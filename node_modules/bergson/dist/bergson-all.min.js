/*! Bergson 0.14.1, Copyright 2019 Colin Clark | github.com/colinbdclark/bergson */


var fluid_3_0_0 = fluid_3_0_0 || {}, fluid = fluid || fluid_3_0_0;

!function(e) {
    "use strict";
    var r = Object.prototype.toString, n = Object.prototype.hasOwnProperty, t = "undefined" != typeof window ? window : "undefined" != typeof self ? self : global, o = t.jQuery, a = t.$, u = e.jQueryStandalone = {
        jquery: "1.6.1-fluidStandalone",
        noConflict: function(e) {
            return t.$ === u && (t.$ = a), e && t.jQuery === u && (t.jQuery = o), u;
        },
        isArray: Array.isArray || function(e) {
            return "[object Array]" === r.call(e);
        },
        isWindow: function(e) {
            return e && "object" == typeof e && "setInterval" in e;
        },
        isPlainObject: function(e) {
            if (!e || "[object Object]" !== r.call(e) || e.nodeType || u.isWindow(e)) return !1;
            if (e.constructor && !n.call(e, "constructor") && !n.call(e.constructor.prototype, "isPrototypeOf")) return !1;
            var t;
            for (t in e) ;
            return void 0 === t || n.call(e, t);
        },
        trim: function(e) {
            return e.trim();
        },
        isEmptyObject: function(e) {
            for (var t in e) return !1;
            return !0;
        },
        extend: function() {
            var e, t = arguments[0] || {}, r = 1, n = arguments.length, o = !1;
            for ("boolean" == typeof t && (o = t, t = arguments[1] || {}, r = 2), "object" != typeof t && "function" != typeof t && (t = {}); r < n; r++) if (null !== (e = arguments[r])) for (var a in e) {
                var i, s, c = t[a], l = e[a];
                if (t !== l) o && l && (u.isPlainObject(l) || (i = u.isArray(l))) ? (s = i ? (i = !1, 
                c && u.isArray(c) ? c : []) : c && u.isPlainObject(c) ? c : {}, t[a] = u.extend(o, s, l)) : void 0 !== l && (t[a] = l);
            }
            return t;
        }
    };
}(fluid_3_0_0);

var jQuery = fluid.jQueryStandalone;

fluid_3_0_0 = fluid_3_0_0 || {}, fluid = fluid || fluid_3_0_0;

!function(g, y) {
    "use strict";
    y.version = "Infusion 3.0.0", y.Error = Error, y.environment = {
        fluid: y
    }, y.global = y.global || "undefined" != typeof window ? window : "undefined" != typeof self ? self : {}, 
    y.invokeLater = function(e) {
        return setTimeout(e, 1);
    }, y.defeatLogging = !0, y.activityTracing = !1, y.activityTrace = [];
    var s = /(%\w+)/g;
    function o(e, t, r, n) {
        for (var o = e[r], a = 0; a < n.length - 1; ++a) o = n[a + 1](o, r);
        t[r] = o;
    }
    y.renderActivityArgument = function(e) {
        return y.isComponent(e) ? y.dumpComponentAndPath(e) : e;
    }, y.renderOneActivity = function(e, t) {
        for (var r = !0 === t ? [] : [ "    while " ], n = e.message, o = s.lastIndex = 0; ;) {
            var a = s.exec(n);
            if (!a) break;
            var i = a[1].substring(1);
            r.push(n.substring(o, a.index)), r.push(y.renderActivityArgument(e.args[i])), o = s.lastIndex;
        }
        return o < n.length && r.push(n.substring(o)), r;
    }, y.renderActivity = function(e, t) {
        return t = t || y.renderOneActivity, y.transform(e, t);
    }, y.singleThreadLocal = function(e) {
        var t = e();
        return function(e) {
            return void 0 === e ? t : t = e;
        };
    }, y.threadLocal = y.singleThreadLocal, y.globalThreadLocal = y.threadLocal(function() {
        return {};
    }), y.getActivityStack = function() {
        var e = y.globalThreadLocal();
        return e.activityStack || (e.activityStack = []), e.activityStack;
    }, y.describeActivity = y.getActivityStack, y.logActivity = function(e) {
        e = e || y.describeActivity();
        var t = y.renderActivity(e).reverse();
        0 < t.length && (y.log("Current activity: "), y.each(t, function(e) {
            y.log.apply(null, e);
        }));
    }, y.pushActivity = function(e, t, r) {
        var n = {
            type: e,
            message: t,
            args: r,
            time: new Date().getTime()
        };
        y.activityTracing && y.activityTrace.push(n), y.passLogLevel(y.logLevel.TRACE) && y.log.apply(null, y.renderOneActivity(n, !0)), 
        y.getActivityStack().push(n);
    }, y.popActivity = function(e) {
        e = e || 1, y.activityTracing && y.activityTrace.push({
            pop: e
        });
        var t = y.getActivityStack(), r = t.length - e;
        t.length = r < 0 ? 0 : r;
    }, y.FluidError = function() {
        var e = Error.apply(this, arguments);
        this.message = e.message;
        try {
            throw e;
        } catch (e) {
            this.stack = e.stack;
        }
        return this;
    }, y.FluidError.prototype = Object.create(Error.prototype), y.logFailure = function(e, t) {
        y.log.apply(null, [ y.logLevel.FAIL, "ASSERTION FAILED: " ].concat(e)), y.logActivity(t);
    }, y.renderLoggingArg = function(e) {
        return void 0 === e ? "undefined" : y.isPrimitive(e) || !y.isPlainObject(e) ? e : JSON.stringify(e);
    }, y.builtinFail = function(e) {
        var t = y.transform(e, y.renderLoggingArg).join("");
        throw new y.FluidError("Assertion failure - check console for more details: " + t);
    }, y.fail = function() {
        var e = y.makeArray(arguments), t = y.makeArray(y.describeActivity());
        y.popActivity(t.length), y.failureEvent ? y.failureEvent.fire(e, t) : (y.logFailure(e, t), 
        y.builtinFail(e, t));
    }, y.notrycatch = !1, y.tryCatch = function(e, t, r) {
        if (r = r || y.identity, y.notrycatch) {
            var n = e();
            return r(), n;
        }
        try {
            return e();
        } catch (e) {
            if (!t) throw e;
            t(e);
        } finally {
            r();
        }
    }, y.expect = function(t, r, e) {
        y.transform(y.makeArray(e), function(e) {
            void 0 === r[e] && y.fail(t + " missing required member " + e);
        });
    }, y.isLogging = function() {
        return r[0].priority > y.logLevel.IMPORTANT.priority;
    }, y.isLogLevel = function(e) {
        return y.isMarker(e) && void 0 !== e.priority;
    }, y.passLogLevel = function(e) {
        return e.priority <= r[0].priority;
    }, y.setLogging = function(e) {
        var t;
        "boolean" == typeof e ? t = y.logLevel[e ? "INFO" : "IMPORTANT"] : y.isLogLevel(e) ? t = e : y.fail("Unrecognised fluid logging level ", e), 
        r.unshift(t), y.defeatLogging = !y.isLogging();
    }, y.setLogLevel = y.setLogging, y.popLogging = function() {
        var e = 1 === r.length ? r[0] : r.shift();
        return y.defeatLogging = !y.isLogging(), e;
    }, y.doBrowserLog = function(e) {
        "undefined" != typeof console && (console.debug ? console.debug.apply(console, e) : "function" == typeof console.log && console.log.apply(console, e));
    }, y.log = function() {
        var e = y.makeArray(arguments), t = y.logLevel.INFO;
        y.isLogLevel(e[0]) && (t = e.shift()), y.passLogLevel(t) && y.loggingEvent.fire(e);
    }, y.isValue = function(e) {
        return null != e;
    }, y.isPrimitive = function(e) {
        var t = typeof e;
        return !e || "string" == t || "boolean" == t || "number" == t || "function" == t;
    }, y.isJQuery = function(e) {
        return Boolean(e && e.jquery && e.constructor && e.constructor.prototype && e.constructor.prototype.jquery);
    }, y.isArrayable = function(e) {
        return Boolean(e) && ("[object Array]" === Object.prototype.toString.call(e) || y.isJQuery(e));
    }, y.isPlainObject = function(e, t) {
        var r = Object.prototype.toString.call(e);
        return "[object Array]" === r ? !t : "[object Object]" === r && (!e.constructor || !e.constructor.prototype || Object.prototype.hasOwnProperty.call(e.constructor.prototype, "isPrototypeOf"));
    }, y.typeCode = function(e) {
        return y.isPrimitive(e) || !y.isPlainObject(e) ? "primitive" : y.isArrayable(e) ? "array" : "object";
    }, y.isIoCReference = function(e) {
        return "string" == typeof e && "{" === e.charAt(0) && 0 < e.indexOf("}");
    }, y.isReferenceOrExpander = function(e) {
        return e && (y.isIoCReference(e) || e.expander);
    }, y.isDOMNode = function(e) {
        return e && "number" == typeof e.nodeType;
    }, y.isComponent = function(e) {
        return e && e.constructor === y.componentConstructor;
    }, y.isUncopyable = function(e) {
        return y.isPrimitive(e) || !y.isPlainObject(e);
    }, y.isApplicable = function(e) {
        return e.apply && "function" == typeof e.apply;
    }, y.identity = function(e) {
        return e;
    }, y.notImplemented = function() {
        y.fail("This operation is not implemented");
    }, y.firstDefined = function(e, t) {
        return void 0 === e ? t : e;
    }, y.freshContainer = function(e) {
        return y.isArrayable(e) ? [] : {};
    }, y.copyRecurse = function(e, n) {
        return n.length > y.strategyRecursionBailout && y.fail("Runaway recursion encountered in fluid.copy - reached path depth of " + y.strategyRecursionBailout + " via path of " + n.join(".") + "this object is probably circularly connected. Either adjust your object structure to remove the circularity or increase fluid.strategyRecursionBailout"), 
        y.isUncopyable(e) ? e : y.transform(e, function(e, t) {
            n.push(t);
            var r = y.copyRecurse(e, n);
            return n.pop(), r;
        });
    }, y.copy = function(e) {
        return y.copyRecurse(e, []);
    }, y.extend = g.extend, y.makeArray = function(e) {
        var t = [];
        if (null != e) if (y.isPrimitive(e) || y.isPlainObject(e, !0) || "number" != typeof e.length) t.push(e); else for (var r = 0; r < e.length; ++r) t[r] = e[r];
        return t;
    }, y.pushArray = function(e, t, r) {
        var n = e[t] ? e[t] : e[t] = [];
        y.isArrayable(r) ? n.push.apply(n, r) : n.push(r);
    }, y.transform = function(e) {
        if (y.isPrimitive(e)) return e;
        var t = y.freshContainer(e);
        if (y.isArrayable(e)) for (var r = 0; r < e.length; ++r) o(e, t, r, arguments); else for (var n in e) o(e, t, n, arguments);
        return t;
    }, y.forEachInRange = function(e, t, r, n) {
        for (var o = t; o < r; ++o) n(e[o], o);
    }, y.peek = function(e) {
        return 0 === e.length ? void 0 : e[e.length - 1];
    }, y.each = function(e, t) {
        if (y.isArrayable(e)) for (var r = 0; r < e.length; ++r) t(e[r], r); else for (var n in e) t(e[n], n);
    }, y.make_find = function(i) {
        var s = !i && void 0;
        return function(e, t, r) {
            var n;
            if (y.isArrayable(e)) {
                for (var o = 0; o < e.length; ++o) if ((n = t(e[o], o)) !== s) return i ? e[o] : n;
            } else for (var a in e) if ((n = t(e[a], a)) !== s) return i ? e[a] : n;
            return r;
        };
    }, y.find = y.make_find(!1), y.find_if = y.make_find(!0), y.accumulate = function(e, t, r) {
        for (var n = 0; n < e.length; ++n) r = t(e[n], r, n);
        return r;
    }, y.add = function(e, t) {
        return e + t;
    }, y.remove_if = function(e, t, r) {
        if (y.isArrayable(e)) for (var n = e.length - 1; 0 <= n; --n) t(e[n], n) && (r && r.unshift(e[n]), 
        e.splice(n, 1)); else for (var o in e) t(e[o], o) && (r && (r[o] = e[o]), delete e[o]);
        return r || e;
    }, y.generate = function(e, t, r) {
        for (var n = [], o = 0; o < e; ++o) n[o] = r ? t(o) : t;
        return n;
    }, y.iota = function(e, t) {
        t = t || 0;
        for (var r = [], n = 0; n < e; ++n) r[r.length] = t++;
        return r;
    }, y.getMembers = function(e, t) {
        return y.transform(e, function(e) {
            return y.get(e, t);
        });
    }, y.filterKeys = function(e, r, n) {
        return y.remove_if(g.extend({}, e), function(e, t) {
            return n ^ -1 === r.indexOf(t);
        });
    }, y.censorKeys = function(e, t) {
        return y.filterKeys(e, t, !0);
    }, y.keys = function(e) {
        var t = [];
        for (var r in e) t.push(r);
        return t;
    }, y.values = function(e) {
        var t = [];
        for (var r in e) t.push(e[r]);
        return t;
    }, y.contains = function(e, t) {
        return e ? y.isArrayable(e) ? -1 !== e.indexOf(t) : y.find(e, function(e) {
            if (t === e) return !0;
        }) : void 0;
    }, y.keyForValue = function(e, r) {
        return y.find(e, function(e, t) {
            if (r === e) return t;
        });
    }, y.arrayToHash = function(e) {
        var t = {};
        return y.each(e, function(e) {
            t[e] = !0;
        }), t;
    }, y.stableSort = function(e, t) {
        for (var r = 0; r < e.length; r++) {
            var n, o = e[r];
            for (n = r; 0 < n && t(o, e[n - 1]) < 0; n--) e[n] = e[n - 1];
            e[n] = o;
        }
    }, y.hashToArray = function(e, n, o) {
        var a = [];
        return y.each(e, function(e, t) {
            var r = {};
            r[n] = t, o ? r = o(r, e, t) || r : g.extend(!0, r, e), a.push(r);
        }), a;
    }, y.flatten = function(e) {
        var t = [];
        return y.each(e, function(e) {
            y.isArrayable(e) ? t = t.concat(e) : t.push(e);
        }), t;
    }, y.clear = function(e) {
        if (y.isArrayable(e)) e.length = 0; else for (var t in e) delete e[t];
    }, y.compareStringLength = function(e) {
        return e ? function(e, t) {
            return e.length - t.length;
        } : function(e, t) {
            return t.length - e.length;
        };
    }, y.parseInteger = function(e) {
        return isFinite(e) && e % 1 == 0 ? Number(e) : NaN;
    }, y.isInteger = function(e) {
        return "number" == typeof e && isFinite(e) && Math.floor(e) === e;
    }, y.roundToDecimal = function(e, t, r) {
        return t = t && 0 <= t ? Math.round(t) : 0, "ceil" === r || "floor" === r ? Number(Math[r](e + "e" + t) + "e-" + t) : Number((0 <= e ? 1 : -1) * (Math.round(Math.abs(e) + "e" + t) + "e-" + t));
    }, y.debounce = function(n, o, a) {
        var i, s;
        return function() {
            var e = this, t = arguments, r = a && !i;
            return clearTimeout(i), i = setTimeout(function() {
                i = null, a || (s = n.apply(e, t));
            }, o), r && (s = n.apply(e, t)), s;
        };
    }, y.freezeRecursive = function(e) {
        return y.isPlainObject(e) ? (y.each(e, function(e) {
            y.freezeRecursive(e);
        }), Object.freeze(e)) : e;
    }, y.marker = function() {}, y.makeMarker = function(e, t) {
        var r = Object.create(y.marker.prototype);
        return r.value = e, g.extend(r, t), Object.freeze(r);
    }, y.VALUE = y.makeMarker("VALUE"), y.NO_VALUE = y.makeMarker("NO_VALUE"), y.EXPAND = y.makeMarker("EXPAND"), 
    y.isMarker = function(e, t) {
        return e instanceof y.marker && (!t || e.value === t.value);
    }, y.logLevelsSpec = {
        FATAL: 0,
        FAIL: 5,
        WARN: 10,
        IMPORTANT: 12,
        INFO: 15,
        TRACE: 20
    }, y.logLevel = y.transform(y.logLevelsSpec, function(e, t) {
        return y.makeMarker(t, {
            priority: e
        });
    });
    var r = [ y.logLevel.IMPORTANT ];
    y.model = {}, y.model.copyModel = function(e, t) {
        y.clear(e), g.extend(!0, e, t);
    }, y.model.parseEL = function(e) {
        return "" === e ? [] : String(e).split(".");
    }, y.model.composePath = function(e, t) {
        return "" === e ? t : "" === t ? e : e + "." + t;
    }, y.model.composeSegments = function() {
        return y.makeArray(arguments).join(".");
    }, y.lastDotIndex = function(e) {
        return e.lastIndexOf(".");
    }, y.model.getToTailPath = function(e) {
        var t = y.lastDotIndex(e);
        return -1 === t ? "" : e.substring(0, t);
    }, y.model.getTailPath = function(e) {
        var t = y.lastDotIndex(e);
        return e.substring(t + 1);
    }, y.path = y.model.composeSegments, y.composePath = y.model.composePath, y.requireDataBinding = function() {
        y.fail("Please include DataBinding.js in order to operate complex model accessor configuration");
    }, y.model.setWithStrategy = y.model.getWithStrategy = y.requireDataBinding, y.model.resolvePathSegment = function(e, t, r, n) {
        if (!n && e.resolvePathSegment) {
            var o = e.resolvePathSegment(t);
            if (void 0 !== o) return o;
        }
        return r && void 0 === e[t] ? e[t] = {} : e[t];
    }, y.model.parseToSegments = function(e, t, r) {
        return "number" == typeof e || "string" == typeof e ? t(e) : r ? y.makeArray(e) : e;
    }, y.model.pathToSegments = function(e, t) {
        var r = t && t.parser ? t.parser.parse : y.model.parseEL;
        return y.model.parseToSegments(e, r);
    }, y.model.accessImpl = function(e, t, r, n, o, a, i) {
        var s = y.model.pathToSegments(t, n), c = 0;
        if (o && (c = o.length, s = o.concat(s)), e = i(e, s, c, n, r === y.NO_VALUE ? 0 : 1), 
        r === y.NO_VALUE || r === y.VALUE) return a ? {
            root: e,
            segs: s
        } : e;
        e[y.peek(s)] = r;
    }, y.model.accessSimple = function(e, t, r, n, o, a) {
        return y.model.accessImpl(e, t, r, n, o, a, y.model.traverseSimple);
    }, y.model.traverseSimple = function(e, t, r, n, o) {
        for (var a = n, i = t.length - o, s = 0; s < i; ++s) {
            if (!e) return;
            var c = t[s];
            e = n && n[c] ? n[c] : y.model.resolvePathSegment(e, c, 1 === o, a), n = null;
        }
        return e;
    }, y.model.setSimple = function(e, t, r, n, o) {
        y.model.accessSimple(e, t, r, n, o, !1);
    }, y.model.getSimple = function(e, t, r, n) {
        return null == t || 0 === t.length ? e : y.model.accessSimple(e, t, y.NO_VALUE, r, n, !1);
    }, y.getImmediate = function(e, t, r) {
        for (var n = void 0 === r ? t.length : r + 1, o = 0; o < n; ++o) e = e ? e[t[o]] : void 0;
        return e;
    }, y.decodeAccessorArg = function(e) {
        return e && e !== y.model.defaultGetConfig && e !== y.model.defaultSetConfig ? "environment" === e.type ? e.value : void 0 : null;
    }, y.set = function(e, t, r, n, o) {
        var a = y.decodeAccessorArg(n);
        void 0 === a ? y.model.setWithStrategy(e, t, r, n, o) : y.model.setSimple(e, t, r, a, o);
    }, y.get = function(e, t, r, n) {
        var o = y.decodeAccessorArg(r);
        return void 0 === o ? y.model.getWithStrategy(e, t, r, n) : y.model.accessImpl(e, t, y.NO_VALUE, o, null, !1, y.model.traverseSimple);
    }, y.getGlobalValue = function(e, t) {
        if (e) return t = t || y.environment, y.get(y.global, e, {
            type: "environment",
            value: t
        });
    }, y.bind = function(e, t, r) {
        return e[t].apply(e, y.makeArray(r));
    }, y.invokeGlobalFunction = function(e, t, r) {
        var n = y.getGlobalValue(e, r);
        if (n) return n.apply(null, y.isArrayable(t) ? t : y.makeArray(t));
        y.fail("Error invoking global function: " + e + " could not be located");
    }, y.registerGlobalFunction = function(e, t, r) {
        r = r || y.environment, y.set(y.global, e, t, {
            type: "environment",
            value: r
        });
    }, y.setGlobalValue = y.registerGlobalFunction, y.registerNamespace = function(e, t) {
        t = t || y.environment;
        var r = y.getGlobalValue(e, t);
        return r || (r = {}, y.setGlobalValue(e, r, t)), r;
    }, y.dumpEl = y.identity, y.renderTimestamp = y.identity, y.generateUniquePrefix = function() {
        return Math.floor(1e12 * Math.random()).toString(36) + "-";
    };
    var e = y.generateUniquePrefix();
    y.fluidInstance = e;
    var t = 1;
    y.allocateGuid = function() {
        return e + t++;
    }, y.registerNamespace("fluid.event"), y.extremePriority = 4e9, y.priorityTypes = {
        first: -1,
        last: 1,
        before: 0,
        after: 0
    }, y.extremalPriorities = {
        none: 0,
        transaction: 10,
        testing: 20,
        authoring: 30
    }, y.parsePriorityConstraint = function(e, t, r) {
        var n = e.split(":"), o = n[0], a = y.priorityTypes[o];
        return void 0 === a && y.fail("Invalid constraint type in priority field " + e + ": the only supported values are " + y.keys(y.priorityTypes).join(", ") + " or numeric"), 
        t && 0 === a && y.fail("Constraint type in priority field " + e + " is not supported in a " + r + " record - you must use either a numeric value or first, last"), 
        {
            type: n[0],
            target: n[1]
        };
    }, y.parsePriority = function(e, t, r, n) {
        var o = {
            count: t || 0,
            fixed: null,
            constraint: null,
            site: n
        };
        "number" == typeof (e = e || 0) ? o.fixed = -e : o.constraint = y.parsePriorityConstraint(e, r, n);
        var a = o.constraint ? y.priorityTypes[o.constraint.type] : 0;
        if (0 !== a) {
            var i = o.constraint.target || "none", s = y.extremalPriorities[i];
            void 0 === s && y.fail("Unrecognised extremal priority target " + i + ": the currently supported values are " + y.keys(y.extremalPriorities).join(", ") + ": register your value in fluid.extremalPriorities"), 
            o.fixed = a * (y.extremePriority + s);
        }
        return null !== o.fixed && (o.fixed += o.count / 1024), o;
    }, y.renderPriority = function(e) {
        return e.constraint ? e.constraint.target ? e.constraint.type + ":" + e.constraint.target : e.constraint.type : Math.floor(e.fixed);
    }, y.compareByPriority = function(e, t) {
        return null !== e.priority.fixed && null !== t.priority.fixed ? e.priority.fixed - t.priority.fixed : (null === e.priority.fixed) - (null === t.priority.fixed);
    }, y.honourConstraint = function(e, t, r) {
        var n = e[r].priority.constraint, o = y.find(e, function(e, t) {
            return e.namespace === n.target ? t : void 0;
        }, -1);
        if (-1 === o) return !0;
        if (t <= o) return !1;
        for (var a = o + ("after" === n.type ? 1 : 0), i = e[r], s = r; a <= s; --s) e[s] = e[s - 1];
        return e[a] = i, !0;
    }, y.sortByPriority = function(e) {
        y.stableSort(e, y.compareByPriority);
        for (var t = y.find(e, function(e, t) {
            return e.priority.constraint && 0 === y.priorityTypes[e.priority.constraint.type] ? t : void 0;
        }, e.length); ;) {
            if (t === e.length) return e;
            for (var r = t, n = t; n < e.length; ++n) {
                y.honourConstraint(e, t, n) && ++t;
            }
            if (t === r) {
                var o = e.slice(t);
                y.fail("Could not find targets for any constraints in " + o[0].priority.site + " ", o, ": none of the targets (" + y.getMembers(o, "priority.constraint.target").join(", ") + ") matched any namespaces of the elements in (", e.slice(0, t), ") - this is caused by either an invalid or circular reference");
            }
        }
    }, y.parsePriorityRecords = function(e, r) {
        var t = y.hashToArray(e, "namespace", function(e, t) {
            g.extend(e, t), e.priority = y.parsePriority(t.priority, 0, !1, r);
        });
        return y.sortByPriority(t), t;
    }, y.event.identifyListener = function(e, t) {
        return "string" == typeof e || e.$$fluid_guid || t || (e.$$fluid_guid = y.allocateGuid()), 
        e.$$fluid_guid;
    }, y.event.impersonateListener = function(e, t) {
        y.event.identifyListener(e), t.$$fluid_guid = e.$$fluid_guid;
    }, y.event.sortListeners = function(e) {
        var o = [];
        return y.each(e, function(e) {
            for (var t, r = 0; r < e.length; ++r) {
                var n = e[r];
                n.softNamespace || t || (t = n);
            }
            t ? o.push(t) : o = o.concat(e);
        }), y.sortByPriority(o);
    }, y.event.resolveListener = function(e) {
        var t = e.globalName || ("string" == typeof e ? e : null);
        if (t) {
            var r = y.getGlobalValue(t);
            r ? e = r : y.fail("Unable to look up name " + t + " as a global function");
        }
        return e;
    }, y.nameComponent = function(e) {
        return e ? "component with typename " + e.typeName + " and id " + e.id : "[unknown component]";
    }, y.event.nameEvent = function(e, t) {
        return t + " of " + y.nameComponent(e);
    }, y.makeEventFirer = function(a) {
        var s, e = (a = a || {}).name || "<anonymous>";
        return s = {
            eventId: y.allocateGuid(),
            name: e,
            ownerId: a.ownerId,
            typeName: "fluid.event.firer",
            destroy: function() {
                s.destroyed = !0;
            },
            addListener: function() {
                (function() {
                    s.listeners = {}, s.byId = {}, s.sortedListeners = [], s.addListener = function(e, t, r, n, o) {
                        var a;
                        if (s.destroyed && y.fail("Cannot add listener to destroyed event firer " + s.name), 
                        e) {
                            y.isPlainObject(e, !0) && !y.isApplicable(e) && (e = (a = e).listener, t = a.namespace, 
                            r = a.priority, n = a.softNamespace, o = a.listenerId), "string" == typeof e && (e = {
                                globalName: e
                            });
                            var i = o || y.event.identifyListener(e);
                            t = t || i, a = g.extend(a || {}, {
                                namespace: t,
                                listener: e,
                                softNamespace: n,
                                listenerId: o,
                                priority: y.parsePriority(r, s.sortedListeners.length, !1, "listeners")
                            }), s.byId[i] = a, (s.listeners[t] = y.makeArray(s.listeners[t]))[n ? "push" : "unshift"](a), 
                            s.sortedListeners = y.event.sortListeners(s.listeners);
                        }
                    }, s.addListener.apply(null, arguments);
                }).apply(null, arguments);
            },
            removeListener: function(e) {
                if (s.listeners) {
                    var t, r, n;
                    "string" == typeof e ? (t = e, (n = s.listeners[t]) || (r = t, t = null)) : "function" == typeof e && ((r = y.event.identifyListener(e, !0)) || y.fail("Cannot remove unregistered listener function ", e, " from event " + s.name));
                    var o = s.byId[r], a = o && o.softNamespace;
                    t = t || o && o.namespace || r, delete s.byId[r], (n = s.listeners[t]) && (a ? y.remove_if(n, function(e) {
                        return e.listener.$$fluid_guid === r || e.listenerId === r;
                    }) : n.shift(), 0 === n.length && delete s.listeners[t]), s.sortedListeners = y.event.sortListeners(s.listeners);
                }
            },
            fire: function() {
                var e = s.sortedListeners;
                if (e && !s.destroyed) for (var t = 0; t < e.length; ++t) {
                    var r = e[t];
                    "function" != typeof r.listener && (r.listener = y.event.resolveListener(r.listener));
                    var n, o = r.listener.apply(null, arguments);
                    if ((a.preventable && !1 === o || s.destroyed) && (n = !1), void 0 !== n) return n;
                }
            }
        };
    }, y.fireEvent = function(e, t, r) {
        var n = e.events && e.events[t];
        n && n.fire.apply(null, y.makeArray(r));
    }, y.event.addListenerToFirer = function(e, t, r, n) {
        if (n = n || y.identity, y.isArrayable(t)) for (var o = 0; o < t.length; ++o) y.event.addListenerToFirer(e, t[o], r, n); else "function" == typeof t || "string" == typeof t ? n(e).addListener(t, r) : t && "object" == typeof t && n(e).addListener(t.listener, r || t.namespace, t.priority, t.softNamespace, t.listenerId);
    }, y.event.resolveListenerRecord = function(e) {
        return {
            records: e
        };
    }, y.expandImmediate = function(e) {
        y.fail("fluid.expandImmediate could not be loaded - please include FluidIoC.js in order to operate IoC-driven event with descriptor " + e);
    }, y.mergeListeners = function(i, s, e) {
        y.each(e, function(e, t) {
            var r, n;
            if (y.isIoCReference(t)) (r = y.expandImmediate(t, i)) || y.fail("Error in listener record: key " + t + ' could not be looked up to an event firer - did you miss out "events." when referring to an event firer?'); else {
                var o = t.indexOf(".");
                -1 !== o && (n = t.substring(o + 1), t = t.substring(0, o)), s[t] || y.fail("Listener registered for event " + t + " which is not defined for this component"), 
                r = s[t];
            }
            var a = y.event.resolveListenerRecord(e, i, t, n, !0);
            y.event.addListenerToFirer(r, a.records, n, a.adderWrapper);
        });
    }, y.eventFromRecord = function(e, t, r) {
        var n;
        return e && ("string" != typeof e || y.isIoCReference(e)) ? y.event.resolveEvent ? n = y.event.resolveEvent(r, t, e) : y.fail("fluid.event.resolveEvent could not be loaded - please include FluidIoC.js in order to operate IoC-driven event with descriptor ", e) : n = y.makeEventFirer({
            name: y.event.nameEvent(r, t),
            preventable: "preventable" === e,
            ownerId: r.id
        }), n;
    }, y.mergeListenerPolicy = function(e, t, r) {
        return "string" != typeof r && y.fail("Error in listeners declaration - the keys in this structure must resolve to event names - got " + r + " from ", t), 
        !y.isIoCReference(r) && -1 !== r.indexOf(".") ? t || e : y.arrayConcatPolicy(e, t);
    }, y.makeMergeListenersPolicy = function(n, t) {
        return function(r, e) {
            return r = r || {}, t && (y.isArrayable(e) || "string" == typeof e.target) ? r[""] = n(r[""], e, "") : y.each(e, function(e, t) {
                r[t] = n(r[t], e, t);
            }), r;
        };
    }, y.validateListenersImplemented = function(r) {
        var n = [];
        return y.each(r.events, function(e, t) {
            y.each(e.sortedListeners, function(e) {
                e.listener !== y.notImplemented && "fluid.notImplemented" !== e.listener.globalName || n.push({
                    name: t,
                    namespace: e.namespace,
                    componentSource: y.model.getSimple(r.options.listeners, [ t + "." + e.namespace, 0, "componentSource" ])
                });
            });
        }), n;
    }, y.arrayConcatPolicy = function(e, t) {
        return y.makeArray(e).concat(y.makeArray(t));
    }, y.loggingEvent = y.makeEventFirer({
        name: "logging event"
    }), y.addTimestampArg = function(e) {
        var t = y.renderTimestamp(new Date()) + ":  ";
        e.unshift(t);
    }, y.loggingEvent.addListener(y.doBrowserLog, "log"), y.loggingEvent.addListener(y.identity, "filterArgs", "before:log"), 
    y.loggingEvent.addListener(y.addTimestampArg, "addTimestampArg", "after:filterArgs"), 
    y.failureEvent = y.makeEventFirer({
        name: "failure event"
    }), y.failureEvent.addListener(y.builtinFail, "fail"), y.failureEvent.addListener(y.logFailure, "log", "before:fail"), 
    y.pushSoftFailure = function(e) {
        y.log(y.logLevel.WARN, "fluid.pushSoftFailure is deprecated and will be removed in the FLUID-6148 release"), 
        "function" == typeof e ? y.failureEvent.addListener(e, "fail") : -1 === e ? y.failureEvent.removeListener("fail") : "boolean" == typeof e && y.fail("pushSoftFailure with boolean value is no longer supported");
    }, y.componentConstructor = function() {}, y.typeTag = function(e, t) {
        var r = Object.create(y.componentConstructor.prototype);
        return r.typeName = e, r.id = t || y.allocateGuid(), r;
    };
    var c = 1, l = {};
    function b(e, t, r, n) {
        for (var o = 0; o < r; ++o) e = n(e, t[o], o, y.makeArray(t));
        return e;
    }
    y.defaultsStore = {}, y.resolveGradesImpl = function(e, t) {
        for (var r = (t = y.makeArray(t)).length - 1; 0 <= r; --r) {
            var n = t[r];
            if (n && !e.gradeHash[n]) {
                var o = (y.isIoCReference(n) ? null : y.rawDefaults(n)) || {}, a = l[n] || c - 1;
                e.lastTick = Math.max(e.lastTick, a), e.gradeHash[n] = !0, e.gradeChain.push(n);
                for (var i = y.makeArray(o.gradeNames), s = i.length - 1; 0 <= s; --s) y.resolveGradesImpl(e, i[s]);
            }
        }
        return e;
    }, y.resolveGradeStructure = function(e, t) {
        var r = {
            lastTick: 0,
            gradeChain: [],
            gradeHash: {}
        };
        return y.resolveGradesImpl(r, [ e ].concat(y.makeArray(t))), r.gradeChain.reverse(), 
        r;
    }, y.hasGrade = function(e, t) {
        return !(!e || !e.gradeNames) && y.contains(e.gradeNames, t);
    }, y.resolveGrade = function(e, t, r) {
        var n = y.resolveGradeStructure(t, r), o = y.transform(n.gradeChain, y.rawDefaults, y.copy);
        y.remove_if(o, function(e) {
            return !e;
        });
        for (var a = {}, i = 0; i < o.length; ++i) o[i] && o[i].mergePolicy && (a = g.extend(!0, a, o[i].mergePolicy));
        o = [ a, {} ].concat(o);
        var s = y.merge.apply(null, o);
        return s.gradeNames = n.gradeChain, y.freezeRecursive(s), {
            defaults: s,
            lastTick: n.lastTick
        };
    }, y.mergedDefaultsCache = {}, y.gradeNamesToKey = function(e, t) {
        return e + "|" + t.join("|");
    }, y.getMergedDefaults = function(e, t) {
        t = y.makeArray(t);
        var r = y.gradeNamesToKey(e, t), n = y.mergedDefaultsCache[r];
        if (n) {
            for (var o = 0, a = n.defaults.gradeNames, i = 0; i < a.length; ++i) o = Math.max(o, l[a[i]] || 0);
            o > n.lastTick && (y.passLogLevel(y.logLevel.TRACE) && y.log(y.logLevel.TRACE, "Clearing cache for component " + e + " with gradeNames ", a), 
            n = null);
        }
        if (!n) {
            var s = y.rawDefaults(e);
            if (!s) return s;
            n = y.mergedDefaultsCache[r] = y.resolveGrade(s, e, t);
        }
        return n.defaults;
    }, y.upgradePrimitiveFunc = function(e, t) {
        if (e && y.isPrimitive(e)) {
            var r = {};
            return r[t || ("string" == typeof e && "{" !== e.charAt(0) ? "funcName" : "func")] = e, 
            r.args = y.NO_VALUE, r;
        }
        return e;
    }, y.annotateListeners = function(r, e) {
        e.listeners = y.transform(e.listeners, function(e) {
            var t = y.makeArray(e);
            return y.transform(t, function(e) {
                return (e = y.upgradePrimitiveFunc(e, "listener")).componentSource = r, e;
            });
        }), e.invokers = y.transform(e.invokers, function(e) {
            return (e = y.upgradePrimitiveFunc(e)) && (e.componentSource = r), e;
        });
    }, y.workflowCache = {}, y.workflowCacheSorted = [], y.resortWorkflows = function(e, r) {
        var n = y.workflowCache[e], t = y.parsePriorityRecords(n, e + " workflows");
        return t.forEach(function(e, t) {
            n[e.namespace].index = t + r;
        }), t;
    }, y.indexOneWorkflows = function(r, n, e, t) {
        return y.each(e, function(e, t) {
            y.model.setSimple(y.workflowCache, [ n, t ], {
                workflowType: n,
                workflowName: t,
                priority: e.priority,
                gradeName: r,
                workflowOptions: e
            });
        }), y.resortWorkflows(n, t);
    }, y.clearGradeWorkflows = function(r, e) {
        var n = y.workflowCache[e];
        y.each(n, function(e, t) {
            e.gradeName === r && delete n[t];
        });
    }, y.indexGradeWorkflows = function(e, t) {
        y.clearGradeWorkflows(e, "global"), y.clearGradeWorkflows(e, "local");
        var r = y.indexOneWorkflows(e, "global", y.getImmediate(t, [ "workflows", "global" ]), 0), n = r.length, o = y.indexOneWorkflows(e, "local", y.getImmediate(t, [ "workflows", "local" ]), n);
        y.workflowCacheSorted = r.concat(o);
    }, y.rawDefaults = function(e) {
        var t = y.defaultsStore[e];
        return t && t.options;
    }, y.registerRawDefaults = function(e, t) {
        y.pushActivity("registerRawDefaults", "registering defaults for grade %componentName with options %options", {
            componentName: e,
            options: t
        });
        var r = y.expandCompact ? y.expandCompact(t) : y.copy(t);
        y.annotateListeners(e, r), y.indexGradeWorkflows(e, r), delete r.workflows;
        var n = y.getCallerInfo && y.getCallerInfo(6);
        y.freezeRecursive(r), y.defaultsStore[e] = {
            options: r,
            callerInfo: n
        }, l[e] = c++, y.popActivity();
    }, y.doIndexDefaults = function(e, t, r, n) {
        for (var o = y.makeArray(n.gradeNames), a = 0; a < o.length; ++a) if (!y.hasGrade(t, o[a])) return;
        for (var i = ("function" == typeof n.indexFunc ? n.indexFunc : y.getGlobalValue(n.indexFunc))(t) || [], s = 0; s < i.length; ++s) y.pushArray(r, i[s], e);
    }, y.indexDefaults = function(e, t) {
        var r = {};
        for (var n in y.defaultsStore) {
            var o = y.getMergedDefaults(n);
            y.doIndexDefaults(n, o, r, t);
        }
        return r;
    }, y.defaults = function(e, t) {
        if (void 0 === t) return y.getMergedDefaults(e);
        t && t.options && y.fail("Probable error in options structure for " + e + ' with option named "options" - perhaps you meant to write these options at top level in fluid.defaults? - ', t), 
        y.registerRawDefaults(e, t);
        var r = y.getMergedDefaults(e);
        y.hasGrade(r, "fluid.function") || y.makeComponentCreator(e);
    }, y.validateCreatorGrade = function(e, t) {
        var r = y.getMergedDefaults(t);
        if (r && r.gradeNames && 0 !== r.gradeNames.length) {
            if (!r.argumentMap) {
                for (var n = [], o = 0; o < r.gradeNames.length; ++o) {
                    var a = r.gradeNames[o];
                    y.rawDefaults(a) || n.push(a);
                }
                0 === n.length ? y.fail(e + " type " + t + " which is not derived from fluid.component") : y.fail("The grade hierarchy of component with type " + t + " is incomplete - it inherits from the following grade(s): " + n.join(", ") + " for which the grade definitions are corrupt or missing. Please check the files which might include these grades and ensure they are readable and have been loaded by this instance of Infusion");
            }
        } else y.fail(e + " type " + t + " which does not have any gradeNames defined");
    }, y.makeComponentCreator = function(e) {
        function t() {
            return y.validateCreatorGrade("Cannot make component creator for", e), y.initFreeComponent(e, arguments);
        }
        var r = y.getGlobalValue(e);
        r && g.extend(t, r), y.setGlobalValue(e, t);
    }, y.emptyPolicy = y.freezeRecursive({}), y.derefMergePolicy = function(e) {
        return (e ? e["*"] : y.emptyPolicy) || y.emptyPolicy;
    }, y.compileMergePolicy = function(e) {
        var i = {}, s = {}, c = {
            builtins: i,
            defaultValues: s
        };
        return e && y.each(e, function(e, t) {
            var r = {}, n = !0;
            if ("function" == typeof e) r.func = e; else if ("object" == typeof e) r = e; else if (y.isDefaultValueMergePolicy(e)) y.set(s, t, "{that}.options." + e), 
            n = !(c.hasDefaults = !0); else for (var o = e.split(/\s*,\s*/), a = 0; a < o.length; ++a) r[o[a]] = !0;
            n && y.set(i, y.composePath(t, "*"), r);
        }), c;
    }, y.isDefaultValueMergePolicy = function(e) {
        return "string" == typeof e && -1 === e.indexOf(",") && !/replace|nomerge|noexpand/.test(e);
    }, y.mergeOneImpl = function(e, t, r, n, o, a, i, s) {
        var c = e, l = y.isPrimitive(e);
        return void 0 !== t && (o.func || null === t || !y.isPlainObject(t) || o.nomerge ? (n[r] = void 0, 
        c = o.func ? o.func.call(null, e, t, a, s, i) : t) : l && (c = e = y.freshContainer(t))), 
        c;
    }, y.fetchMergeChildren = function(n, o, a, i, s, c) {
        for (var e = y.derefMergePolicy(s), t = i.length - 1; 0 <= t; --t) {
            var r = i[t];
            if (void 0 !== r && (y.each(r, function(e, t) {
                var r = y.concreteTrundler(s, t);
                t in n && (!c.evaluateFully || void 0 !== r || y.isPrimitive(n[t])) || (a[o] = t, 
                c.strategy(n, t, o + 1, a, i, s));
            }), e.replace)) break;
        }
        return n;
    }, y.inEvaluationMarker = Object.freeze({
        __CURRENTLY_IN_EVALUATION__: !0
    }), y.strategyRecursionBailout = 50, y.makeMergeStrategy = function(v) {
        function e(e, t, r, n, o, a) {
            if (r > y.strategyRecursionBailout && y.fail("Overflow/circularity in options merging, current path is ", n, " at depth ", r, ' - please protect components from merging using the "nomerge" merge policy'), 
            !y.isPrimitive(e)) {
                var i;
                if (y.isTracing && y.tracing.pathCount.push(y.path(n.slice(0, r))), t in e) {
                    if (i = e[t], !v.evaluateFully) return i;
                } else e !== y.inEvaluationMarker && (e[t] = y.inEvaluationMarker);
                void 0 === o && (n = y.makeArray(n), o = function(e, t, r, n) {
                    for (var o = [], a = 0; a < e.length; ++a) {
                        var i = b(e[a], t, r, n[a]);
                        void 0 !== i && o.push(i);
                    }
                    return o;
                }(v.sources, n, r - 1, v.sourceStrategies), a = b(v.mergePolicy, n, r - 1, y.concreteTrundler));
                var s, c, l, u = y.concreteTrundler(a, t), d = y.derefMergePolicy(u);
                l = d.replace ? (s = 1 - o.length, c = 0, -1) : (s = 0, c = o.length - 1, 1);
                for (var p, f = [], m = s; m <= c; ++m) {
                    var g = l * m, h = v.sourceStrategies[g](o[g], t, r, n);
                    if (void 0 !== h && (y.isPrimitive(h) || (f[g] = h), void 0 === i)) {
                        if (-1 === l) {
                            p = e[t] = h;
                            break;
                        }
                        p = y.mergeOneImpl(p, h, m, f, d, u, r, n, v), e !== y.inEvaluationMarker && (e[t] = p);
                    }
                }
                return void 0 !== i && (p = i), 0 < f.length && y.isPlainObject(p) && y.fetchMergeChildren(p, r, n, f, u, v), 
                void 0 === i && 0 === f.length && delete e[t], p;
            }
        }
        return v.strategy = e;
    }, y.driveStrategy = function(e, t, r) {
        t = y.makeArray(t);
        for (var n = 0; n < t.length; ++n) {
            if (!e) return;
            e = r(e, t[n], n + 1, t);
        }
        return e;
    }, y.concreteTrundler = function(e, t) {
        return e ? e[t] : void 0;
    }, y.merge = function(e) {
        var t = Array.prototype.slice.call(arguments, 1), r = y.compileMergePolicy(e).builtins, n = y.makeMergeOptions(r, t, {});
        return n.initter(), n.target;
    }, y.makeMergeOptions = function(e, t, r) {
        var n = {
            mergePolicy: e,
            sources: t
        };
        return (n = g.extend(n, r)).target = n.target || y.freshContainer(n.sources[0]), 
        n.sourceStrategies = n.sourceStrategies || y.generate(n.sources.length, y.concreteTrundler), 
        n.initter = function() {
            n.evaluateFully = !0, y.fetchMergeChildren(n.target, 0, [], n.sources, n.mergePolicy, n);
        }, y.makeMergeStrategy(n), n;
    }, y.transformOptions = function(e, t) {
        return y.expect("Options transformation record", t, [ "transformer", "config" ]), 
        y.getGlobalValue(t.transformer).call(null, e, t.config);
    }, y.findMergeBlocks = function(e, t) {
        return y.remove_if(y.makeArray(e), function(e) {
            return e.recordType !== t;
        });
    }, y.transformOptionsBlocks = function(r, n, e) {
        y.each(e, function(e) {
            var t = y.findMergeBlocks(r, e);
            y.each(t, function(e) {
                var t = e.source ? "source" : "target";
                e[e.simple || "target" == t ? "target" : "source"] = y.transformOptions(e[t], n);
            });
        });
    }, y.dedupeDistributionNamespaces = function(e) {
        var r = {};
        y.remove_if(e, function(e) {
            var t = e.namespace;
            if (t) {
                if (r[t] && r[t] !== e.contextThat.id) return !0;
                r[t] = e.contextThat.id;
            }
        });
    }, y.mergeRecordTypes = {
        defaults: 1e3,
        defaultValueMerge: 900,
        lensedComponents: 800,
        subcomponentRecord: 700,
        user: 600,
        distribution: 100
    }, y.model.applyChangeRequest = function(e, t) {
        var r = t.segs;
        if (0 === r.length) "ADD" === t.type ? g.extend(!0, e, t.value) : y.clear(e); else if ("ADD" === t.type) y.model.setSimple(e, t.segs, t.value); else {
            for (var n = 0; n < r.length - 1; ++n) if (!(e = e[r[n]])) return;
            delete e[y.peek(r)];
        }
    }, y.destroyValue = function(e, t) {
        e && y.model.applyChangeRequest(e, {
            type: "DELETE",
            segs: t
        });
    }, y.mergeComponentOptions = function(e, t, r) {
        y.validateCreatorGrade("Cannot construct component of", r.type);
        function n() {
            y.each(a, function(e) {
                y.isPrimitive(e.priority) && (e.priority = y.parsePriority(e.priority, 0, !1, "options distribution"));
            }), y.sortByPriority(a), y.dedupeDistributionNamespaces(a), s.length = 0, c.length = 0, 
            y.each(a, function(e) {
                s.push(e.strategy), c.push(e.target);
            });
        }
        var o = {}, a = y.expandComponentOptions(o, t, r, e), i = {}, s = [], c = [], l = {
            target: i,
            sourceStrategies: s
        };
        n();
        var u, d, p = y.makeMergeOptions(o, c, l);
        function f() {
            d = y.driveStrategy(i, "mergePolicy", p.strategy), d = g.extend({}, y.rootMergePolicy, d), 
            u = y.compileMergePolicy(d), g.extend(!0, o, u.builtins);
        }
        p.mergeBlocks = a, p.updateBlocks = n, p.destroyValue = function(e) {
            for (var t = 0; t < a.length; ++t) a[t].immutableTarget || y.destroyValue(a[t].target, e);
            y.destroyValue(l.target, e);
        }, f(), p.computeMergePolicy = f, u.hasDefaults && (a.push(y.generateExpandBlock({
            options: u.defaultValues,
            recordType: "defaultValueMerge",
            priority: y.mergeRecordTypes.defaultValueMerge
        }, e, {})), n()), e.options = i, y.driveStrategy(i, "gradeNames", p.strategy), y.deliverOptionsStrategy(e, i, p), 
        y.computeComponentAccessor(e, t.localRecord);
        var m = y.driveStrategy(i, "transformOptions", p.strategy);
        return m && (y.transformOptionsBlocks(a, m, [ "user", "subcomponentRecord" ]), n()), 
        l.target.mergePolicy || f(), p;
    }, y.defaults("fluid.function", {}), y.invokeGradedFunction = function(e, r) {
        var t = y.defaults(e);
        t && t.argumentMap && y.hasGrade(t, "fluid.function") || y.fail("Cannot look up name " + e + " to a function with registered argumentMap - got defaults ", t);
        var n = [];
        return y.each(t.argumentMap, function(e, t) {
            n[e] = r[t];
        }), y.invokeGlobalFunction(e, n);
    }, y.noNamespaceDistributionPrefix = "no-namespace-distribution-", y.mergeOneDistribution = function(e, t, r) {
        var n = t.namespace || r || y.noNamespaceDistributionPrefix + y.allocateGuid();
        e[t.namespace = n] = g.extend(!0, {}, e[n], t);
    }, y.distributeOptionsPolicy = function(r, e) {
        if (r = r || {}, y.isArrayable(e)) for (var t = 0; t < e.length; ++t) y.mergeOneDistribution(r, e[t]); else "string" == typeof e.target ? y.mergeOneDistribution(r, e) : y.each(e, function(e, t) {
            y.mergeOneDistribution(r, e, t);
        });
        return r;
    }, y.mergingArray = function() {}, y.mergingArray.prototype = [], y.deferringMergePolicy = function(r, e, n) {
        return r = r || {}, y.each(e, function(e, t) {
            r[t] || (r[t] = new y.mergingArray()), y.derefMergePolicy(n[t]).replace && (r[t].length = 0), 
            e instanceof y.mergingArray ? r[t].push.apply(r[t], e) : void 0 !== e && r[t].push(e);
        }), r;
    }, y.invokerStrategies = y.arrayToHash([ "func", "funcName", "listener", "this", "method", "changePath", "value" ]), 
    y.invokersMergePolicy = function(a, e) {
        return a = a || {}, y.each(e, function(e, t) {
            if (e) {
                e = y.upgradePrimitiveFunc(e);
                var r = a[t];
                for (var n in r = r || (a[t] = {}), y.invokerStrategies) if (n in e) for (var o in y.invokerStrategies) r[o] = void 0;
                g.extend(r, e);
            } else a[t] = e;
        }), a;
    }, y.rootMergePolicy = y.freezeRecursive({
        gradeNames: y.arrayConcatPolicy,
        distributeOptions: y.distributeOptionsPolicy,
        members: {
            noexpand: !0,
            func: y.deferringMergePolicy
        },
        invokers: {
            noexpand: !0,
            func: y.invokersMergePolicy
        },
        components: {
            noexpand: !0,
            func: y.deferringMergePolicy
        },
        dynamicComponents: {
            noexpand: !0,
            func: y.deferringMergePolicy
        },
        transformOptions: "replace",
        listeners: y.makeMergeListenersPolicy(y.mergeListenerPolicy)
    }), y.defaults("fluid.component", {
        mergePolicy: y.rootMergePolicy,
        argumentMap: {
            options: 0
        },
        workflows: {
            local: {
                concludeComponentObservation: {
                    funcName: "fluid.concludeComponentObservation",
                    priority: "first"
                },
                concludeComponentInit: {
                    funcName: "fluid.concludeComponentInit",
                    waitIO: !0,
                    priority: "last"
                }
            }
        },
        events: {
            onCreate: null,
            onDestroy: null,
            afterDestroy: null
        }
    }), y.computeNickName = function(e) {
        var t = y.model.parseEL(e);
        return y.peek(t);
    }, y.isDestroyed = function(e) {
        return "destroyed" === e.lifecycleStatus || "destroying" === e.lifecycleStatus;
    }, y.computeGlobalMemberName = function(e, t) {
        return y.computeNickName(e) + "-" + t;
    }, y.initFreeComponent = function(e, n) {
        var t = y.allocateGuid(), r = [ y.computeGlobalMemberName(e, t) ], o = {
            recordType: "user",
            type: e
        }, a = y.defaults(e), i = y.defaults(void 0 !== a.argumentMap.container ? "fluid.viewComponent" : "fluid.component").argumentMap;
        y.each(i, function(e, t) {
            var r = n[e];
            o[t] = "options" === t ? y.expandCompact(r, !0) : r;
        });
        var s = {
            type: "create",
            path: r,
            componentId: t,
            records: [ o ]
        }, c = y.registerPotentia(s), l = y.commitPotentiae(c.transactionId), u = !1;
        return c.promise.then(null, function(e) {
            if (!u) throw e;
        }), u = !0, l && l.that;
    };
    var n = "(?:[\\w\\u00c0-\\uFFFF*_-";
    y.simpleCSSMatcher = {
        regexp: new RegExp("([#.]?)(" + n + "]|\\\\.)+)", "g"),
        charToTag: {
            "": "tag",
            "#": "id",
            ".": "clazz"
        }
    }, y.IoCSSMatcher = {
        regexp: new RegExp("([&#]?)(" + n + "]|\\.|\\/)+)", "g"),
        charToTag: {
            "": "context",
            "&": "context",
            "#": "id"
        }
    };
    var f = new RegExp("\\s*(>)?\\s*", "g");
    y.parseSelector = function(e, t) {
        var r = [];
        e = e.trim();
        for (var n = t.regexp, o = n.lastIndex = 0; ;) {
            for (var a = [], i = !0; ;) {
                var s = n.exec(e);
                if (!s) break;
                if (s.index !== o) {
                    if (!i) break;
                    y.fail("Error in selector string - cannot match child selector expression starting at " + e.substring(o));
                }
                var c = {}, l = s[2], u = t.charToTag[s[1]];
                u && (c[u] = l), a[a.length] = c, o = n.lastIndex, i = !1;
            }
            f.lastIndex = o;
            var d = {
                predList: a
            }, p = f.exec(e);
            if (p && p.index === o || y.fail("Error in selector string - can not match child selector expression at " + e.substring(o)), 
            ">" === p[1] && (d.child = !0), r[r.length] = d, f.lastIndex >= e.length) break;
            o = f.lastIndex, n.lastIndex = f.lastIndex;
        }
        return r;
    }, y.flattenObjectPaths = function(e) {
        var n = {};
        return y.each(e, function(e, r) {
            if (null !== e && "object" == typeof e) {
                var t = y.flattenObjectPaths(e);
                y.each(t, function(e, t) {
                    n[r + "." + t] = e;
                }), "function" == typeof y.get(e, "toString") && (n[r] = e.toString());
            } else n[r] = e;
        }), n;
    }, y.stringTemplate = function(e, t) {
        var r = y.flattenObjectPaths(t), n = y.keys(r);
        n = n.sort(y.compareStringLength());
        for (var o = 0; o < n.length; ++o) for (var a = n[o], i = "%" + a, s = r[a], c = -1; -1 !== (c = e.indexOf(i)); ) e = e.slice(0, c) + s + e.slice(c + i.length);
        return e;
    };
}(jQuery, fluid_3_0_0), function(a) {
    "use strict";
    a.promise = function() {
        var o = {
            onResolve: [],
            onReject: [],
            onCancel: [],
            then: function(e, t, r) {
                return a.promise.pushHandler(o, e, "onResolve", "resolve"), a.promise.pushHandler(o, t, "onReject", "reject"), 
                a.promise.pushHandler(o, r, "onCancel", "cancel"), o;
            },
            resolve: function(e) {
                return o.disposition ? "cancel" !== o.disposition && a.fail("Error: resolving promise ", o, ' which has already received "' + o.disposition + '"') : o.complete("resolve", o.onResolve, e), 
                o;
            },
            reject: function(e) {
                return o.disposition ? "cancel" !== o.disposition && a.fail("Error: rejecting promise ", o, 'which has already received "' + o.disposition + '"') : o.complete("reject", o.onReject, e), 
                o;
            },
            cancel: function(e) {
                o.disposition || o.complete("cancel", o.onCancel, e);
            },
            complete: function(e, t, r) {
                o.disposition = e, o.value = r;
                for (var n = 0; n < t.length; ++n) t[n](r);
                delete o.onResolve, delete o.onReject, delete o.onCancel;
            }
        };
        return o;
    }, a.promise.pushHandler = function(e, t, r, n) {
        t && (e.disposition ? e.disposition === n && t(e.value) : e[r].push(t));
    }, a.isPromise = function(e) {
        return e && "function" == typeof e.then;
    }, a.toPromise = function(e) {
        if (a.isPromise(e)) return e;
        var t = a.promise();
        return t.resolve(e), t;
    }, a.promise.follow = function(e, t) {
        e.then(t.resolve, t.reject);
    }, a.promise.map = function(e, r) {
        var t = a.toPromise(e), n = a.promise();
        return t.then(function(e) {
            var t = r(e);
            a.isPromise(t) ? a.promise.follow(t, n) : n.resolve(t);
        }, function(e) {
            n.reject(e);
        }), n;
    }, a.promise.makeSequencer = function(e, t, r) {
        return a.isArrayable(e) || a.fail("fluid.promise sequence algorithms must be supplied an array as source"), 
        {
            sources: e,
            resolvedSources: [],
            index: 0,
            strategy: r,
            options: t,
            returns: [],
            sequenceStarted: !1,
            promise: a.promise()
        };
    }, a.promise.progressSequence = function(e, t) {
        e.returns.push(t), e.index++, a.promise.resumeSequence(e);
    }, a.promise.processSequenceReject = function(e, t) {
        for (var r = e.index - 1; 0 <= r; --r) {
            var n = e.resolvedSources[r];
            t = (a.isPromise(n) && "function" == typeof n.accumulateRejectionReason ? n.accumulateRejectionReason : a.identity)(t);
        }
        e.promise.reject(t);
    }, a.promise.resumeSequence = function(t) {
        if (t.sequenceStarted = !0, t.index === t.sources.length) t.promise.resolve(t.strategy.resolveResult(t)); else {
            var e = t.strategy.invokeNext(t);
            t.resolvedSources[t.index] = e, a.isPromise(e) ? e.then(function(e) {
                a.promise.progressSequence(t, e);
            }, function(e) {
                a.promise.processSequenceReject(t, e);
            }) : a.promise.progressSequence(t, e);
        }
    }, a.promise.makeSequenceStrategy = function() {
        return {
            invokeNext: function(e) {
                var t = e.sources[e.index];
                return "function" == typeof t ? t(e.options) : t;
            },
            resolveResult: function(e) {
                return e.returns;
            }
        };
    }, a.promise.sequence = function(e, t) {
        var r = a.promise.makeSequencer(e, t, a.promise.makeSequenceStrategy());
        return r.promise.sequencer = r, a.promise.resumeSequence(r), r.promise;
    }, a.promise.makeTransformerStrategy = function() {
        return {
            invokeNext: function(e) {
                var t = e.sources[e.index];
                return t.listener = a.event.resolveListener(t.listener), t.listener.apply(null, [ e.returns[e.index], e.options ]);
            },
            resolveResult: function(e) {
                return e.returns[e.index];
            }
        };
    }, a.promise.makeTransformer = function(e, t, r) {
        e.unshift({
            listener: function() {
                return t;
            }
        });
        var n = a.promise.makeSequencer(e, r, a.promise.makeTransformerStrategy());
        return n.returns.push(null), a.promise.resumeSequence(n), n;
    }, a.promise.filterNamespaces = function(e, t) {
        return t ? a.remove_if(a.makeArray(e), function(e) {
            return e.namespace && !e.softNamespace && !a.contains(t, e.namespace);
        }) : e;
    }, a.promise.fireTransformEvent = function(e, t, r) {
        var n = (r = r || {}).reverse ? a.makeArray(e.sortedListeners).reverse() : a.makeArray(e.sortedListeners);
        return n = a.promise.filterNamespaces(n, r.filterNamespaces), a.promise.makeTransformer(n, t, r).promise;
    };
}(fluid_3_0_0 = fluid_3_0_0 || {}), function(n, d) {
    "use strict";
    d.renderTimestamp = function(e) {
        function t(e, t) {
            t = t || 2;
            var r = void 0 === e ? "" : e.toString();
            return "00000".substring(5 - t + r.length) + r;
        }
        return t(e.getHours()) + ":" + t(e.getMinutes()) + ":" + t(e.getSeconds()) + "." + t(e.getMilliseconds(), 3);
    }, d.isTracing = !1, d.registerNamespace("fluid.tracing"), d.tracing.pathCount = [], 
    d.tracing.summarisePathCount = function(e) {
        e = e || d.tracing.pathCount;
        for (var t = {}, r = 0; r < e.length; ++r) {
            var n = e[r];
            t[n] ? ++t[n] : t[n] = 1;
        }
        var o = [];
        return d.each(t, function(e, t) {
            o.push({
                path: t,
                count: e
            });
        }), o.sort(function(e, t) {
            return t.count - e.count;
        }), o;
    }, d.tracing.condensePathCount = function(e, t) {
        e = d.makeArray(e);
        var n = {};
        d.each(e, function(e) {
            n[e] = 0;
        });
        var o = [];
        return d.each(t, function(t) {
            var r = t.path;
            d.find(e, function(e) {
                if (0 === r.indexOf(e)) return n[e] += t.count, !0;
            }) || o.push(t);
        }), d.each(n, function(e, t) {
            o.unshift({
                path: t,
                count: e
            });
        }), o;
    }, d.detectStackStyle = function(e) {
        var t = "other", r = {
            offset: 0
        };
        return e.arguments ? t = "chrome" : "undefined" != typeof window && window.opera && e.stacktrace ? t = "opera10" : e.stack ? (t = "firefox", 
        r.offset = -1 === e.stack.indexOf("Trace exception") ? 1 : 0) : "undefined" == typeof window || !window.opera || "stacktrace" in e || (t = "opera"), 
        r.style = t, r;
    }, d.obtainException = function() {
        try {
            throw new Error("Trace exception");
        } catch (e) {
            return e;
        }
    };
    var a = d.detectStackStyle(d.obtainException());
    d.registerNamespace("fluid.exceptionDecoders"), d.decodeStack = function() {
        if ("firefox" !== a.style) return null;
        var e = d.obtainException();
        return d.exceptionDecoders[a.style](e);
    }, d.exceptionDecoders.firefox = function(e) {
        var t = e.stack.replace(/(?:\n@:0)?\s+$/m, "").replace(/^\(/gm, "{anonymous}(").split("\n");
        return d.transform(t, function(e) {
            var t = (e = e.replace(/\)/g, "")).indexOf("at ");
            return -1 === t ? [ e ] : [ e.substring(t + "at ".length), e.substring(0, t) ];
        });
    }, d.getCallerInfo = function(e) {
        e = (e || 3) - a.offset;
        var t = d.decodeStack(), r = t && t[e][0];
        if (r) {
            var n = r.lastIndexOf("/");
            -1 === n && (n = 0);
            var o = r.indexOf(":", n);
            return {
                path: r.substring(0, n),
                filename: r.substring(n + 1, o),
                index: r.substring(o + 1)
            };
        }
        return null;
    }, d.generatePadding = function(e, t) {
        for (var r = "", n = 0; n < t; ++n) r += e;
        return r;
    }, d.SYNTHETIC_PROPERTY = Object.freeze({}), d.getSafeProperty = function(e, t) {
        var r = Object.getOwnPropertyDescriptor(e, t);
        return r && !r.get ? e[t] : d.SYNTHETIC_PROPERTY;
    }, d.prettyPrintJSON = function(e, t) {
        return (t = n.extend({
            indent: 4,
            stack: [],
            output: ""
        }, t)).indentChars = d.generatePadding(" ", t.indent), function e(t, r, n) {
            function o(e) {
                n.output += e;
            }
            var a = r + n.indentChars, i = "function" == typeof t;
            if (void 0 !== n.maxRenderChars && n.output.length > n.maxRenderChars) return !0;
            if (null === t) o("null"); else if (void 0 === t) o("undefined"); else if (t === d.SYNTHETIC_PROPERTY) o("[Synthetic property]"); else if (d.isPrimitive(t) && !i) o(JSON.stringify(t)); else {
                if (-1 !== n.stack.indexOf(t)) return void o("(CIRCULAR)");
                var s;
                if (n.stack.push(t), d.isArrayable(t)) if (0 === t.length) o("[]"); else {
                    for (o("[\n" + a), s = 0; s < t.length; ++s) {
                        if (e(t[s], a, n)) return !0;
                        s !== t.length - 1 && o(",\n" + a);
                    }
                    o("\n" + r + "]");
                } else {
                    o("{" + (i ? " Function" : "") + "\n" + a);
                    var c = d.keys(t);
                    for (s = 0; s < c.length; ++s) {
                        var l = c[s], u = d.getSafeProperty(t, l);
                        if (o(JSON.stringify(l) + ": "), e(u, a, n)) return !0;
                        s !== c.length - 1 && o(",\n" + a);
                    }
                    o("\n" + r + "}");
                }
                n.stack.pop();
            }
        }(e, "", t), t.output;
    }, d.dumpEl = function(e) {
        var t;
        if (!e) return "null";
        if (3 === e.nodeType || 8 === e.nodeType) return "[data: " + e.data + "]";
        if (9 === e.nodeType) return "[document: location " + e.location + "]";
        if (e.nodeType || !d.isArrayable(e)) return t = (e = n(e)).get(0).tagName, e.id && (t += "#" + e.id), 
        e.attr("class") && (t += "." + e.attr("class")), t;
        t = "[";
        for (var r = 0; r < e.length; ++r) t += d.dumpEl(e[r]), r < e.length - 1 && (t += ", ");
        return t + "]";
    }, d.debugger = function() {}, d.defaults("fluid.debuggingProbe", {
        gradeNames: [ "fluid.component" ]
    }), d.probeToDistribution = function(e) {
        var t = d.globalInstantiator, r = d.parseContextReference(e.target), n = d.model.parseToSegments(r.path, t.parseEL, !0);
        "options" !== n[0] && n.unshift("options");
        var o = d.parsePriority(e.priority);
        return o.constraint && !o.constraint.target && (o.constraint.target = "authoring"), 
        {
            target: "{/ " + r.context + "}." + t.composeSegments.apply(null, n),
            record: {
                func: e.func,
                funcName: e.funcName,
                args: e.args,
                priority: d.renderPriority(o)
            }
        };
    }, d.registerProbes = function(e) {
        var t = d.transform(e, d.probeToDistribution), r = "fluid_debuggingProbe_" + d.allocateGuid();
        return d.construct([ r ], {
            type: "fluid.debuggingProbe",
            distributeOptions: t
        }), r;
    }, d.deregisterProbes = function(e) {
        d.destroy([ e ]);
    };
}(jQuery, fluid_3_0_0 = fluid_3_0_0 || {}), function(d, g) {
    "use strict";
    g.visitComponentChildren = function(e, t, r, n) {
        n = n || [];
        var o = g.shadowForComponent(e);
        for (var a in o.childComponents) {
            var i = o.childComponents[a];
            if (!r.visited || !r.visited[i.id]) {
                if (n.push(a), r.visited && (r.visited[i.id] = !0), t(i, a, n, n.length - 1)) return !0;
                r.flat || g.visitComponentChildren(i, t, r, n), n.pop();
            }
        }
    }, g.getContextHash = function(e, t) {
        var r = e.idToShadow[t.id];
        return r && r.contextHash;
    }, g.componentHasGrade = function(e, t) {
        var r = g.getContextHash(g.globalInstantiator, e);
        return !(!r || !r[t]);
    }, g.visitComponentsForMatching = function(e, t, a) {
        var i = g.getInstantiator(e);
        t = d.extend({
            visited: {},
            instantiator: i
        }, t);
        var s = [ e ], c = [ g.getContextHash(i, e) ];
        g.visitComponentChildren(e, function(e, t, r) {
            s.length = 1, c.length = 1;
            for (var n = 0; n < r.length; ++n) {
                var o = s[n][r[n]];
                s[n + 1] = o, c[n + 1] = g.getContextHash(i, o) || {};
            }
            return a(e, s, c, r, r.length);
        }, t, []);
    }, g.getMemberNames = function(e, t) {
        if (0 === t.length) return [];
        var r = e.idToPath(g.peek(t).id), n = e.parseEL(r);
        return n.unshift.apply(n, g.generate(t.length - n.length, "")), n;
    }, g.visitComponentsForVisibility = function(e, t, r, n) {
        n = n || {
            visited: {},
            flat: !0,
            instantiator: e
        };
        for (var o = g.getMemberNames(e, t), a = t.length - 1; 0 <= a; --a) {
            var i = t[a];
            if (n.visited[i.id] = !0, r(i, o[a], o, a)) return;
            if (g.visitComponentChildren(i, r, n, o)) return;
            o.pop();
        }
    }, g.mountStrategy = function(a, e, i) {
        var s = a.length;
        return function(e, t, r, n) {
            if (!(r <= a.length)) {
                for (var o = 0; o < a.length; ++o) if (n[o] !== a[o]) return;
                return i(e, t, r - a.length, n.slice(s));
            }
        };
    }, g.invokerFromRecord = function(e, t, r) {
        g.pushActivity("makeInvoker", "beginning instantiation of invoker with name %name and record %record as child of %that", {
            name: t,
            record: e,
            that: r
        });
        var n = e ? g.makeInvoker(r, e, t) : void 0;
        return g.popActivity(), n;
    }, g.memberFromRecord = function(e, t, r) {
        for (var n, o = g.shadowForComponent(r), a = 0; a < e.length; ++a) {
            var i = g.expandImmediate(e[a], r, o.localRecord);
            n = g.isPlainObject(n) ? d.extend(!0, n, i) : i;
        }
        return n;
    }, g.resourceFromRecord = function(e, t, r) {
        var n = g.getForComponent(r, "resourceFetcher"), o = n.resourceSpecs[t], a = new g.fetchResources.FetchOne(o, n), i = a.resourceSpec.promise;
        i.disposition || g.currentTreeTransaction().pendingIO.push(i);
        return a;
    }, g.recordStrategy = function(a, i, s, c, l, r, n) {
        return r = r || [], {
            strategy: function(e, t, r) {
                if (1 === r) {
                    var n = g.driveStrategy(i, [ c, t ], s);
                    if (void 0 !== n) {
                        g.set(e, [ t ], g.inEvaluationMarker);
                        var o = l(n, t, a);
                        return g.set(e, [ t ], o), o;
                    }
                }
            },
            initter: function() {
                var e = g.driveStrategy(i, c, s) || {};
                for (var t in e) n && n[t] || g.getForComponent(a, r.concat([ t ]));
            }
        };
    }, g.makeDistributionRecord = function(e, t, r, n, o, a) {
        a = a || "distribution", g.pushActivity("makeDistributionRecord", "Making distribution record from source record %sourceRecord path %sourcePath to target path %targetSegs", {
            sourceRecord: t,
            sourcePath: r,
            targetSegs: n
        });
        var i = g.copy(g.get(t, r));
        g.each(o, function(e) {
            g.model.applyChangeRequest(i, {
                segs: e,
                type: "DELETE"
            });
        });
        var s = {
            options: {}
        };
        return g.model.applyChangeRequest(s, {
            segs: n,
            type: "ADD",
            value: i
        }), g.checkComponentRecord(s, g.componentRecordExpected), g.popActivity(), d.extend(s, {
            contextThat: e,
            recordType: a
        });
    }, g.filterBlocks = function(t, e, o, a, i, s) {
        var c = [];
        return g.each(e, function(r) {
            var e = g.get(r.source, o);
            if (void 0 !== e) {
                c.push(g.makeDistributionRecord(t, r.source, o, a, i, "distribution"));
                var n = d.extend({}, e);
                s && g.model.applyChangeRequest(r.source, {
                    segs: o,
                    type: "DELETE"
                }), g.each(i, function(e) {
                    var t = g.get(n, e);
                    g.set(r.source, o.concat(e), t);
                });
            }
        }), c;
    }, g.noteCollectedDistribution = function(e, t, r) {
        g.model.setSimple(e, [ "collectedDistributions", t, r.id ], !0);
    }, g.isCollectedDistribution = function(e, t, r) {
        return g.model.getSimple(e, [ "collectedDistributions", t, r.id ]);
    }, g.clearCollectedDistributions = function(e, t) {
        g.model.applyChangeRequest(e, {
            segs: [ "collectedDistributions", t ],
            type: "DELETE"
        });
    }, g.collectDistributions = function(e, t, r, n, o, a, i) {
        var s = g.peek(a);
        !g.isCollectedDistribution(t, s, r) && g.matchIoCSelector(r.selector, n, o, a, i) && (e.push.apply(e, g.copy(r.blocks)), 
        g.noteCollectedDistribution(t, s, r));
    }, g.registerCollectedClearer = function(e, t, r) {
        !e.collectedClearer && t && (e.collectedClearer = function() {
            g.clearCollectedDistributions(t, r);
        });
    }, g.receiveDistributions = function(e, t, r, n) {
        var o = g.getInstantiator(e || n), a = o.getThatStack(e || n);
        a.unshift(g.rootComponent);
        var i = g.getMemberNames(o, a), s = g.transform(a, function(e) {
            return o.idToShadow[e.id];
        }), c = s[s.length - (e ? 1 : 2)], l = g.getMembers(s, "contextHash");
        e ? (i.push(r), l.push(g.gradeNamesToHash(t)), a.push(n)) : g.registerCollectedClearer(g.peek(s), c, g.peek(i));
        for (var u = [], d = 0; d < a.length - 1; ++d) g.each(s[d].distributions, function(e) {
            g.collectDistributions(u, c, e, a, l, i, d);
        });
        return u;
    }, g.computeTreeDistance = function(e, t) {
        for (var r = 0; r < e.length && r < t.length && e[r] === t[r]; ) ++r;
        return e.length + t.length - 2 * r;
    }, g.computeDistributionPriority = function(e, t) {
        if (!t.priority) {
            var r = g.getInstantiator(e), n = r.getThatStack(e), o = g.getMemberNames(r, n), a = r.getThatStack(t.contextThat), i = g.getMemberNames(r, a), s = g.computeTreeDistance(o, i);
            t.priority = g.mergeRecordTypes.distribution - s;
        }
        return t;
    }, g.applyDistributions = function(t, e, r) {
        var n = g.transform(e, function(e) {
            return g.generateExpandBlock(e, t, r.mergePolicy);
        }, function(e) {
            return g.computeDistributionPriority(t, e);
        }), o = r.mergeOptions;
        return o.mergeBlocks.push.apply(o.mergeBlocks, n), o.updateBlocks(), n;
    }, g.matchIoCSelector = function(e, t, r, n, o) {
        for (var a = t.length - 1, i = e.length - 1; ;) {
            for (var s = e[i].child, c = a === t.length - 1 || s, l = t[a], u = e[i], d = !0, p = 0; p < u.predList.length; ++p) {
                var f = u.predList[p], m = f.context;
                if (m && "*" !== m && !r[a][m] && n[a] !== m) {
                    d = !1;
                    break;
                }
                if (f.id && l.id !== f.id) {
                    d = !1;
                    break;
                }
            }
            if (0 === i && o < a && c && s && (d = !1), d) {
                if (0 === i) return !0;
                --a, --i;
            } else {
                if (c) return !1;
                --a;
            }
            if (a < o) return !1;
        }
    }, g.queryIoCSelector = function(e, t, r) {
        var n = g.parseSelector(t, g.IoCSSMatcher), o = [];
        return g.visitComponentsForMatching(e, {
            flat: r
        }, function(e, t, r) {
            g.matchIoCSelector(n, t, r, [], 1) && o.push(e);
        }), o;
    }, g.isIoCSSSelector = function(e) {
        return -1 !== e.indexOf(" ");
    }, g.pushDistributions = function(e, t, r, n) {
        var o = g.shadowForComponent(e), a = g.allocateGuid(), i = {
            id: a,
            target: r,
            selector: t,
            blocks: n
        };
        return Object.freeze(i), Object.freeze(i.blocks), i.blocks.forEach(function(e) {
            g.freezeRecursive(e.options);
        }), g.pushArray(o, "distributions", i), a;
    }, g.clearDistribution = function(e, t) {
        var r = g.globalInstantiator.idToShadow[e];
        r && g.remove_if(r.distributions, function(e) {
            return e.id === t;
        });
    }, g.clearDistributions = function(e) {
        g.each(e.outDistributions, function(e) {
            g.clearDistribution(e.targetHeadId, e.distributionId);
        });
    }, g.extractSelectorHead = function(e) {
        var t = e[0].predList, r = t[0].context;
        return t.length = 0, r;
    }, g.parseExpectedOptionsPath = function(e, t) {
        var r = g.model.parseEL(e);
        return "options" !== r[0] && g.fail("Error in options distribution path ", e, " - only " + t + ' paths beginning with "options" are supported'), 
        r.slice(1);
    }, g.replicateProperty = function(t, r, e) {
        void 0 !== t[r] && g.each(e, function(e) {
            e[r] = t[r];
        });
    }, g.undistributableOptions = [ "gradeNames", "distributeOptions", "argumentMap", "mergePolicy" ], 
    g.distributeOptionsOne = function(e, t, r, n, o) {
        g.pushActivity("distributeOptions", "parsing distributeOptions block %record %that ", {
            that: e,
            record: t
        });
        var a = g.resolveContext(o, e);
        a || g.fail("Error in options distribution record ", t, " - could not resolve context {" + o + "} to a head component");
        var i, s = g.shadowForComponent(e), c = g.model.parseEL(r.path);
        if (void 0 !== t.record) i = [ g.makeDistributionRecord(e, t.record, [], c, []) ]; else {
            var l = g.parseContextReference(t.source);
            "that" !== l.context && g.fail("Error in options distribution record ", t, " only a source context of {that} is supported");
            var u = g.parseExpectedOptionsPath(l.path, "source"), d = g.makeArray(t.exclusions).concat(0 === u.length ? g.undistributableOptions : []), p = g.transform(d, function(e) {
                return g.model.parseEL(e);
            });
            i = g.filterBlocks(e, s.mergeOptions.mergeBlocks, u, c, p, t.removeSource), s.mergeOptions.updateBlocks();
        }
        if (g.replicateProperty(t, "priority", i), g.replicateProperty(t, "namespace", i), 
        n) {
            var f = g.pushDistributions(a, n, t.target, i);
            s.outDistributions = s.outDistributions || [], s.outDistributions.push({
                targetHeadId: a.id,
                distributionId: f
            });
        } else {
            var m = g.shadowForComponent(a);
            g.applyDistributions(e, i, m);
        }
        g.popActivity();
    }, g.distributeOptions = function(o, e) {
        var t = g.driveStrategy(o.options, "distributeOptions", e);
        g.each(t, function(e) {
            "string" != typeof e.target && g.fail("Error in options distribution record ", e, ' a member named "target" must be supplied holding an IoC reference'), 
            "string" == typeof e.source ^ void 0 === e.record && g.fail("Error in options distribution record ", e, ': must supply either a member "source" holding an IoC reference or a member "record" holding a literal record');
            var t, r, n = g.parseContextReference(e.target);
            "/" === (r = g.isIoCSSSelector(n.context) ? (t = g.parseSelector(n.context, g.IoCSSMatcher), 
            g.extractSelectorHead(t)) : n.context) || "that" === r ? g.distributeOptionsOne(o, e, n, t, r) : g.currentTreeTransaction().deferredDistributions.push({
                that: o,
                record: e,
                targetRef: n,
                selector: t,
                context: r
            });
        });
    }, g.gradeNamesToHash = function(e) {
        var t = {};
        return g.each(e, function(e) {
            t[e] = !0, t[g.computeNickName(e)] = !0;
        }), t;
    }, g.cacheShadowGrades = function(r, n) {
        var e = g.gradeNamesToHash(r.options && r.options.gradeNames || [ r.typeName ]);
        e[n.memberName] || (e[n.memberName] = "memberName"), n.contextHash = e, g.each(e, function(e, t) {
            n.ownScope[t] = r, n.parentShadow && "fluid.rootComponent" !== n.parentShadow.that.type && (n.parentShadow.childrenScope[t] = r);
        });
    }, g.deliverOptionsStrategy = function(e, t, r) {
        var n = g.shadowForComponent(e, n);
        g.cacheShadowGrades(e, n), n.mergeOptions = r;
    }, g.collectDistributedGrades = function(e) {
        var t = g.receiveDistributions(null, null, null, e.that);
        if (0 < t.length) {
            var r = g.applyDistributions(e.that, t, e.shadow), n = g.transform(g.getMembers(r, [ "source", "gradeNames" ]), g.makeArray);
            g.accumulateDynamicGrades(e, g.flatten(n));
        }
    }, g.flattenGradeName = function(e) {
        return "string" == typeof e ? e : JSON.stringify(e);
    }, g.applyDynamicGrades = function(t) {
        t.oldGradeNames = g.makeArray(t.gradeNames);
        var e = g.copy(g.getMergedDefaults(t.that.typeName, t.gradeNames));
        t.gradeNames.length = 0, t.gradeNames.push.apply(t.gradeNames, e.gradeNames), g.each(t.gradeNames, function(e) {
            g.isReferenceOrExpander(e) || (t.seenGrades[e] = !0);
        });
        var r = t.shadow;
        g.cacheShadowGrades(t.that, r), r.mergeOptions.destroyValue([ "mergePolicy" ]), 
        r.mergeOptions.destroyValue([ "components" ]), r.mergeOptions.destroyValue([ "invokers" ]), 
        t.defaultsBlock.source = e, r.mergeOptions.updateBlocks(), r.mergeOptions.computeMergePolicy(), 
        g.accumulateDynamicGrades(t, e.gradeNames);
    }, g.accumulateDynamicGrades = function(r, e) {
        g.each(e, function(e) {
            var t = g.flattenGradeName(e);
            r.seenGrades[t] || (g.isReferenceOrExpander(e) ? (r.rawDynamic.push(e), r.seenGrades[t] = !0) : g.contains(r.oldGradeNames, e) || r.plainDynamic.push(e));
        });
    }, g.computeDynamicGrades = function(e, t, r) {
        delete e.options.gradeNames;
        var n = g.driveStrategy(e.options, "gradeNames", r);
        n.length = 0;
        var o = {
            that: e,
            shadow: t,
            defaultsBlock: g.findMergeBlocks(t.mergeOptions.mergeBlocks, "defaults")[0],
            gradeNames: n,
            seenGrades: {},
            plainDynamic: [],
            rawDynamic: []
        };
        for (g.each(t.mergeOptions.mergeBlocks, function(e) {
            n.push.apply(n, g.makeArray(e.target && e.target.gradeNames)), g.applyDynamicGrades(o);
        }), g.collectDistributedGrades(o); ;) {
            for (;0 < o.plainDynamic.length; ) n.push.apply(n, o.plainDynamic), o.plainDynamic.length = 0, 
            g.applyDynamicGrades(o), g.collectDistributedGrades(o);
            if (!(0 < o.rawDynamic.length)) break;
            var a = g.expandImmediate(o.rawDynamic.shift(), e, t.localRecord);
            "function" == typeof a && (a = a()), a && (o.plainDynamic = o.plainDynamic.concat(a));
        }
        t.collectedClearer && (t.collectedClearer(), delete t.collectedClearer);
    }, g.computeComponentAccessor = function(e, t) {
        var r = g.globalInstantiator, n = g.shadowForComponent(e);
        n.localRecord = t;
        var o = e.options, a = n.mergeOptions.strategy, i = g.mountStrategy([ "options" ], o, a);
        n.invokerStrategy = g.recordStrategy(e, o, a, "invokers", g.invokerFromRecord), 
        n.eventStrategyBlock = g.recordStrategy(e, o, a, "events", g.eventFromRecord, [ "events" ]);
        var s = g.mountStrategy([ "events" ], e, n.eventStrategyBlock.strategy);
        if (n.memberStrategy = g.recordStrategy(e, o, a, "members", g.memberFromRecord, null, {
            model: !0,
            modelRelay: !0
        }), n.getConfig = {
            strategies: [ g.model.funcResolverStrategy, g.concreteStrategy, i, n.invokerStrategy.strategy, n.memberStrategy.strategy, s ]
        }, g.computeDynamicGrades(e, n, a, n.mergeOptions.mergeBlocks), n.contextHash["fluid.resourceLoader"]) {
            n.resourceStrategyBlock = g.recordStrategy(e, o, a, "resources", g.resourceFromRecord, [ "resources" ]);
            var c = g.mountStrategy([ "resources" ], e, n.resourceStrategyBlock.strategy);
            n.getConfig.strategies.push(c), e.resources = {};
        }
        if (g.distributeOptions(e, a), n.contextHash["fluid.resolveRoot"]) {
            var l;
            if (n.contextHash["fluid.resolveRootSingle"]) {
                var u = g.getForComponent(e, [ "options", "singleRootType" ]);
                u || g.fail("Cannot register object with grades " + Object.keys(n.contextHash).join(", ") + " as fluid.resolveRootSingle since it has not defined option singleRootType"), 
                l = g.typeNameToMemberName(u);
            } else l = g.computeGlobalMemberName(e.typeName, e.id);
            var d = g.resolveRootComponent;
            d[l] && r.clearComponent(d, l), r.recordKnownComponent(d, e, l, !1);
        }
        return n.getConfig;
    }, g.shadowForComponent = function(e) {
        var t = g.getInstantiator(e);
        return t && e ? t.idToShadow[e.id] : null;
    }, g.getForComponent = function(e, t) {
        var r = g.model.pathToSegments(t, o);
        if (0 === r.length) return e;
        var n = g.shadowForComponent(e), o = n ? n.getConfig : void 0, a = g.get(e, r[0], o);
        return g.isComponent(a) ? g.getForComponent(a, r.slice(1)) : g.get(e, t, o);
    }, g.concreteStrategy = function(e, t, r, n) {
        var o = e[t];
        return o === g.inEvaluationMarker && r === n.length && g.fail('Error in component configuration - a circular reference was found during evaluation of path segment "' + t + '": for more details, see the activity records following this message in the console, or issue fluid.setLogging(fluid.logLevel.TRACE) when running your application'), 
        1 < r ? o : void 0 === o && e.hasOwnProperty(t) ? g.NO_VALUE : o;
    }, g.frameworkGrades = [ "fluid.component", "fluid.modelComponent", "fluid.viewComponent", "fluid.rendererComponent" ], 
    g.filterBuiltinGrades = function(e) {
        return g.remove_if(g.makeArray(e), function(e) {
            return -1 !== g.frameworkGrades.indexOf(e);
        });
    }, g.dumpGradeNames = function(e) {
        return e.options && e.options.gradeNames ? " gradeNames: " + JSON.stringify(g.filterBuiltinGrades(e.options.gradeNames)) : "";
    }, g.dumpThat = function(e) {
        return '{ typeName: "' + e.typeName + '"' + g.dumpGradeNames(e) + " id: " + e.id + "}";
    }, g.dumpThatStack = function(e, r) {
        return g.transform(e, function(e) {
            var t = r.idToPath(e.id);
            return g.dumpThat(e) + (t ? " - path: " + t : "");
        }).join("\n");
    }, g.dumpComponentPath = function(e) {
        var t = g.pathForComponent(e);
        return t ? g.pathUtil.composeSegments.apply(null, t) : "** no path registered for component **";
    }, g.dumpComponentAndPath = function(e) {
        return "component " + g.dumpThat(e) + " at path " + g.dumpComponentPath(e);
    }, g.resolveContext = function(n, e, t) {
        if ("that" === n) return e;
        if ("/" === n) return g.rootComponent;
        if ("object" == typeof n) {
            var r = g.resolveContext(n.context, e, t);
            g.isComponent(r) || g.triggerMismatchedPathError(n.context, e);
            var o = g.getForComponent(r, n.path), a = g.expandOptions(o, e);
            return g.isComponent(a) || g.fail("Unable to resolve recursive context expression " + g.renderContextReference(n) + ": the directly resolved value of " + o + " did not resolve to a component in the scope of component ", e, ": got ", a), 
            a;
        }
        var i, s = g.globalInstantiator;
        if (t) return s.idToShadow[e.id].ownScope[n];
        var c = s.getFullStack(e);
        return g.visitComponentsForVisibility(s, c, function(e, t) {
            var r = g.shadowForComponent(e).contextHash[n];
            if (r && "memberName" !== r || n === t) return i = e, !0;
        }), i;
    }, g.triggerMismatchedPathError = function(e, t) {
        var r = g.renderContextReference(e);
        g.fail("Failed to resolve reference " + r + " - could not match context with name " + e.context + " from " + g.dumpComponentAndPath(t));
    }, g.makeStackFetcher = function(n, o, a) {
        return function(e) {
            n && "destroyed" === n.lifecycleStatus && g.fail("Cannot resolve reference " + g.renderContextReference(e) + " from component " + g.dumpThat(n) + " which has been destroyed");
            var t = e.context;
            if (o && t in o) return g.get(o[t], e.path);
            var r = g.resolveContext(t, n, a);
            return r || "" === e.path || g.triggerMismatchedPathError(e, n), g.getForComponent(r, e.path);
        };
    }, g.makeStackResolverOptions = function(e, t, r) {
        return d.extend(g.copy(g.rawDefaults("fluid.makeExpandOptions")), {
            localRecord: t || {},
            fetcher: g.makeStackFetcher(e, t, r),
            contextThat: e,
            exceptions: {
                members: {
                    model: !0,
                    modelRelay: !0
                }
            }
        });
    }, g.clearListeners = function(e) {
        g.each(e.listeners, function(e) {
            e.event.removeListener(e.listenerId || e.listener);
        }), delete e.listeners;
    }, g.recordListener = function(e, t, r, n) {
        e.ownerId !== r.that.id && g.pushArray(r, "listeners", {
            event: e,
            listener: t,
            listenerId: n
        });
    }, g.constructScopeObjects = function(e, t, r, n) {
        var o = t ? e.idToShadow[t.id] : null;
        n.childrenScope = o ? Object.create(o.ownScope) : {}, n.ownScope = Object.create(n.childrenScope), 
        n.parentShadow = o, n.childComponents = {}, g.cacheShadowGrades(r, n);
    }, g.clearChildrenScope = function(e, r, n, t) {
        g.each(t.contextHash, function(e, t) {
            r.childrenScope[t] === n && delete r.childrenScope[t];
        });
    }, g.doDestroy = function(e, t, r) {
        for (var n in "destroyed" === e.lifecycleStatus && g.fail("Cannot destroy " + g.dumpComponentAndPath(e) + " which has already been destroyed"), 
        g.fireEvent(e, "onDestroy", [ e, t || "", r ]), e.lifecycleStatus = "destroyed", 
        e.events) "afterDestroy" !== n && "function" == typeof e.events[n].destroy && e.events[n].destroy();
        e.applier && e.applier.destroy();
    }, g.instantiator = function() {
        var u = g.typeTag("instantiator");
        function i(e, t, r, n, o) {
            var a;
            if (o) (a = u.idToShadow[t.id] = {}).that = t, a.path = r, a.memberName = n, g.constructScopeObjects(u, e, t, a); else {
                (a = u.idToShadow[t.id]).injectedPaths = a.injectedPaths || {}, a.injectedPaths[r] = !0;
                var i = u.idToShadow[e.id], s = g.keys(a.contextHash);
                g.remove_if(s, function(e) {
                    return a.contextHash && "memberName" === a.contextHash[e];
                }), s.push(n), g.each(s, function(e) {
                    i.childrenScope[e] || (i.childrenScope[e] = t);
                });
            }
            u.pathToComponent[r] && g.fail("Error during instantiation - path " + r + " which has just created component " + g.dumpThat(t) + " has already been used for component " + g.dumpThat(u.pathToComponent[r]) + " - this is a circular instantiation or other oversight. Please clear the component using instantiator.clearComponent() before reusing the path."), 
            u.pathToComponent[r] = t;
        }
        return d.extend(u, {
            lifecycleStatus: "constructed",
            pathToComponent: {},
            idToShadow: {},
            modelTransactions: {},
            treeTransactions: {},
            currentTreeTransactionId: null,
            composePath: g.model.composePath,
            composeSegments: g.model.composeSegments,
            parseEL: g.model.parseEL,
            events: {
                onComponentAttach: g.makeEventFirer({
                    name: "instantiator's onComponentAttach event"
                }),
                onComponentClear: g.makeEventFirer({
                    name: "instantiator's onComponentClear event"
                })
            }
        }), u.parseToSegments = function(e) {
            return g.model.parseToSegments(e, u.parseEL, !0);
        }, u.idToPath = function(e) {
            var t = u.idToShadow[e];
            return t ? t.path : "";
        }, u.getThatStack = function(e) {
            var t = u.idToShadow[e.id];
            if (t) {
                for (var r = t.path, n = u.parseEL(r), o = u.pathToComponent[""], a = [], i = 0; i < n.length; ++i) o = o[n[i]], 
                a.push(o);
                return a;
            }
            return [];
        }, u.getFullStack = function(e) {
            var t = e ? u.getThatStack(e) : [];
            return t.unshift(g.resolveRootComponent), t;
        }, u.recordRoot = function(e) {
            i(null, e, "", "", !0);
        }, u.recordKnownComponent = function(e, t, r, n) {
            if (e[r] = t, g.isComponent(t) || "instantiator" === t.type) {
                var o = u.idToShadow[e.id];
                o.childComponents[r] = t;
                var a = u.composePath(o.path, r);
                i(e, t, a, r, n), u.events.onComponentAttach.fire(t, a, u, n);
            } else g.fail("Cannot record non-component with value ", t, ' at path "' + r + '" of parent ', e);
        }, u.clearConcreteComponent = function(o) {
            var e = o.childShadow;
            g.each(e.injectedPaths, function(e, t) {
                var r = g.model.getToTailPath(t), n = u.pathToComponent[r];
                u.clearComponent(n, g.model.getTailPath(t), o.child);
            }), g.clearDistributions(e), g.clearListeners(e), g.fireEvent(o.child, "afterDestroy", [ o.child, o.name, o.component ]), 
            delete u.idToShadow[o.child.id];
        }, u.clearComponent = function(e, t, a, i, r, n) {
            var o = u.idToShadow[e.id];
            i = i || {
                flat: !0,
                instantiator: u,
                destroyRecs: []
            }, a = a || e[t], void 0 === (n = n || o.path) && g.fail("Cannot clear component " + t + " from component ", e, " which was not created by this instantiator");
            var s = u.composePath(n, t), c = u.idToShadow[a.id];
            if (c) {
                var l = c.path === s;
                u.events.onComponentClear.fire(a, s, e, l), l ? (g.isDestroyed(a) && g.fail("Cannot destroy component which is already in status ", a.lifecycleStatus), 
                a.lifecycleStatus = "destroying", g.visitComponentChildren(a, function(e, t, r, n) {
                    var o = u.composeSegments.apply(null, r.slice(0, n));
                    u.clearComponent(a, t, null, i, !0, o);
                }, i, u.parseEL(s)), g.doDestroy(a, t, e), i.destroyRecs.push({
                    child: a,
                    childShadow: c,
                    name: t,
                    component: e,
                    shadow: o
                })) : g.remove_if(c.injectedPaths, function(e, t) {
                    return t === s;
                }), g.clearChildrenScope(u, o, a, c), delete u.pathToComponent[s], delete o.childComponents[t], 
                r || (delete e[t], g.each(i.destroyRecs, u.clearConcreteComponent));
            }
        }, u;
    }, g.globalInstantiator = g.instantiator(), g.getInstantiator = function(e) {
        var t = g.globalInstantiator;
        return e && t.idToShadow[e.id] ? t : null;
    }, g.defaults("fluid.resolveRoot"), g.defaults("fluid.resolveRootSingle", {
        gradeNames: "fluid.resolveRoot"
    }), g.constructRootComponents = function(e) {
        g.rootComponent = e.rootComponent = g.typeTag("fluid.rootComponent"), e.recordRoot(g.rootComponent), 
        g.resolveRootComponent = e.resolveRootComponent = g.typeTag("fluid.resolveRootComponent"), 
        e.recordKnownComponent(g.rootComponent, g.resolveRootComponent, "resolveRootComponent", !0);
        var t = e.idToShadow[g.rootComponent.id];
        t.contextHash = {};
        var r = e.idToShadow[g.resolveRootComponent.id];
        r.ownScope = t.ownScope, r.childrenScope = t.childrenScope, e.recordKnownComponent(g.resolveRootComponent, e, "instantiator", !0), 
        r.childrenScope.instantiator = e;
    }, g.constructRootComponents(g.globalInstantiator), g.expandOptions = function(e, t, r, n, o) {
        if (!e) return e;
        g.pushActivity("expandOptions", "expanding options %args for component %that ", {
            that: t,
            args: e
        });
        var a = g.makeStackResolverOptions(t, n);
        a.mergePolicy = r, a.defer = o && o.defer;
        var i = a.defer ? g.makeExpandOptions(e, a) : g.expand(e, a);
        return g.popActivity(), i;
    }, g.computeMergeListPriority = function(e) {
        e.forEach(function(e) {
            var t = e.recordType;
            "distribution" !== t && (e.priority = g.mergeRecordTypes[t] + (e.priorityDelta || 0), 
            g.isInteger(e.priority) || g.fail("Merge record with unrecognised type " + t + ": ", e));
        });
    };
    g.generateExpandBlock = function(e, t, r, n) {
        var o = g.expandOptions(e.options || {}, e.contextThat || t, r, n, {
            defer: !0
        });
        return o.priority = e.priority, o.namespace = e.namespace, o.recordType = e.recordType, 
        o;
    }, g.fabricateDestroyMethod = function(t) {
        return function() {
            var e = g.shadowForComponent(t);
            g.destroy(e.path);
        };
    }, g.typeNameToMemberName = function(e) {
        return e.replace(/\./g, "_");
    }, g.expandComponentOptions = function(t, r, e, n) {
        var o, a = e.toMerge, i = g.lightMergeValue(a, "container");
        i && a.push({
            recordType: "distribution",
            priority: g.mergeRecordTypes.distribution,
            options: {
                container: i
            },
            contextThat: r.parentThat
        }), n.destroy = g.fabricateDestroyMethod(n), o = t, g.each([ "gradeNames", "mergePolicy", "argumentMap", "components", "dynamicComponents", "events", "listeners", "modelListeners", "modelRelay", "distributeOptions", "transformOptions" ], function(e) {
            g.set(o, [ e, "*", "noexpand" ], !0);
        }), g.shadowForComponent(n).mergePolicy = t, g.computeMergeListPriority(a);
        var s = g.transform(a, function(e) {
            return g.generateExpandBlock(e, n, t, r.localRecord);
        });
        return g.popActivity(), s;
    }, g.computeDynamicComponentKey = function(e, t) {
        return e + (0 === t ? "" : "-" + t);
    }, g.concludeAnyTransaction = function() {
        var t, e = g.globalInstantiator, r = e.currentTreeTransactionId;
        if (r && (e.treeTransactions[r].promise.then(null, function(e) {
            t = e;
        }), g.commitPotentiae(r), t)) throw t;
    }, g.bindDeferredComponent = function(n, o, a, i) {
        var s = a.createOnEvent, e = g.isIoCReference(s) ? g.expandOptions(s, n) : n.events[s];
        e && e.addListener || g.fail("Error instantiating createOnEvent component with name " + o + " of parent ", n, " since event specification " + s + " could not be expanded to an event - got ", e);
        var c = g.shadowForComponent(n);
        i && g.set(c, [ "dynamicComponentCount", o ], 0);
        function t() {
            var e = i ? g.computeDynamicComponentKey(o, c.dynamicComponentCount[o]++) : o, t = {
                arguments: g.makeArray(arguments)
            };
            g.pushActivity("initDeferred", "instantiating deferred component %componentName of parent %that due to event %eventName", {
                componentName: o,
                that: n,
                eventName: s
            });
            var r = g.copy(a);
            delete r.createOnEvent, g.registerConcreteSubPotentia(r, e, 0, n, t), g.popActivity();
        }
        e.addListener(t), g.recordListener(e, t, c), e.addListener(g.concludeAnyTransaction, "fluid-componentConstruction", "last:transaction"), 
        g.recordListener(e, g.concludeAnyTransaction, c);
    }, g.markSubtree = function(o, e, a, i) {
        e.lifecycleStatus = i, g.visitComponentChildren(e, function(e, t) {
            var r = o.composePath(a, t), n = o.idToShadow[e.id];
            n && n.path === r && g.markSubtree(o, e, r, i);
        }, {
            flat: !0
        });
    }, g.assessTreeConstruction = function(e, t) {
        var r = g.globalInstantiator, n = r.getThatStack(e);
        g.find_if(n, function(e) {
            return "constructing" === e.lifecycleStatus;
        }) ? e.lifecycleStatus = "constructed" : g.markSubtree(r, e, t.path, "treeConstructed");
    }, g.concludeComponentObservation = function(e) {
        var r = e.that, t = e.mergeOptions;
        g.pushActivity("concludeComponentObservation", "constructing component of type %componentName at path %path", {
            componentName: r.typeName,
            path: e.path
        });
        for (var n = 0; n < t.mergeBlocks.length; ++n) t.mergeBlocks[n].initter();
        t.initter(), delete r.options.mergePolicy, e.memberStrategy.initter(), e.invokerStrategy.initter(), 
        g.each(e.lightMergeComponents, function(e, t) {
            e.createOnEvent && g.bindDeferredComponent(r, t, e);
        }), g.each(e.lightMergeDynamicComponents, function(e, t) {
            e.createOnEvent && g.bindDeferredComponent(r, t, e, !0);
        }), g.popActivity();
    }, g.concludeComponentInit = function(e) {
        var t = e.that;
        if (!g.isDestroyed(t)) return t.lifecycleStatus = "constructed", g.assessTreeConstruction(t, e), 
        t.events.onCreate.fire(t), g.popActivity(), t;
    }, g.pushCreatePotentia = function(e, t, r) {
        var n = e.pathToPotentia[t];
        if (!n || n.applied) return (e.pathToPotentia[t] = r).records && (r.lightMerge = g.lightMergeRecords(r.records), 
        delete r.records), r;
        g.lightMergeRecords.pushRecords(n, r.records || r.lightMerge.toMerge);
    }, g.blankPotentiaList = function() {
        return {
            destroys: [],
            creates: [],
            activeCount: 0,
            pathToPotentia: {}
        };
    }, g.isInjectedComponentRecord = function(e) {
        return "string" == typeof e || e.expander;
    }, g.lightMergeValue = function(e, r) {
        var n;
        return e.forEach(function(e) {
            var t = e[r];
            n = void 0 === t ? n : t;
        }), n;
    }, g.lightMergeRecords = function(e) {
        var t = {
            toMerge: [],
            isInjected: !1
        };
        return g.lightMergeRecords.pushRecords(t, e), t;
    }, g.lightMergeRecords.pushRecord = function(e, t) {
        g.isInjectedComponentRecord(t) ? (e.toMerge = [ {
            injected: t
        } ], e.isInjected = !0) : (e.type = t.type || e.type, e.createOnEvent = t.createOnEvent || e.createOnEvent, 
        e.source = t.source || e.source, e.sources = t.sources || e.sources, e.isInjected ? e.toMerge = [ t ] : e.toMerge.push(t), 
        e.isInjected = !1);
    }, g.lightMergeRecords.pushRecords = function(t, e) {
        e.forEach(function(e) {
            g.lightMergeRecords.pushRecord(t, e);
        });
    }, g.instantiateEvents = function(e) {
        var t = e.that;
        e.eventStrategyBlock.initter();
        var r = g.getForComponent(t, [ "options", "listeners" ]);
        g.mergeListeners(t, t.events, r);
        var n = g.validateListenersImplemented(t);
        0 < n.length && g.fail(g.transform(n, function(e) {
            return [ "Error constructing component ", t, " - the listener for event " + e.name + " with namespace " + e.namespace + (e.componentSource ? " which was defined in grade " + e.componentSource : "") + " needs to be overridden with a concrete implementation" ];
        })).join("\n");
    }, g.initComponentShell = function(e, t) {
        var r = g.globalInstantiator, n = g.defaults(t.type), o = e.parentThat, a = e.memberName, i = g.receiveDistributions(o, n && n.gradeNames, a, {});
        g.each(i, function(e) {
            g.computeDistributionPriority(o, e), g.isPrimitive(e.priority) && (e.priority = g.parsePriority(e.priority, 0, !1, "options distribution"));
        }), g.sortByPriority(i), g.lightMergeRecords.pushRecords(t, i), n = g.defaults(t.type);
        var s = g.copy(n);
        t.toMerge.unshift({
            options: s,
            recordType: "defaults"
        });
        var c = "fluid.emptySubcomponent" === t.type ? null : g.typeTag(t.type, e.componentId);
        c && (c.lifecycleStatus = "constructing", r.recordKnownComponent(o, c, a, !0), g.mergeComponentOptions(c, e, t).exceptions = {
            members: {
                model: !0,
                modelRelay: !0
            }
        }, c.events = {});
        return c;
    }, g.registerConcreteSubPotentia = function(e, t, r, n, o, a) {
        r = r || 0;
        var i = g.pathForComponent(n).concat([ t ]);
        n[t] && g.registerPotentia({
            segs: i,
            type: "destroy"
        }, a), e.toMerge = g.transform(e.toMerge, function(e) {
            return d.extend({
                componentDepth: r + 1,
                sourceComponentId: n.id,
                recordType: "subcomponentRecord"
            }, e);
        }), e.type = g.expandImmediate(e.type, n, o);
        var s = {
            type: "create",
            segs: i,
            lightMerge: e,
            localRecord: o
        };
        g.registerPotentia(s, a);
    }, g.lightMergeComponentRecord = function(e, t, r, n) {
        var o = g.lightMergeRecords(n);
        return g.set(e, [ t, r ], o), o;
    }, g.componentRecordExpected = g.arrayToHash([ "type", "options", "container", "createOnEvent" ]), 
    g.dynamicComponentRecordExpected = d.extend({}, g.componentRecordExpected, g.arrayToHash([ "source", "sources" ])), 
    g.checkComponentRecord = function(r, n) {
        g.isInjectedComponentRecord(r) || g.each(r, function(e, t) {
            n[t] || g.fail("Probable error in subcomponent record ", r, ' - key "' + t + '" found, where the only legal options are ' + g.keys(n).join(", "));
        });
    }, g.checkSubcomponentRecords = function(e, t) {
        e.forEach(function(e) {
            g.checkComponentRecord(e, t);
        });
    }, g.registerSourcedDynamicComponent = function(e, t, r, n, o, a, i) {
        var s = d.extend({}, e.localRecord, {
            source: r,
            sourcePath: n
        });
        (i || g.identity)(s, r, n);
        var c = g.computeDynamicComponentKey(a, n), l = g.copy(o);
        g.registerConcreteSubPotentia(l, c, e.componentDepth, t, s);
    }, g.registerSourcedDynamicComponents = function(r, n, e, o, a, i) {
        g.each(e, function(e, t) {
            g.registerSourcedDynamicComponent(r, n, e, t, o, a, i);
        });
    }, g.lensedComponentModelListener = function(e, t, r, n, o) {
        function a(e) {
            return o ? !e : void 0 === e;
        }
        var i = g.shadowForComponent(e), s = o ? 0 : g.peek(r), c = e[g.computeDynamicComponentKey(t, s)];
        if (a(n) || c) a(n) && c && c.destroy(); else {
            var l = i.lightMergeDynamicComponents[t], u = i.modelSourcedDynamicComponents[t];
            g.registerSourcedDynamicComponent(i.potentia, e, n, s, l, t, u.localRecordContributor);
        }
    }, g.lensedComponentDefToBlock = function(e, t, r) {
        var n = t.segs.slice(1), o = {
            path: {
                context: t.context,
                segs: n.concat(r ? [] : [ "*" ])
            },
            excludeSource: "init",
            funcName: "fluid.lensedComponentModelListener",
            args: [ "{that}", e, "{change}.path", "{change}.value", r ]
        }, a = {};
        return a["lensedComponents-" + e] = o, {
            modelListeners: a
        };
    }, g.addLensedComponentBlocks = function(e, t, r) {
        var n = g.extend.apply(null, [ !0, {} ].concat(e));
        r.mergeOptions.mergeBlocks.push(g.generateExpandBlock({
            options: n,
            recordType: "lensedComponents",
            priority: g.mergeRecordTypes.lensedComponents
        }, r.that, r.mergePolicy, t.localRecord)), r.mergeOptions.updateBlocks();
    }, g.expectExactlyOne = function(e, t, r) {
        var n = 0;
        r.forEach(function(e) {
            void 0 !== t[e] && ++n;
        }), 1 !== n && g.fail.apply(null, e.concat([ " must contain exactly one member out of " + r.join(", ") ]));
    }, g.registerSourcedDynamicComponentsTriage = function(e, t, r, n, o, a, i) {
        a ? g.registerSourcedDynamicComponent(e, t, r, 0, n, o, i) : g.registerSourcedDynamicComponents(e, t, r, n, o, i);
    }, g.processComponentShell = function(s, c, e) {
        var l = g.globalInstantiator.idToShadow[c.id];
        l.potentia = s;
        var t = l.mergeOptions, r = g.driveStrategy(c.options, "components", t.strategy);
        g.each(r, function(e, t) {
            g.checkSubcomponentRecords(e, g.componentRecordExpected);
            var r = g.lightMergeComponentRecord(l, "lightMergeComponents", t, e);
            r.createOnEvent || g.registerConcreteSubPotentia(r, t, s.componentDepth, c, s.localRecord);
        });
        var n = g.driveStrategy(c.options, "dynamicComponents", t.strategy), u = [];
        g.each(n, function(e, t) {
            g.checkSubcomponentRecords(e, g.dynamicComponentRecordExpected);
            var r = g.lightMergeComponentRecord(l, "lightMergeDynamicComponents", t, e);
            if (g.expectExactlyOne([ "dynamicComponents records ", e ], r, [ "source", "sources", "createOnEvent" ]), 
            void 0 !== r.sources || void 0 !== r.source) {
                var n, o = r.sources, a = !1;
                if (void 0 !== r.source && (o = r.source, a = !0), g.isIoCReference(o)) {
                    var i = g.parseValidModelReference(c, "dynamicComponents source", o, !0);
                    i.nonModel ? (n = g.getForComponent(i.that, i.segs), g.registerSourcedDynamicComponentsTriage(s, c, n, r, t, null, a)) : (g.set(l, [ "modelSourcedDynamicComponents", t ], {
                        sourcesParsed: i,
                        isBoolean: a
                    }), u.push(g.lensedComponentDefToBlock(t, i, a)));
                } else n = g.expandImmediate(o, c, s.localRecord), g.registerSourcedDynamicComponentsTriage(s, c, n, r, t, null, a);
            }
        }), u.length && g.addLensedComponentBlocks(u, s, l), e.deferredDistributions.length && (e.pendingPotentiae.creates.push({
            type: "distributeOptions",
            distributions: e.deferredDistributions
        }), ++e.pendingPotentiae.activeCount, e.deferredDistributions = []);
    }, g.preparePathedPotentia = function(e, t) {
        var r = e.segs || t.parseToSegments(e.path);
        e.segs = r, e.memberName = g.peek(r), e.parentThat = g.getImmediate(g.rootComponent, r.slice(0, -1));
    }, g.fetchInjectedComponentReference = function(e, t, r, n) {
        var o = g.globalInstantiator;
        if (r.expander) return g.expandImmediate(r, n);
        var a = g.parseContextReference(r), i = g.resolveContext(a.context, n);
        if (i) {
            var s = o.idToShadow[i.id].path, c = g.composePath(s, a.path), l = o.pathToComponent[c];
            if (l) return l;
            var u = t.pathToPotentia[c];
            if (u) {
                if (!u.applied) return g.operateOneCreatePotentia(e, u);
                g.fail("Circular reference found when resolving injected component reference ", r, " - the target of the reference is still in construction");
            }
        } else {
            if ("" === a.path) return i;
            g.fail("Error in injected component reference ", r, " - could not resolve context {" + a.context + "} to a head component");
        }
    }, g.operateCreatePotentia = function(e, t, r) {
        var n = g.globalInstantiator;
        g.preparePathedPotentia(r, n);
        var o, a = r.memberName, i = r.parentThat;
        g.pushActivity("operateCreatePotentia", 'operating create potentia for path "%path" with records %records', {
            path: r.path,
            records: r.records
        });
        var s = r.lightMerge;
        if (s.isInjected) {
            i[a] = g.inEvaluationMarker;
            var c = g.fetchInjectedComponentReference(e, t, s.toMerge[0].injected, i);
            c ? n.recordKnownComponent(i, c, a, !1) : delete i[a];
        } else s.type ? (o = g.initComponentShell(r, s)) && g.processComponentShell(r, o, e) : g.fail("Unrecognised material in place of subcomponent " + a + " - could not recognise the records ", r.records, " as designating either an injected or concrete component");
        if (g.pushPotentia(e.restoreRecords, n, {
            type: "destroy",
            segs: r.segs
        }), g.popActivity(), o) return n.idToShadow[o.id];
    }, g.operateDestroyPotentia = function(e, t, r) {
        r = r || g.globalInstantiator, g.preparePathedPotentia(t, r);
        var n = g.getImmediate(g.rootComponent, t.segs);
        n && r.clearComponent(t.parentThat, t.memberName, n);
    }, g.lookupWorkflowStage = function(t) {
        if (!t) return g.workflowCacheSorted.length;
        if ("shells" === t) return 0;
        var e = g.find_if(g.workflowCacheSorted, function(e) {
            return e.workflowName === t;
        });
        if (e) return e.index + 1;
        g.fail("Unknown workflow name " + t + ' supplied as "breakAt" for tree transaction: : valid names are ' + g.getMembers(g.workflowCacheSorted, "workflowName").join(", "));
    }, g.evaluateWorkflows = function(e, t) {
        var r = [];
        return g.workflowCacheSorted[t].forEach(function(t) {
            0 < e.filter(function(e) {
                return g.componentHasGrade(e.that, t.gradeName);
            }).length && r.push({
                shadows: e,
                workflowIndex: t.index,
                workflowOptions: t.workflowOptions
            });
        }), r;
    }, g.findWorkflowShadows = function(e, t, r, n) {
        for (var o = [], a = t; a < r; ++a) g.componentHasGrade(e[a].that, n.gradeName) && ("global" === n.workflowType ? o.push(e[a]) : o.unshift(e[a]));
        return o;
    }, g.waitPendingIOTask = function(e) {
        function t() {
            o.currentTreeTransactionId = e.transactionId;
        }
        function r() {
            return e.pendingIO.length ? n = g.promise.sequence(e.pendingIO.concat([ t ])) : null;
        }
        var n, o = g.globalInstantiator;
        return r.taskName = "waitIO", r.sequence = n, r;
    }, g.enqueueWorkflowBlock = function(l, u, e, t, d, p, f) {
        var m = !1;
        return l.lastWorkflowShadow = Math.max(l.lastWorkflowShadow, p), g.forEachInRange(g.workflowCacheSorted, e, t, function(e, t) {
            if (0 === t) for (var r = d; r < p; ++r) g.instantiateEvents(u[r]);
            var n = g.findWorkflowShadows(u, d, p, e);
            if (l.maximumWorkflowStage = Math.max(l.maximumWorkflowStage, t + 1), 0 < n.length) {
                var o = e.workflowOptions, a = g.getGlobalValue(o.funcName), i = f.sources;
                if (o.waitIO && i.push(g.waitPendingIOTask(l)), "global" === e.workflowType) {
                    var s = function() {
                        a(n, l);
                    };
                    s.taskName = e.namespace, i.push(s);
                } else {
                    var c = function() {
                        "concludeComponentInit" === e.namespace && (f.hasStartedConcludeInit = !0), n.forEach(function(e) {
                            a(e, l);
                        });
                    };
                    c.taskName = e.namespace, i.push(c);
                }
                m = !0;
            }
        }), m;
    }, g.applyWorkflowPhase = function(e, t) {
        var r = e.outputShadows;
        if (r.length > e.lastWorkflowShadow && 0 < e.maximumWorkflowStage) return g.enqueueWorkflowBlock(e, r, 0, e.maximumWorkflowStage, e.lastWorkflowShadow, r.length, t), 
        !0;
        if (e.maximumWorkflowStage < e.workflowStageBreak) for (var n = e.maximumWorkflowStage; n < e.workflowStageBreak; ++n) {
            var o = g.enqueueWorkflowBlock(e, r, n, n + 1, 0, r.length, t);
            if (o) return o;
        }
    }, g.operateOneCreatePotentia = function(e, t) {
        t.applied = !0, --e.pendingPotentiae.activeCount;
        var r = g.operateCreatePotentia(e, e.pendingPotentiae, t);
        return r && e.outputShadows.push(r), r && r.that;
    }, g.commitPotentiaePhase = function(t) {
        var r = t.pendingPotentiae;
        r.destroys.forEach(function(e) {
            e.applied || (e.applied = !0, --r.activeCount, g.operateDestroyPotentia(t, e));
        });
        for (var e = 0; e < r.creates.length; ++e) {
            var n = r.creates[e];
            n.applied || ("create" === n.type ? g.operateOneCreatePotentia(t, n) : "distributeOptions" === n.type ? (n.distributions.forEach(function(e) {
                g.distributeOptionsOne(e.that, e.record, e.targetRef, e.selector, e.context);
            }), n.applied = !0, --r.activeCount) : g.fail("Unrecognised potentia type " + n.type));
        }
    }, g.isPopulatedPotentiaList = function(e) {
        return 0 < e.activeCount;
    }, g.commitPotentiae = function(e) {
        var t = g.globalInstantiator, r = t.treeTransactions[e];
        ++r.commitDepth;
        var n, o = r.lastWorkflowShadow, a = r.rootSequencer, i = g.getImmediate(g.peek(a.sources), [ "sequencer" ]);
        return !i || i.hasStartedConcludeInit || i.promise.disposition ? ((n = g.promise.makeSequencer([], {}, g.promise.makeSequenceStrategy())).promise.sequencer = n, 
        a.sources.push(n.promise)) : n = i, g.tryCatch(function() {
            g.isPopulatedPotentiaList(r.pendingPotentiae) && g.commitPotentiaePhase(r), g.applyWorkflowPhase(r, n) && n.sources.push(function() {
                g.commitPotentiae(e);
            }), n.sequenceStarted || g.promise.resumeSequence(n), a.sequenceStarted || g.promise.resumeSequence(a);
        }, function(e) {
            r.promise.disposition || r.promise.reject(e);
        }), --r.commitDepth, 0 === r.commitDepth && (t.currentTreeTransactionId = null), 
        r.outputShadows[o];
    }, g.pushPotentia = function(e, t, r) {
        var n = r.segs = r.segs || t.parseToSegments(r.path), o = r.path = t.composeSegments.apply(null, n);
        if ("destroy" === r.type) e.destroys.push(r), e.activeCount++; else {
            var a = r;
            "create" === r.type && (a = g.pushCreatePotentia(e, o, r)), a && (e.creates.push(r), 
            e.activeCount++);
        }
    }, g.pathForComponent = function(e, t) {
        var r = (t = t || g.getInstantiator(e) || g.globalInstantiator).idToShadow[e.id];
        return r ? t.parseEL(r.path) : null;
    }, g.currentTreeTransaction = function() {
        var e = g.globalInstantiator;
        return e.treeTransactions[e.currentTreeTransactionId];
    }, g.clearTreeTransaction = function(e) {
        e.rootSequencer = g.promise.makeSequencer([], {}, g.promise.makeSequenceStrategy()), 
        e.restoreRecords = g.blankPotentiaList(), e.initModelTransaction = {}, e.outputShadows = [], 
        e.lastWorkflowShadow = 0, e.maximumWorkflowStage = 0, e.deferredDistributions = [];
    }, g.beginTreeTransaction = function(e) {
        var t = g.globalInstantiator;
        t.currentTreeTransactionId && g.fail("Attempt to start new tree transaction when transaction " + t.currentTreeTransactionId + " is already active");
        var r = t.currentTreeTransactionId = g.allocateGuid(), n = d.extend({
            transactionId: r,
            workflowStageBreak: void 0,
            pendingPotentiae: g.blankPotentiaList(),
            commitDepth: 0,
            cancelled: !1,
            cancellationError: null,
            pendingIO: []
        }, e);
        g.clearTreeTransaction(n), n.promise = n.rootSequencer.promise;
        function o() {
            n.rootSequencer.promise.disposition && (t.currentTreeTransactionId = null, delete t.treeTransactions[r]);
        }
        n.promise.then(o, function(e) {
            n.cancelled || (delete n.rootSequencer, g.cancelTreeTransaction(r, t, e), o());
        }), t.treeTransactions[r] = n;
        try {
            n.workflowStageBreak = g.lookupWorkflowStage(n.breakAt);
        } catch (e) {
            n.promise.reject(e);
        }
        return n;
    }, g.registerPotentia = function(e, t) {
        var r = g.globalInstantiator;
        t = (t = t || r.currentTreeTransactionId) || g.beginTreeTransaction().transactionId;
        var n = r.treeTransactions[t];
        return g.pushPotentia(n.pendingPotentiae, r, e), n;
    }, g.cancelTreeTransaction = function(t, r) {
        var n = r.treeTransactions[t];
        if (n) try {
            n.pendingPotentiae = n.restoreRecords, n.cancelled = !0, g.clearTreeTransaction(n), 
            g.commitPotentiae(t, !0);
        } catch (e) {
            throw g.log(g.logLevel.FAIL, "Fatal error cancelling transaction " + t + ": destroying all affected paths"), 
            n.restoreRecords.creates.forEach(function(e) {
                r.clearComponent(e.parentThat, e.memberName, e.parentThat[e.memberName]);
            }), e;
        }
    }, g.constructChild = function(e, t, r) {
        var n = g.pathForComponent(e).concat([ t ]);
        return g.construct(n, r);
    }, g.construct = function(e, r, t) {
        t = t || {};
        var n = g.registerPotentia({
            path: e,
            type: "destroy"
        }, t.transactionId), o = {
            recordType: "user"
        };
        g.each(g.componentRecordExpected, function(e, t) {
            void 0 !== r[t] && (o[t] = r[t]);
        }), o.options = r;
        var a = {
            path: e,
            type: "create",
            localRecord: t.localRecord,
            records: [ o ]
        };
        return g.registerPotentia(a, n.transactionId), t.transactionId || g.commitPotentiae(n.transactionId), 
        t.returnTransaction ? n : g.getImmediate(g.rootComponent, a.segs);
    }, g.destroy = function(e, t) {
        0 === (t = t || g.globalInstantiator).parseToSegments(e).length && g.fail("Cannot destroy the root component");
        var r = g.registerPotentia({
            path: e,
            type: "destroy"
        });
        return g.commitPotentiae(r.transactionId), r;
    }, g.constructSingle = function(e, t, r) {
        r = r || g.globalInstantiator, e = e || "";
        var n = g.model.parseToSegments(e, r.parseEL, !0);
        "string" == typeof t && (t = {
            type: t
        });
        var o = t.type;
        o || g.fail("Cannot construct singleton object without a type entry");
        var a = (t = d.extend({}, t)).gradeNames = g.makeArray(t.gradeNames);
        a.unshift(o), t.type = "fluid.component", 0 === n.length && a.push("fluid.resolveRoot");
        var i = g.typeNameToMemberName(t.singleRootType || o);
        return n.push(i), g.construct(n, t);
    }, g.destroySingle = function(e, t, r) {
        r = r || g.globalInstantiator;
        var n = g.model.parseToSegments(e, r.parseEL, !0), o = g.typeNameToMemberName(t);
        n.push(o), g.destroy(n, r);
    }, g.makeGradeLinkage = function(e, t, r) {
        g.defaults(e, {
            gradeNames: "fluid.component",
            distributeOptions: {
                record: r,
                target: "{/ " + t.join("&") + "}.options.gradeNames"
            }
        }), g.constructSingle([], e);
    }, g.componentForPath = function(e) {
        return g.globalInstantiator.pathToComponent[g.isArrayable(e) ? e.join(".") : e];
    }, g.thisistToApplicable = function(o, a, i) {
        return {
            apply: function(e, t) {
                var r = g.expandOptions(a, i);
                "string" == typeof r && (r = g.getGlobalValue(r)), r || g.fail("Could not resolve reference " + a + " to a value");
                var n = r[o.method];
                return "function" != typeof n && g.fail("Object ", r, " at reference " + a + " has no member named " + o.method + " which is a function "), 
                g.passLogLevel(g.logLevel.TRACE) && g.log(g.logLevel.TRACE, "Applying arguments ", t, " to method " + o.method + " of instance ", r), 
                n.apply(r, t);
            }
        };
    }, g.changeToApplicable = function(s, c) {
        return {
            apply: function(e, t, r, n) {
                var o = g.parseValidModelReference(c, "changePath listener record", s.changePath), a = g.expandOptions(s.value, c, {}, g.extend(r, {
                    arguments: t
                })), i = n && n.source && n.source.length ? g.makeArray(s.source).concat(n.source) : s.source;
                o.applier.change(o.modelSegs, a, s.type, i);
            }
        };
    }, g.recordToApplicable = function(e, t, r) {
        if (void 0 !== e.changePath) return g.changeToApplicable(e, t, r);
        var n = e.this;
        return e.method ^ n && g.fail("Record ", t, ' must contain both entries "method" and "this" if it contains either'), 
        e.method ? g.thisistToApplicable(e, n, t) : null;
    }, g.getGlobalValueNonComponent = function(e, t) {
        var r = g.defaults(e);
        return r && g.hasGrade(r, "fluid.component") && g.fail("Error in function specification - cannot invoke function " + e + " in the context of " + t + ": component creator functions can only be used as subcomponents"), 
        g.getGlobalValue(e);
    }, g.makeInvoker = function(r, n, o) {
        void 0 === (n = g.upgradePrimitiveFunc(n)).args || n.args === g.NO_VALUE || g.isArrayable(n.args) || (n.args = g.makeArray(n.args));
        var a = g.recordToApplicable(n, r), i = g.preExpand(n.args), s = {}, c = g.makeStackResolverOptions(r, s, !0);
        return (a = a || (n.funcName ? g.getGlobalValueNonComponent(n.funcName, "an invoker") : g.expandImmediate(n.func, r))) && a.apply ? a === g.notImplemented && g.fail("Error constructing component ", r, " - the invoker named " + o + " which was defined in grade " + n.componentSource + " needs to be overridden with a concrete implementation") : g.fail("Error in invoker record: could not resolve members func, funcName or method to a function implementation - got " + a + " from ", n), 
        function() {
            var e, t;
            return !1 === g.defeatLogging && g.pushActivity("invokeInvoker", "invoking invoker with name %name and record %record holding component %that", {
                name: o,
                record: n,
                that: r
            }), "destroyed" === r.lifecycleStatus ? g.log(g.logLevel.WARN, "Ignoring call to invoker " + o + " of component ", r, " which has been destroyed") : (s.arguments = arguments, 
            t = void 0 === n.args || n.args === g.NO_VALUE ? arguments : (g.expandImmediateImpl(i, c), 
            i.source), e = a.apply(null, t)), !1 === g.defeatLogging && g.popActivity(), e;
        };
    }, g.event.makeTrackedListenerAdder = function(e) {
        var i = g.shadowForComponent(e);
        return function(a) {
            return {
                addListener: function(e, t, r, n, o) {
                    g.recordListener(a, e, i, o), a.addListener.apply(null, arguments);
                }
            };
        };
    }, g.event.listenerEngine = function(r, n, o) {
        var a = {};
        g.each(r, function(e, t) {
            o(e).addListener(function() {
                a[t] = g.makeArray(arguments), function() {
                    if (!g.find(r, function(e, t) {
                        if (void 0 === a[t]) return !0;
                    })) {
                        var e = a;
                        a = {}, n(e);
                    }
                }();
            });
        });
    }, g.event.dispatchListener = function(n, o, a, i, s) {
        void 0 === i.args || i.args === g.NO_VALUE || g.isArrayable(i.args) || (i.args = g.makeArray(i.args)), 
        o = g.event.resolveListener(o);
        function e() {
            !1 === g.defeatLogging && g.pushActivity("dispatchListener", "firing to listener to event named %eventName of component %that", {
                eventName: a,
                that: n
            });
            var e, t = s ? arguments[0] : arguments;
            l.arguments = t, e = void 0 !== i.args && i.args !== g.NO_VALUE ? (g.expandImmediateImpl(c, u), 
            c.source) : t;
            var r = o.apply(null, e);
            return !1 === g.defeatLogging && g.popActivity(), r;
        }
        var c = g.preExpand(i.args), l = {}, u = g.makeStackResolverOptions(n, l, !0);
        return g.event.impersonateListener(o, e), e;
    }, g.event.resolveSoftNamespace = function(e) {
        if ("string" != typeof e) return null;
        var t = Math.max(e.lastIndexOf("."), e.lastIndexOf("}"));
        return e.substring(t + 1);
    }, g.event.resolveListenerRecord = function(e, i, s, c, l) {
        function u(e, t) {
            g.fail("Error in listener record - could not resolve reference ", e, ' to a listener or firer. Did you miss out "events." when referring to an event firer?' + t);
        }
        g.pushActivity("resolveListenerRecord", "resolving listener record for event named %eventName for component %that", {
            eventName: s,
            that: i
        });
        var t = g.makeArray(e), r = {
            records: g.transform(t, function(e) {
                var t = g.isPrimitive(e) || e.expander ? {
                    listener: e
                } : g.copy(e), r = g.recordToApplicable(e, i, l);
                t.listener = r || (t.listener || t.func || t.funcName), t.listener || u(e, ' Listener record must contain a member named "listener", "func", "funcName" or "method"');
                var n = e.method ? g.event.resolveSoftNamespace(e.this) + "." + e.method : g.event.resolveSoftNamespace(t.listener);
                t.namespace || c || !n || (t.softNamespace = !0, t.namespace = (e.componentSource ? e.componentSource : i.typeName) + "." + n);
                var o = t.listener = g.expandOptions(t.listener, i);
                o || u(e, "");
                var a = !1;
                return "fluid.event.firer" === o.typeName && (o = o.fire, a = !0), t.listener = l && (t.args && "fluid.notImplemented" !== o || a) ? g.event.dispatchListener(i, o, s, t) : o, 
                t.listenerId = g.allocateGuid(), t;
            }),
            adderWrapper: l ? g.event.makeTrackedListenerAdder(i) : null
        };
        return g.popActivity(), r;
    }, g.event.expandOneEvent = function(e, t) {
        var r;
        return (r = "string" == typeof t && "{" !== t.charAt(0) ? g.getForComponent(e, [ "events", t ]) : g.expandOptions(t, e)) && "fluid.event.firer" === r.typeName || g.fail("Error in event specification - could not resolve base event reference ", t, " to an event firer: got ", r), 
        r;
    }, g.event.expandEvents = function(t, e) {
        return "string" == typeof e ? g.event.expandOneEvent(t, e) : g.transform(e, function(e) {
            return g.event.expandOneEvent(t, e);
        });
    }, g.event.resolveEvent = function(i, s, c) {
        g.pushActivity("resolveEvent", "resolving event with name %eventName attached to component %that", {
            eventName: s,
            that: i
        });
        var l = g.event.makeTrackedListenerAdder(i);
        "string" == typeof c && (c = {
            event: c
        });
        var e = "fluid.event.firer" === c.typeName ? c : c.event || c.events;
        e || g.fail("Event specification for event with name " + s + " does not include a base event specification: ", c);
        var t, u = "fluid.event.firer" === e.typeName ? e : g.event.expandEvents(i, e), r = "fluid.event.firer" !== u.typeName;
        if (c.args || r) {
            t = g.makeEventFirer({
                name: " [composite] " + g.event.nameEvent(i, s)
            });
            var n = g.event.dispatchListener(i, t.fire, s, c, r);
            r ? g.event.listenerEngine(u, n, l) : l(u).addListener(n);
        } else (t = {
            typeName: "fluid.event.firer",
            fire: function() {
                var e = g.makeArray(arguments);
                g.pushActivity("fireSynthetic", "firing synthetic event %eventName ", {
                    eventName: s
                });
                var t = u.fire.apply(null, e);
                return g.popActivity(), t;
            },
            addListener: function(e, t, r, n, o) {
                var a = g.event.dispatchListener(i, e, s, c);
                l(u).addListener(a, t, r, n, o);
            },
            removeListener: function(e) {
                u.removeListener(e);
            }
        }).originEvent = u;
        return g.popActivity(), t;
    }, g.coerceToPrimitive = function(e) {
        return "false" !== e && ("true" === e || (isFinite(e) ? Number(e) : e));
    }, g.compactStringToRec = function(e, t) {
        var r = e.indexOf("("), n = e.indexOf(")");
        if ((-1 === r ^ -1 === n || n < r) && g.fail("Badly-formed compact " + t + " record without matching parentheses: " + e), 
        -1 === r || -1 === n) return "expander" === t && g.fail("Badly-formed compact expander record without parentheses: " + e), 
        e;
        var o = e.substring(n + 1);
        "" !== d.trim(o) && g.fail("Badly-formed compact " + t + " record " + e + " - unexpected material following close parenthesis: " + o);
        var a = e.substring(0, r), i = d.trim(e.substring(r + 1, n)), s = "" === i ? [] : g.transform(i.split(","), d.trim, g.coerceToPrimitive), c = g.upgradePrimitiveFunc(a, null);
        return c.args = s, c;
    }, g.expandPrefix = "@expand:", g.expandCompactString = function(e, t) {
        var r = e;
        if (0 === e.indexOf(g.expandPrefix)) {
            var n = e.substring(g.expandPrefix.length);
            r = {
                expander: g.compactStringToRec(n, "expander")
            };
        } else t && (r = g.compactStringToRec(e, t));
        return r;
    };
    var a = {
        listeners: "listener",
        modelListeners: "modelListener"
    }, i = d.extend({
        invokers: "invoker"
    }, a);
    function u(e, t, r, n) {
        for (var o = 0; o < r; ++o) e = n(e, t[o], o, g.makeArray(t));
        return e;
    }
    g.expandCompactRec = function(r, n, e) {
        g.guardCircularExpansion(r, r.length);
        var t = g.peek(r), o = i[t];
        !o && 1 < r.length && (o = a[r[r.length - 2]]), g.each(e, function(e, t) {
            if (g.isPlainObject(e)) return n[t] = g.freshContainer(e), r.push(t), g.expandCompactRec(r, n[t], e), 
            void r.pop();
            "string" == typeof e && (e = g.expandCompactString(e, o)), n[t] = e;
        });
    }, g.expandCompact = function(e) {
        var t = {};
        return g.expandCompactRec([], t, e), t;
    }, g.extractEL = function(e, t) {
        if ("ALL" === t.ELstyle) return e;
        if (1 === t.ELstyle.length) {
            if (e.charAt(0) === t.ELstyle) return e.substring(1);
        } else if ("${}" === t.ELstyle) {
            var r = e.indexOf("${"), n = e.lastIndexOf("}");
            if (0 === r && -1 !== n) return e.substring(2, n);
        }
    }, g.extractELWithContext = function(e, t) {
        var r = g.extractEL(e, t);
        return g.isIoCReference(r) ? g.parseContextReference(r) : r ? {
            path: r
        } : r;
    }, g.parseContextReference = function(e, t, r) {
        t = t || 0;
        var n, o, a, i = "{" === e.charAt(t + 1);
        -1 === (n = i ? (a = g.parseContextReference(e, t + 1, "}")).endpos : e.indexOf("}", t + 1)) && g.fail('Cannot parse context reference "' + e + '": Malformed context reference without }'), 
        o = i ? a : e.substring(t + 1, n);
        var s = r ? e.indexOf(r, n + 1) : e.length, c = e.substring(n + 1, s);
        return "." === c.charAt(0) && (c = c.substring(1)), {
            context: o,
            path: c,
            endpos: s
        };
    }, g.renderContextReference = function(e) {
        var t = e.context;
        return "{" + ("string" == typeof t ? t : g.renderContextReference(t)) + "}" + (e.path ? "." + e.path : "");
    }, g.resolveContextValue = function(e, r) {
        function t(e) {
            g.pushActivity("resolveContextValue", "resolving context value %parsed", {
                parsed: e
            });
            var t = r.fetcher(e);
            return g.pushActivity("resolvedContextValue", "resolved value %parsed to value %value", {
                parsed: e,
                value: t
            }), g.popActivity(2), t;
        }
        var n;
        if (r.bareContextRefs && g.isIoCReference(e)) return t(n = g.parseContextReference(e));
        if (r.ELstyle && "${}" !== r.ELstyle && (n = g.extractELWithContext(e, r))) return t(n);
        for (;"string" == typeof e; ) {
            var o = e.indexOf("${"), a = e.indexOf("}", o + 2);
            if (-1 === o || -1 === a) break;
            "{" === e.charAt(o + 2) ? a = (n = g.parseContextReference(e, o + 2, "}")).endpos : n = {
                path: e.substring(o + 2, a)
            };
            var i = t(n), s = 0 === o && a === e.length - 1;
            if (null == i) return i;
            e = s ? i : e.substring(0, o) + i + e.substring(a + 1);
        }
        return e;
    }, g.fetchExpandChildren = function(r, n, o, a, i, s) {
        if (a.expander) {
            var e = g.expandExpander(r, a, s);
            if (g.isPrimitive(e) || !g.isPlainObject(e) || g.isArrayable(e) ^ g.isArrayable(r)) return e;
            d.extend(!0, r, e);
        }
        return g.each(a, function(e, t) {
            void 0 === e ? r[t] = void 0 : "expander" !== t && (o[n] = t, !0 !== g.getImmediate(s.exceptions, o, n) && s.strategy(r, t, n + 1, o, a, i));
        }), r;
    }, g.isUnexpandable = function(e) {
        return g.isPrimitive(e) || !g.isPlainObject(e);
    }, g.expandSource = function(e, t, r, n, o, a, i, s) {
        var c, l, u = g.derefMergePolicy(i);
        return "string" != typeof a || u.noexpand ? u.noexpand || g.isUnexpandable(a) ? c = a : a.expander ? c = g.expandExpander(o, a, e) : (c = g.freshContainer(a), 
        l = !0) : e.defaultEL && "{" !== a.charAt(0) ? c = a : (g.pushActivity("expandContextValue", "expanding context value %source held at path %path", {
            source: a,
            path: g.path.apply(null, n.slice(0, r))
        }), c = g.resolveContextValue(a, e), g.popActivity(1)), c !== g.NO_VALUE && o(c), 
        l && s(c, a, r, n, i), c;
    }, g.guardCircularExpansion = function(e, t) {
        t > g.strategyRecursionBailout && g.fail("Overflow/circularity in options expansion, current path is ", e, " at depth ", t, ' - please ensure options are not circularly connected, or protect from expansion using the "noexpand" policy or expander');
    }, g.makeExpandStrategy = function(c) {
        function l(e, t, r, n, o) {
            return g.fetchExpandChildren(e, r || 0, n || [], t, o, c);
        }
        function e(t, r, e, n, o, a) {
            if (g.guardCircularExpansion(n, e), t) {
                if (t.hasOwnProperty(r)) return t[r];
                void 0 === o && (o = u(c.source, n, e - 1, c.sourceStrategy), a = u(c.mergePolicy, n, e - 1, g.concreteTrundler));
                var i = c.sourceStrategy(o, r, e, n), s = g.concreteTrundler(a, r);
                return g.expandSource(c, t, e, n, function(e) {
                    t[r] = e;
                }, i, s, l);
            }
        }
        return c.recurse = l, c.strategy = e;
    }, g.defaults("fluid.makeExpandOptions", {
        ELstyle: "${}",
        bareContextRefs: !0,
        target: g.inCreationMarker
    }), g.makeExpandOptions = function(e, t) {
        return (t = d.extend({}, g.rawDefaults("fluid.makeExpandOptions"), t)).defaultEL = "${}" === t.ELStyle && t.bareContextRefs, 
        t.expandSource = function(e) {
            return g.expandSource(t, null, 0, [], g.identity, e, t.mergePolicy, !1);
        }, g.isUnexpandable(e) ? (t.strategy = g.concreteTrundler, t.initter = g.identity, 
        t.target = "string" == typeof e ? (t.defer ? g.copy : g.identity)(t.expandSource(e)) : e, 
        t.immutableTarget = !0) : (t.source = e, t.target = g.freshContainer(e), t.sourceStrategy = t.sourceStrategy || g.concreteTrundler, 
        g.makeExpandStrategy(t), t.initter = function() {
            t.target = g.fetchExpandChildren(t.target, 0, [], t.source, t.mergePolicy, t);
        }), t;
    }, g.expand = function(e, t) {
        var r = g.makeExpandOptions(e, t);
        return r.initter(), r.target;
    }, g.preExpandRecurse = function(r, n, t, o, a) {
        function e(e) {
            r.expanders.push({
                expander: e,
                holder: t,
                member: o
            }), delete t[o];
        }
        if (g.guardCircularExpansion(a, a.length), g.isIoCReference(n)) {
            var i = g.parseContextReference(n), s = g.model.parseEL(i.path);
            e({
                typeFunc: g.expander.fetch,
                context: i.context,
                segs: s
            });
        } else g.isPlainObject(n) && (n.expander ? (n.expander.typeFunc = g.getGlobalValue(n.expander.type || "fluid.invokeFunc"), 
        e(n.expander)) : g.each(n, function(e, t) {
            a.push(t), g.preExpandRecurse(r, e, n, t, a), a.pop();
        }));
    }, g.preExpand = function(e) {
        var t = {
            expanders: [],
            source: g.isUnexpandable(e) ? e : g.copy(e)
        };
        return g.preExpandRecurse(t, t.source, t, "source", []), t;
    }, g.expandImmediate = function(e, t, r) {
        var n = g.makeStackResolverOptions(t, r, !0), o = g.preExpand(e);
        return g.expandImmediateImpl(o, n), o.source;
    }, g.expandImmediateImpl = function(e, t) {
        for (var r = e.expanders, n = 0; n < r.length; ++n) {
            var o = r[n];
            o.holder[o.member] = o.expander.typeFunc(null, o, t);
        }
    }, g.expandExpander = function(e, t, r) {
        var n = g.getGlobalValue(t.expander.type || "fluid.invokeFunc");
        return n || g.fail("Unknown expander with type " + t.expander.type), n(e, t, r);
    }, g.registerNamespace("fluid.expander"), g.expander.fetch = function(e, t, r) {
        var n = r.localRecord, o = t.expander.context, a = t.expander.segs, i = void 0 !== n[o], s = r.contextThat.lifecycleStatus, c = "treeConstructed" === s || "destroyed" === s, l = i ? n[o] : g.resolveContext(o, r.contextThat, c);
        if (l) {
            var u = l;
            if (i || "constructing" !== l.lifecycleStatus) for (var d = 0; d < a.length; ++d) u = u ? u[a[d]] : void 0; else u = g.getForComponent(l, a);
            return void 0 !== u || i || (u = g.getForComponent(l, a)), u;
        }
        0 < a.length && g.triggerMismatchedPathError(t.expander, r.contextThat);
    }, g.invokeFunc = function(e, t, r) {
        var n = t.expander, o = g.makeArray(n.args), a = n.func ? "func" : n.funcName ? "funcName" : null;
        n.args = o, o = r.recurse ? r.recurse([], o) : (n = g.expandImmediate(n, r.contextThat, r.localRecord)).args;
        var i = n[a], s = (r.expandSource ? r.expandSource(i) : i) || g.recordToApplicable(n, r.contextThat);
        return "string" == typeof s && (s = g.getGlobalValue(s)), s || g.fail("Error in expander record ", t.expander, ": " + t.expander[a] + " could not be resolved to a function for component ", r.contextThat), 
        s.apply(null, o);
    }, g.noexpand = function(e, t) {
        return t.expander.value ? t.expander.value : t.expander.tree;
    };
}(jQuery, fluid_3_0_0 = fluid_3_0_0 || {}), function(r, y) {
    "use strict";
    y.model.makeEnvironmentStrategy = function(n) {
        return function(e, t, r) {
            return 0 === r && n[t] ? n[t] : void 0;
        };
    }, y.model.defaultCreatorStrategy = function(e, t) {
        if (void 0 === e[t]) return e[t] = {}, e[t];
    }, y.model.defaultFetchStrategy = function(e, t) {
        return e[t];
    }, y.model.funcResolverStrategy = function(e, t) {
        if (e.resolvePathSegment) return e.resolvePathSegment(t);
    }, y.model.traverseWithStrategy = function(e, t, r, n, o) {
        for (var a = n.strategies, i = t.length - o, s = r; s < i; ++s) {
            if (!e) return e;
            for (var c, l = 0; l < a.length && void 0 === (c = a[l](e, t[s], s + 1, t)); ++l) ;
            c === y.NO_VALUE && (c = void 0), e = c;
        }
        return e;
    }, y.model.getValueAndSegments = function(e, t, r, n) {
        return y.model.accessWithStrategy(e, t, y.NO_VALUE, r, n, !0);
    }, y.model.makeTrundler = function(r) {
        return function(e, t) {
            return y.model.getValueAndSegments(e.root, t, r, e.segs);
        };
    }, y.model.getWithStrategy = function(e, t, r, n) {
        return y.model.accessWithStrategy(e, t, y.NO_VALUE, r, n);
    }, y.model.setWithStrategy = function(e, t, r, n, o) {
        y.model.accessWithStrategy(e, t, r, n, o);
    }, y.model.accessWithStrategy = function(e, t, r, n, o, a) {
        if (y.isPrimitive(t) || y.isArrayable(t)) return y.model.accessImpl(e, t, r, n, o, a, y.model.traverseWithStrategy);
        var i = t.type || "default", s = n.resolvers[i];
        s || y.fail("Unable to find resolver of type " + i);
        var c = y.model.makeTrundler(n), l = {
            root: e,
            segs: o
        };
        return l = s(l, t, c), t.path && l && (l = c(l, t.path)), a ? l : l ? l.root : void 0;
    }, y.registerNamespace("fluid.pathUtil"), y.pathUtil.getPathSegmentImpl = function(e, t, r) {
        var n = null;
        e && (n = "");
        for (var o = !1, a = t.length; r < a; ++r) {
            var i = t.charAt(r);
            if (o) o = !1, null !== n && (n += i); else {
                if ("." === i) break;
                "\\" === i ? o = !0 : null !== n && (n += i);
            }
        }
        return null !== n && (e[0] = n), r;
    };
    var a = [];
    y.pathUtil.parseEL = function(e) {
        for (var t = [], r = 0, n = e.length; r < n; ) {
            var o = y.pathUtil.getPathSegmentImpl(a, e, r);
            t.push(a[0]), r = o + 1;
        }
        return t;
    }, y.pathUtil.composeSegment = function(e, t) {
        t = t.toString();
        for (var r = 0; r < t.length; ++r) {
            var n = t.charAt(r);
            "." !== n && "\\" !== n && "}" !== n || (e += "\\"), e += n;
        }
        return e;
    }, y.pathUtil.escapeSegment = function(e) {
        return y.pathUtil.composeSegment("", e);
    }, y.pathUtil.composePath = function(e, t) {
        return 0 !== e.length && (e += "."), y.pathUtil.composeSegment(e, t);
    }, y.pathUtil.composeSegments = function() {
        for (var e = "", t = 0; t < arguments.length; ++t) e = y.pathUtil.composePath(e, arguments[t]);
        return e;
    }, y.pathUtil.matchSegments = function(e, t, r, n) {
        if (n - r !== e.length) return !1;
        for (var o = r; o < n; ++o) if (t[o] !== e[o - r]) return !1;
        return !0;
    }, y.model.unescapedParser = {
        parse: y.model.parseEL,
        compose: y.model.composeSegments
    }, y.model.defaultGetConfig = {
        parser: y.model.unescapedParser,
        strategies: [ y.model.funcResolverStrategy, y.model.defaultFetchStrategy ]
    }, y.model.defaultSetConfig = {
        parser: y.model.unescapedParser,
        strategies: [ y.model.funcResolverStrategy, y.model.defaultFetchStrategy, y.model.defaultCreatorStrategy ]
    }, y.model.escapedParser = {
        parse: y.pathUtil.parseEL,
        compose: y.pathUtil.composeSegments
    }, y.model.escapedGetConfig = {
        parser: y.model.escapedParser,
        strategies: [ y.model.defaultFetchStrategy ]
    }, y.model.escapedSetConfig = {
        parser: y.model.escapedParser,
        strategies: [ y.model.defaultFetchStrategy, y.model.defaultCreatorStrategy ]
    }, y.stronglyConnected = function(e, t) {
        var r = {
            stack: [],
            accessor: t,
            components: [],
            index: 0
        };
        return e.forEach(function(e) {
            delete e.lowIndex, delete e.tarjanIndex, delete e.onStack;
        }), e.forEach(function(e) {
            void 0 === e.tarjanIndex && y.stronglyConnectedOne(e, r);
        }), r.components;
    }, y.stronglyConnectedOne = function(t, r) {
        if (t.tarjanIndex = r.index, t.lowIndex = r.index, ++r.index, r.stack.push(t), t.onStack = !0, 
        r.accessor(t).forEach(function(e) {
            void 0 === e.tarjanIndex ? (y.stronglyConnectedOne(e, r), t.lowIndex = Math.min(t.lowIndex, e.lowIndex)) : e.onStack && (t.lowIndex = Math.min(t.lowIndex, e.tarjanIndex));
        }), t.lowIndex === t.tarjanIndex) {
            for (var e, n = []; (e = r.stack.pop()).onStack = !1, n.push(e), e !== t; ) ;
            r.components.push(n);
        }
    }, y.initRelayModel = function(e) {
        return e.model;
    }, y.findInitModelTransaction = function(e) {
        var t = y.currentTreeTransaction();
        if (t && y.isComponent(e)) return t.initModelTransaction[e.id];
    }, y.enlistModelComponent = function(e) {
        var t = y.currentTreeTransaction().initModelTransaction, r = t[e.id];
        if (!r) {
            var n = y.shadowForComponent(e);
            r = {
                that: e,
                applier: y.getForComponent(e, "applier"),
                completeOnInit: !!n.initTransactionId
            }, t[e.id] = r;
        }
        return r;
    }, y.clearTransactions = function() {
        var e = y.globalInstantiator;
        y.clear(e.modelTransactions);
    }, y.failureEvent.addListener(y.clearTransactions, "clearTransactions", "before:fail"), 
    y.clearLinkCounts = function(r, n) {
        y.each(r, function(e, t) {
            "number" == typeof e ? r[t] = 0 : n && e.options && "number" == typeof e.relayCount && (e.relayCount = 0);
        });
    }, y.computeInitialOutArcs = function(a, i) {
        return y.transform(i, function(e, r) {
            var n = {}, t = e.that.applier.listeners.sortedListeners;
            y.each(t, function(e) {
                if (e.isRelay && !y.isExcludedChangeSource(a[r], e.cond)) {
                    var t = e.targetId;
                    t !== r && (n[t] = !0);
                }
            });
            var o = Object.keys(n).map(function(e) {
                return i[e];
            });
            return y.remove_if(o, function(e) {
                return void 0 === e;
            }), o;
        });
    }, y.sortCompleteLast = function(e, t) {
        return (e.completeOnInit ? 1 : 0) - (t.completeOnInit ? 1 : 0);
    }, y.subscribeResourceModelUpdates = function(n, o, e) {
        function t(e) {
            var t = y.getImmediate(a, [ "initModelTransaction", n.id ]), r = t ? t.transaction : n.applier.initiate();
            r.change(o, null, "DELETE"), r.change(o, e), t || r.commit();
        }
        var a = y.currentTreeTransaction();
        e.onFetched.addListener(t), y.recordListener(e.onFetched, t, y.shadowForComponent(n));
    }, y.operateInitialTransaction = function(e, a) {
        var t, i = y.getModelTransactionRec(y.rootComponent, a), s = y.transform(e, function(e) {
            return t = e.that.applier.initiate(null, "init", a), i[e.that.applier.applierId] = {
                transaction: t
            }, e.transaction = t;
        }), r = y.computeInitialOutArcs(s, e), n = y.values(e), o = y.stronglyConnected(n, function(e) {
            return r[e.that.id];
        }), c = 0;
        o.forEach(function(e) {
            e.forEach(function(e) {
                e.initPriority = e.completeOnInit ? 1 / 0 : c++;
            });
        }), n.sort(function(e, t) {
            return e.initPriority - t.initPriority;
        }), n.forEach(function(e) {
            var t = e.that, r = t.applier, n = s[t.id];
            e.completeOnInit ? y.notifyModelChanges(r.listeners.sortedListeners, "ADD", n.oldHolder, y.emptyHolder, null, n, r, t) : (r.resourceMap.forEach(function(e) {
                y.subscribeResourceModelUpdates(t, e.segs, e.fetchOne.resourceSpec);
            }), y.each(e.initModels, function(e) {
                void 0 !== e && n.fireChangeRequest({
                    type: "ADD",
                    segs: [],
                    value: e
                }), y.clearLinkCounts(i, !0);
            }), t.model = n.newHolder.model, r.earlyModelResolved.fire(t.model), e.completeOnInit = !0);
            var o = y.shadowForComponent(t);
            o && !o.initTransactionId && (o.initTransactionId = a);
        });
    }, y.parseModelReference = function(e, t) {
        var r = y.parseContextReference(t);
        return r.segs = y.pathUtil.parseEL(r.path), r;
    }, y.parseValidModelReference = function(e, t, r, n) {
        function o() {
            var e = [ "Error in " + t + ": ", r ].concat(y.makeArray(arguments));
            y.fail.apply(null, e);
        }
        function a(e) {
            o(" must be a reference to a component with a ChangeApplier (descended from fluid.modelComponent), instead got ", e);
        }
        var i, s, c, l = y.shadowForComponent(e).localRecord;
        if ("string" == typeof r) if (y.isIoCReference(r)) {
            var u = (i = y.parseModelReference(e, r)).segs.indexOf("model");
            -1 === u ? n ? i.nonModel = !0 : o(' must be a reference into a component model via a path including the segment "model"') : (i.modelSegs = i.segs.slice(u + 1), 
            i.contextSegs = i.segs.slice(0, u), delete i.path);
        } else i = {
            path: r,
            modelSegs: e.applier.parseEL(r)
        }; else y.isArrayable(r.segs) || o(' must contain an entry "segs" holding path segments referring a model path within a component'), 
        i = {
            context: r.context,
            modelSegs: y.expandOptions(r.segs, e)
        };
        return i.context ? l && i.context in l ? "source" === i.context && l.sourceModelReference ? (c = l.sourceModelReference.that, 
        i.modelSegs = l.sourceModelReference.modelSegs.concat(i.segs), i.nonModel = !1) : c = l[i.context] : ((s = y.resolveContext(i.context, e)) || o(" context must be a reference to an existing component"), 
        c = i.contextSegs ? y.getForComponent(s, i.contextSegs) : s) : c = e, i.nonModel || (y.isComponent(c) || a(c), 
        c.applier || y.getForComponent(c, [ "applier" ]), c.applier || a(c)), i.that = c, 
        i.applier = c && c.applier, i.path || (i.path = c && c.applier.composeSegments.apply(null, i.modelSegs)), 
        i;
    }, y.getModelTransactionRec = function(e, t) {
        t || y.fail("Cannot get transaction record without transaction id");
        var r = y.isComponent(e) && !y.isDestroyed(e) ? y.globalInstantiator : null;
        if (!r) return null;
        var n = r.modelTransactions[t];
        return n = n || (r.modelTransactions[t] = {
            relays: [],
            sources: {},
            externalChanges: {}
        });
    }, y.recordChangeListener = function(e, t, r, n) {
        var o = y.shadowForComponent(e);
        y.recordListener(t.modelChanged, r, o, n);
    }, y.registerRelayTransaction = function(e, t, r, n, o) {
        var a = t.initiate("relay", null, r), i = e[t.applierId] = {
            transaction: a,
            relayCount: 0,
            namespace: o.namespace,
            priority: o.priority,
            options: n
        };
        return i.priority = y.parsePriority(i.priority, e.relays.length, !1, "model relay"), 
        e.relays.push(i), i;
    }, y.relayRecursionBailout = 100, y.registerDirectChangeRelay = function(l, u, e, d, p, f, m, g) {
        var h = m.targetApplier || l.applier, t = m.sourceApplier || e.applier, v = h.applierId;
        u = y.makeArray(u), d = y.makeArray(d);
        function r(e, t, r, n, o, a) {
            var i = o.id, s = y.getModelTransactionRec(l, i);
            a && o && !s[a.applierId] && (s[a.applierId] = {
                transaction: o
            });
            var c = s[v];
            s[p] = s[p] || 0, ++s[p], s[p] > y.relayRecursionBailout && y.fail("Error in model relay specification at component ", l, " - operated more than " + y.relayRecursionBailout + " relays without model value settling - current model contents are ", o.newHolder.model), 
            c = c || y.registerRelayTransaction(s, h, i, m, g), f && !m.targetApplier ? f(c.transaction, m.sourceApplier ? void 0 : e, d, u, n) : (n && "DELETE" === n.type && c.transaction.fireChangeRequest({
                type: "DELETE",
                segs: u
            }), void 0 !== e && c.transaction.fireChangeRequest({
                type: "ADD",
                segs: u,
                value: e
            }));
        }
        var n = t.modelChanged.addListener({
            isRelay: !0,
            cond: f && f.cond,
            targetId: l.id,
            targetApplierId: h.id,
            segs: d,
            transactional: m.transactional
        }, r);
        y.passLogLevel(y.logLevel.TRACE) && y.log(y.logLevel.TRACE, "Adding relay listener with listenerId " + n.listenerId + " to source applier with id " + t.applierId + " from target applier with id " + v + " for target component with id " + l.id), 
        e && (y.recordChangeListener(e, t, r, n.listenerId), l !== e && y.recordChangeListener(l, t, r, n.listenerId));
    }, y.connectModelRelay = function(e, t, r, n, o) {
        var a = y.allocateGuid();
        y.enlistModelComponent(r), y.enlistModelComponent(e);
        var i = y.filterKeys(o, [ "namespace", "priority" ]);
        o.update ? o.targetApplier ? y.registerDirectChangeRelay(e, t, r, n, a, null, {
            transactional: !1,
            targetApplier: o.targetApplier,
            update: o.update
        }, i) : y.registerDirectChangeRelay(r, n, e, [], a + "-transform", o.forwardAdapter, {
            transactional: !0,
            sourceApplier: o.forwardApplier
        }, i) : (y.registerDirectChangeRelay(r, n, e, t, a, o.forwardAdapter, {
            transactional: !1
        }, i), y.registerDirectChangeRelay(e, t, r, n, a, o.backwardAdapter, {
            transactional: !1
        }, i));
    }, y.parseSourceExclusionSpec = function(e, t) {
        return e.excludeSource = y.arrayToHash(y.makeArray(t.excludeSource || (t.includeSource ? "*" : void 0))), 
        e.includeSource = y.arrayToHash(y.makeArray(t.includeSource)), e;
    }, y.isExcludedChangeSource = function(e, t) {
        if (!t || !t.excludeSource) return !1;
        var r = t.excludeSource["*"];
        for (var n in e.fullSources) t.excludeSource[n] && (r = !0), t.includeSource[n] && (r = !1);
        return r;
    }, y.model.guardedAdapter = function(e, t, r, n) {
        y.isExcludedChangeSource(e, t) || r === y.model.transform.uninvertibleTransform || r.apply(null, n);
    }, y.transformToAdapter = function(e, a) {
        var i = {};
        return i[a] = e, function(e, t, r, n, o) {
            o && "DELETE" === o.type && e.fireChangeRequest({
                type: "DELETE",
                path: a
            }), y.model.transformWithRules(t, i, {
                finalApplier: e
            });
        };
    }, y.makeTransformPackage = function(e, r, n, o, a, t, i, s) {
        var c = {
            forwardHolder: {
                model: r
            },
            backwardHolder: {
                model: null
            },
            generateAdapters: function(e) {
                if (c.forwardAdapterImpl = y.transformToAdapter(e ? e.newHolder.model : c.forwardHolder.model, o), 
                null !== n) {
                    var t = y.model.transform.invertConfiguration(r);
                    t !== y.model.transform.uninvertibleTransform ? (c.backwardHolder.model = t, c.backwardAdapterImpl = y.transformToAdapter(c.backwardHolder.model, n)) : c.backwardAdapterImpl = t;
                }
            },
            forwardAdapter: function(e, t) {
                void 0 === t && c.generateAdapters(), y.model.guardedAdapter(e, a, c.forwardAdapterImpl, arguments);
            }
        };
        c.forwardAdapter.cond = a, c.runTransform = function(e) {
            e.commit(), e.reset();
        }, c.forwardApplier = y.makeHolderChangeApplier(c.forwardHolder), c.forwardApplier.isRelayApplier = !0, 
        c.invalidator = y.makeEventFirer({
            name: "Invalidator for model relay with applier " + c.forwardApplier.applierId
        }), null !== n && (c.backwardApplier = y.makeHolderChangeApplier(c.backwardHolder), 
        c.backwardAdapter = function(e) {
            y.model.guardedAdapter(e, t, c.backwardAdapterImpl, arguments);
        }, c.backwardAdapter.cond = t), c.update = c.invalidator.fire;
        var l = {
            targetApplier: c.forwardApplier,
            update: c.update,
            namespace: i,
            priority: s,
            refCount: 0
        };
        return c.forwardHolder.model = y.parseImplicitRelay(e, r, [], l), c.refCount = l.refCount, 
        c.namespace = i, c.priority = s, c.generateAdapters(), c.invalidator.addListener(c.generateAdapters), 
        c.invalidator.addListener(c.runTransform), c;
    }, y.singleTransformToFull = function(e) {
        return {
            "": {
                transform: r.extend(!0, {
                    inputPath: ""
                }, e)
            }
        };
    }, y.model.relayConditions = {
        initOnly: {
            includeSource: "init"
        },
        liveOnly: {
            excludeSource: "init"
        },
        never: {
            includeSource: []
        },
        always: {}
    }, y.model.parseRelayCondition = function(e) {
        var t;
        return "initOnly" === e ? y.log(y.logLevel.WARN, 'The relay condition "initOnly" is deprecated: Please use the form \'includeSource: "init"\' instead') : "liveOnly" === e && y.log(y.logLevel.WARN, 'The relay condition "liveOnly" is deprecated: Please use the form \'excludeSource: "init"\' instead'), 
        e ? "string" == typeof e ? (t = y.model.relayConditions[e]) || y.fail('Unrecognised model relay condition string "' + e + '": the supported values are "never" or a record with members "includeSource" and/or "excludeSource"') : t = e : t = {}, 
        y.parseSourceExclusionSpec({}, t);
    }, y.parseModelRelay = function(e, t, r) {
        var n = void 0 !== t.source ? y.parseValidModelReference(e, 'modelRelay record member "source"', t.source) : {
            path: null,
            modelSegs: null
        }, o = y.parseValidModelReference(e, 'modelRelay record member "target"', t.target), a = t.namespace || r, i = t.singleTransform ? y.singleTransformToFull(t.singleTransform) : t.transform;
        i || y.fail('Cannot parse modelRelay record without element "singleTransform" or "transform":', t);
        var s = y.model.parseRelayCondition(t.forward), c = y.model.parseRelayCondition(t.backward), l = y.makeTransformPackage(e, i, n.path, o.path, s, c, a, t.priority);
        0 === l.refCount ? y.connectModelRelay(n.that || e, n.modelSegs, o.that, o.modelSegs, y.filterKeys(l, [ "forwardAdapter", "backwardAdapter", "namespace", "priority" ])) : (n.modelSegs && y.fail('Error in model relay definition: If a relay transform has a model dependency, you can not specify a "source" entry - please instead enter this as "input" in the transform specification. Definition was ', t, " for component ", e), 
        y.connectModelRelay(e, null, o.that, o.modelSegs, l));
    }, y.parseImplicitRelay = function(n, e, o, a) {
        var i;
        if (y.isIoCReference(e)) {
            var t = y.parseValidModelReference(n, "model reference from model (implicit relay)", e, !0);
            if (t.nonModel) {
                if ((i = y.isComponent(t.that) ? y.getForComponent(t.that, t.segs) : y.getImmediate(t.that, t.segs)) instanceof y.fetchResources.FetchOne) return n.applier.resourceMap.push({
                    segs: y.makeArray(o),
                    fetchOne: i
                }), null;
            } else ++a.refCount, y.connectModelRelay(n, o, t.that, t.modelSegs, a);
        } else y.isPrimitive(e) || !y.isPlainObject(e) ? i = e : e.expander && y.isPlainObject(e.expander) ? i = y.expandOptions(e, n) : (i = y.freshContainer(e), 
        y.each(e, function(e, t) {
            o.push(t);
            var r = y.parseImplicitRelay(n, e, o, a);
            void 0 !== r && (i[t] = r), o.pop();
        }));
        return i;
    }, y.model.notifyExternal = function(e) {
        var t = e ? y.values(e.externalChanges) : [];
        y.sortByPriority(t);
        for (var r = 0; r < t.length; ++r) {
            var n = t[r];
            n.args[5].destroyed || n.listener.apply(null, n.args);
        }
        y.clearLinkCounts(e, !0);
    }, y.model.commitRelays = function(e, t) {
        var r = e.modelTransactions[t];
        y.each(r, function(e) {
            e.transaction && (e.transaction.commit("relay"), e.transaction.reset());
        });
    }, y.model.updateRelays = function(e, t) {
        var r = e.modelTransactions[t], n = 0;
        return y.sortByPriority(r.relays), y.each(r.relays, function(e) {
            0 < e.transaction.changeRecord.changes && e.relayCount < 2 && e.options.update && (e.relayCount++, 
            y.clearLinkCounts(r), e.options.update(e.transaction, r), ++n);
        }), n;
    }, y.concludeModelTransaction = function(e) {
        var t = y.globalInstantiator;
        y.model.notifyExternal(t.modelTransactions[e.id]), delete t.modelTransactions[e.id];
    }, y.establishModelRelay = function(n, e, t, r, o) {
        var a = y.shadowForComponent(n);
        a.modelRelayEstablished ? y.fail("FLUID-5887 failure: Model relay initialised twice on component", n) : a.modelRelayEstablished = !0;
        var i = y.enlistModelComponent(n);
        y.each(r, function(e, t) {
            for (var r = 0; r < e.length; ++r) y.parseModelRelay(n, e[r], t);
        });
        var s = y.transform(e, function(e) {
            return y.parseImplicitRelay(n, e, [], {
                refCount: 0,
                priority: "first"
            });
        });
        i.initModels = s;
        var c = y.getInstantiator(n);
        return o.preCommit.addListener(function(e) {
            for (;0 < y.model.updateRelays(c, e.id); ) ;
        }), o.preCommit.addListener(function(e, t, r) {
            "relay" !== r && y.model.commitRelays(c, e.id);
        }), o.postCommit.addListener(function(e, t, r) {
            "relay" !== r && y.concludeModelTransaction(e);
        }), o.postCommit.addListener(y.concludeAnyTransaction), null;
    }, y.destroyLensedComponentSource = function(e, t) {
        var r = y.shadowForComponent(e).localRecord.sourceModelReference;
        r && !y.isDestroyed(r.that) && r.that.applier.change(r.modelSegs, !1, t ? "ADD" : "DELETE");
    }, y.constructLensedComponents = function(e, n, t) {
        var r = e.lightMergeDynamicComponents[t], o = y.getImmediate(e.that.model, n.modelSegs), a = e.modelSourcedDynamicComponents[t], i = a.localRecordContributor = function(e, t, r) {
            e.sourceModelReference = {
                that: n.that,
                modelSegs: n.modelSegs.concat(a.isBoolean ? [] : [ r ])
            };
        };
        y.lightMergeRecords.pushRecord(r, {
            options: {
                listeners: {
                    afterDestroy: {
                        funcName: "fluid.destroyLensedComponentSource",
                        args: [ "{that}", a.isBoolean ]
                    }
                }
            }
        }), y.registerSourcedDynamicComponentsTriage(e.potentia, e.that, o, r, t, a.isBoolean, i);
    }, y.operateInitialTransactionWorkflow = function(e, t) {
        var r = t.initModelTransactionId;
        r || (r = y.allocateGuid(), t.initModelTransactionId = r), y.tryCatch(function() {
            y.operateInitialTransaction(t.initModelTransaction, r), e.forEach(function(r) {
                var e = r.that;
                y.registerMergedModelListeners(e, e.options.modelListeners), y.each(r.modelSourcedDynamicComponents, function(e, t) {
                    y.constructLensedComponents(r, e.sourcesParsed, t);
                });
            });
        }, function(e) {
            throw t.initModelTransaction = {}, t.initModelTransactionId = null, y.clearTransactions(), 
            e;
        }, y.identity);
    }, y.enlistModelWorkflow = function(e, t) {
        e.forEach(function(e) {
            y.getForComponent(e.that, "modelRelay");
        }), y.operateInitialTransactionWorkflow(e, t);
    }, y.notifyInitModelWorkflow = function(a, e) {
        if (!a.modelComplete) {
            var t = e.initModelTransaction, i = y.getModelTransactionRec(y.rootComponent, a.initTransactionId), s = Object.values(t)[0].transaction;
            e.initModelTransaction = {}, e.initModelTransactionId = null, s.commit(), y.each(t, function(e) {
                var t = e.that, r = t.applier;
                s = i[r.applierId].transaction;
                var n = r.transListeners.sortedListeners, o = y.shadowForComponent(t);
                o.modelComplete = !0, o.initTransactionId === a.initTransactionId && y.notifyModelChanges(n, "ADD", s.oldHolder, y.emptyHolder, null, s, r, t);
            }), y.concludeModelTransaction(s);
        }
    }, y.defaults("fluid.modelComponent", {
        gradeNames: [ "fluid.component" ],
        workflows: {
            global: {
                enlistModel: {
                    funcName: "fluid.enlistModelWorkflow"
                },
                resolveResourceModel: {
                    funcName: "fluid.identity",
                    priority: "after:enlistModel",
                    waitIO: !0
                }
            },
            local: {
                notifyInitModelWorkflow: {
                    funcName: "fluid.notifyInitModelWorkflow",
                    priority: "before:concludeComponentInit"
                }
            }
        },
        members: {
            model: "@expand:fluid.initRelayModel({that}, {that}.modelRelay)",
            applier: "@expand:fluid.makeHolderChangeApplier({that}, {that}.options.changeApplierOptions)",
            modelRelay: "@expand:fluid.establishModelRelay({that}, {that}.options.model, {that}.options.modelListeners, {that}.options.modelRelay, {that}.applier)"
        },
        mergePolicy: {
            model: {
                noexpand: !0,
                func: y.arrayConcatPolicy
            },
            modelListeners: y.makeMergeListenersPolicy(y.arrayConcatPolicy),
            modelRelay: y.makeMergeListenersPolicy(y.arrayConcatPolicy, !0)
        }
    }), y.modelChangedToChange = function(e) {
        return {
            value: e[0],
            oldValue: e[1],
            path: e[2],
            transaction: e[4]
        };
    }, y.event.invokeListener = function(e, t, r, n) {
        return "string" == typeof e && (e = y.event.resolveListener(e)), e.apply(null, t, r, n);
    }, y.resolveModelListener = function(o, a) {
        function e() {
            if (!y.isDestroyed(o)) {
                var e = y.modelChangedToChange(arguments), t = arguments, r = {
                    change: e,
                    arguments: t
                }, n = {
                    source: Object.keys(e.transaction.sources)
                };
                a.args && (t = y.expandOptions(a.args, o, {}, r)), y.event.invokeListener(a.listener, y.makeArray(t), r, n);
            }
        }
        return y.event.impersonateListener(a.listener, e), e;
    }, y.registerModelListeners = function(n, o, e, a) {
        var i = y.resolveModelListener(n, o);
        y.each(o.byTarget, function(e) {
            var t = e[0], r = {
                listener: i,
                listenerId: y.allocateGuid(),
                segsArray: y.getMembers(e, "modelSegs"),
                pathArray: y.getMembers(e, "path"),
                includeSource: o.includeSource,
                excludeSource: o.excludeSource,
                priority: y.expandOptions(o.priority, n),
                transactional: !0
            };
            r = t.applier.modelChanged.addListener(r, i, a, o.softNamespace), y.recordChangeListener(n, t.applier, i, r.listenerId);
        });
    }, y.registerMergedModelListeners = function(o, e) {
        y.each(e, function(e, n) {
            "string" == typeof e && (e = {
                funcName: e
            });
            var t = y.event.resolveListenerRecord(e, o, "modelListeners", null, !1).records;
            y.each(t, function(r) {
                r.byTarget = {};
                var e = y.makeArray(void 0 === r.path ? n : r.path);
                y.each(e, function(e) {
                    var t = y.parseValidModelReference(o, "modelListeners entry", e);
                    y.pushArray(r.byTarget, t.that.id, t);
                });
                var t = (r.namespace && !r.softNamespace ? r.namespace : null) || (void 0 !== r.path ? n : null);
                y.registerModelListeners(o, r, e, t);
            });
        });
    }, y.fireChanges = function(e, t) {
        for (var r = 0; r < t.length; ++r) e.fireChangeRequest(t[r]);
    }, y.model.isChangedPath = function(e, t) {
        for (var r = 0; r <= t.length; ++r) {
            if ("string" == typeof e) return !0;
            r < t.length && e && (e = e[t[r]]);
        }
        return !1;
    }, y.model.setChangedPath = function(t, r, n) {
        function e(e) {
            r.unshift(e), y.model.setSimple(t, r, n), r.shift();
        }
        y.model.isChangedPath(t.changeMap, r) || (++t.changes, e("changeMap")), y.model.isChangedPath(t.deltaMap, r) || (++t.deltas, 
        e("deltaMap"));
    }, y.model.fetchChangeChildren = function(r, n, o, e, a) {
        y.each(e, function(e, t) {
            o[n] = t, y.model.applyChangeStrategy(r, t, n, o, e, a), o.length = n;
        });
    }, y.model.isSameValue = function(e, t) {
        return "number" != typeof e || "number" != typeof t ? e === t : e === t || e != e && t != t || Math.abs((e - t) / t) < 1e-12;
    }, y.model.applyChangeStrategy = function(e, t, r, n, o, a) {
        var i = e[t], s = y.typeCode(o), c = y.typeCode(i), l = y.NO_VALUE;
        "primitive" === s ? y.model.isSameValue(i, o) || (l = o, ++a.unchanged) : (c !== s || "array" === s && o.length !== i.length) && (l = y.freshContainer(o)), 
        l !== y.NO_VALUE && (e[t] = l, a.changeMap && y.model.setChangedPath(a, n, a.inverse ? "DELETE" : "ADD")), 
        "primitive" !== s && y.model.fetchChangeChildren(e[t], r + 1, n, o, a);
    }, y.model.stepTargetAccess = function(e, t, r, n, o, a) {
        for (var i = n; i < o; ++i) {
            if (e) e[r[i]] !== (e = y.model.traverseWithStrategy(e, r, i, a["ADD" === t ? "resolverSetConfig" : "resolverGetConfig"], r.length - i - 1)) && a.changeMap && y.model.setChangedPath(a, r.slice(0, i + 1), "ADD");
        }
        return {
            root: e,
            last: r[o]
        };
    }, y.model.defaultAccessorConfig = function(e) {
        return (e = e || {}).resolverSetConfig = e.resolverSetConfig || y.model.escapedSetConfig, 
        e.resolverGetConfig = e.resolverGetConfig || y.model.escapedGetConfig, e;
    }, y.model.applyHolderChangeRequest = function(e, t, r) {
        (r = y.model.defaultAccessorConfig(r)).deltaMap = r.changeMap ? {} : null, r.deltas = 0;
        var n, o = t.segs.length, a = 0 === o;
        if (n = a ? {
            root: e,
            last: "model"
        } : (e.model || (e.model = {}, y.model.setChangedPath(r, [], r.inverse ? "DELETE" : "ADD")), 
        y.model.stepTargetAccess(e.model, t.type, t.segs, 0, o - 1, r)), "ADD" === t.type) {
            var i = t.value, s = y.makeArray(t.segs);
            y.model.applyChangeStrategy(n.root, n.last, o - 1, s, i, r, a);
        } else "DELETE" === t.type ? n.root && void 0 !== n.root[n.last] && (delete n.root[n.last], 
        r.changeMap && y.model.setChangedPath(r, t.segs, "DELETE")) : y.fail("Unrecognised change type of " + t.type);
        return r.deltas ? r.deltaMap : null;
    }, y.model.diff = function(e, t, r) {
        r = r || {
            changes: 0,
            unchanged: 0,
            changeMap: {}
        };
        var n, o = y.typeCode(e), a = y.typeCode(t);
        if ("primitive" === o && "primitive" === a) n = y.model.isSameValue(e, t); else if ("primitive" === o ^ "primitive" === a) n = !1; else {
            var i = {
                model: y.copy(e)
            };
            y.model.applyHolderChangeRequest(i, {
                value: t,
                segs: [],
                type: "ADD"
            }, r);
            var s = {
                model: y.copy(t)
            };
            r.inverse = !0, y.model.applyHolderChangeRequest(s, {
                value: e,
                segs: [],
                type: "ADD"
            }, r), n = 0 === r.changes;
        }
        return !1 === n && 0 === r.changes ? (r.changes = 1, r.changeMap = void 0 === t ? "DELETE" : "ADD") : !0 === n && 0 === r.unchanged && (r.unchanged = 1), 
        n;
    }, y.outputMatches = function(r, n, e) {
        y.each(e, function(e, t) {
            r.push(n.concat(t));
        });
    }, y.matchChanges = function(e, t, r, n) {
        for (var o = r.model, a = n.model, i = e, s = [ "model" ], c = !1, l = [], u = 0; u < t.length; ++u) {
            var d = t[u];
            "*" === d ? u === t.length - 1 ? c = !0 : y.fail("Wildcard specification in modelChanged listener is only supported for the final path segment: " + t.join(".")) : (s.push(d), 
            i = y.isPrimitive(i) ? i : i[d], o = o ? o[d] : void 0, a = a ? a[d] : void 0);
        }
        return i && (c ? "DELETE" === i ? y.outputMatches(l, s, a) : "ADD" === i ? y.outputMatches(l, s, o) : y.outputMatches(l, s, i) : l.push(s)), 
        l;
    }, y.storeExternalChange = function(e, t, r, n, o) {
        var a = t.composeSegments.apply(null, r), i = [ t.holder.id, n.listenerId, n.wildcard ? a : "" ].join("|");
        e.externalChanges[i] = {
            listener: n.listener,
            namespace: n.namespace,
            priority: n.priority,
            args: o
        };
    }, y.notifyModelChanges = function(e, t, r, n, o, a, i, s) {
        if (e) for (var c = y.getModelTransactionRec(s, a.id), l = 0; l < e.length; ++l) for (var u = e[l], d = 1 < u.segsArray.length, p = 0; p < u.segsArray.length; ++p) for (var f = y.matchChanges(t, u.segsArray[p], r, n), m = 0; m < f.length; ++m) {
            if (i.destroyed) return;
            var g = f[m];
            u.listener = y.event.resolveListener(u.listener);
            var h = [ d ? r.model : y.model.getSimple(r, g), d ? n.model : y.model.getSimple(n, g), d ? [] : g.slice(1), o, a, i ];
            if (!u.isRelay) {
                if (y.model.diff(h[0], h[1])) continue;
                if (y.isExcludedChangeSource(a, u)) continue;
            }
            c && !u.isRelay && u.transactional ? y.storeExternalChange(c, i, g, u, h) : u.listener.apply(null, h);
        }
    }, y.bindELMethods = function(t) {
        t.parseEL = function(e) {
            return y.model.pathToSegments(e, t.options.resolverSetConfig);
        }, t.composeSegments = function() {
            return t.options.resolverSetConfig.parser.compose.apply(null, arguments);
        };
    }, y.emptyHolder = y.freezeRecursive({
        model: void 0
    }), y.preFireChangeRequest = function(e, t) {
        t.type || (t.type = "ADD"), t.segs = t.segs || e.parseEL(t.path);
    }, y.bindRequestChange = function(a) {
        a.change = function(e, t, r, n) {
            var o = {
                path: e,
                value: t,
                type: r,
                source: n
            };
            a.fireChangeRequest(o);
        };
    }, y.isObjectSimple = function(e) {
        return "[object Object]" === Object.prototype.toString.call(e);
    }, y.mergeChangeSources = function(t, e) {
        y.isObjectSimple(e) ? y.extend(t, e) : y.each(y.makeArray(e), function(e) {
            t[e] = !0;
        });
    }, y.ChangeApplier = function() {}, y.makeHolderChangeApplier = function(i, s) {
        s = y.model.defaultAccessorConfig(s);
        var e = y.allocateGuid(), c = new y.ChangeApplier(), t = y.isComponent(i) ? "ChangeApplier for component " + y.dumpThat(i) : "ChangeApplier with id " + e;
        return r.extend(c, {
            applierId: e,
            holder: i,
            listeners: y.makeEventFirer({
                name: "Internal change listeners for " + t
            }),
            transListeners: y.makeEventFirer({
                name: "External change listeners for " + t
            }),
            options: s,
            modelChanged: {},
            resourceMap: [],
            earlyModelResolved: y.makeEventFirer({
                name: "earlyModelResolved event for " + t
            }),
            preCommit: y.makeEventFirer({
                name: "preCommit event for " + t
            }),
            postCommit: y.makeEventFirer({
                name: "postCommit event for " + t
            })
        }), c.destroy = function() {
            c.preCommit.destroy(), c.postCommit.destroy(), c.destroyed = !0;
        }, c.modelChanged.addListener = function(e, t, r, n) {
            return (e = "string" == typeof e ? {
                path: e
            } : y.copy(e)).listenerId = e.listenerId || y.allocateGuid(), e.namespace = r, e.softNamespace = n, 
            "string" == typeof t && (t = {
                globalName: t
            }), e.listener = t, !1 !== e.transactional && (e.transactional = !0), e.segsArray || (void 0 !== e.path && (e.segs = e.segs || c.parseEL(e.path)), 
            e.segsArray = [ e.segs ]), e.isRelay || (y.parseSourceExclusionSpec(e, e), e.wildcard = y.accumulate(y.transform(e.segsArray, function(e) {
                return y.contains(e, "*");
            }), y.add, 0), e.wildcard && 1 < e.segsArray.length && y.fail("Error in model listener specification ", e, " - you may not supply a wildcard pattern as one of a set of multiple paths to be matched")), 
            c[e.transactional ? "transListeners" : "listeners"].addListener(e), e;
        }, c.modelChanged.removeListener = function(e) {
            c.listeners.removeListener(e), c.transListeners.removeListener(e);
        }, c.fireChangeRequest = function(e) {
            var t = y.findInitModelTransaction(i);
            if (t) t.transaction.fireChangeRequest(e); else {
                var r = c.initiate("local", e.source);
                r.fireChangeRequest(e), r.commit();
            }
        }, c.initiate = function(e, t, r) {
            var n = "relay" === (e = "init" === t ? null : e || "local") || "init" === t, o = {
                instanceId: y.allocateGuid(),
                id: r || y.allocateGuid(),
                changeRecord: {
                    resolverSetConfig: s.resolverSetConfig,
                    resolverGetConfig: s.resolverGetConfig
                },
                reset: function() {
                    o.oldHolder = i, o.newHolder = {
                        model: y.copy(i.model)
                    }, o.changeRecord.changes = 0, o.changeRecord.unchanged = 0, o.changeRecord.changeMap = {};
                },
                commit: function(e) {
                    if (c.preCommit.fire(o, c, e), 0 < o.changeRecord.changes) {
                        var t = {
                            model: i.model
                        };
                        i.model = o.newHolder.model, y.notifyModelChanges(c.transListeners.sortedListeners, o.changeRecord.changeMap, i, t, null, o, c, i);
                    }
                    n || c.postCommit.fire(o, c, e);
                },
                fireChangeRequest: function(e) {
                    y.preFireChangeRequest(c, e), e.transactionId = o.id;
                    var t = y.model.applyHolderChangeRequest(o.newHolder, e, o.changeRecord);
                    y.notifyModelChanges(c.listeners.sortedListeners, t, o.newHolder, i, e, o, c, i);
                },
                hasChangeSource: function(e) {
                    return o.fullSources[e];
                }
            }, a = y.getModelTransactionRec(i, o.id);
            return a && (y.mergeChangeSources(a.sources, t), o.sources = a.sources, o.fullSources = Object.create(a.sources), 
            e && (o.fullSources[e] = !0)), o.reset(), y.bindRequestChange(o), o;
        }, y.bindRequestChange(c), y.bindELMethods(c), c;
    }, y.modelPairToChanges = function(e, t, r) {
        r = r || "";
        var n = {
            changes: 0,
            unchanged: 0,
            changeMap: {}
        };
        y.model.diff(t, e, n);
        var o = [];
        return y.modelPairToChangesImpl(e, y.pathUtil.parseEL(r), n.changeMap, [], o), o;
    }, y.modelPairToChangesImpl = function(n, o, e, a, i) {
        "ADD" === e ? i.push({
            path: o,
            value: n,
            type: "ADD"
        }) : "DELETE" === e ? i.push({
            path: o,
            value: null,
            type: "DELETE"
        }) : y.isPlainObject(e, !0) && y.each(e, function(e, t) {
            var r = a.concat([ t ]);
            "ADD" === e ? i.push({
                path: o.concat(r),
                value: y.get(n, r),
                type: "ADD"
            }) : "DELETE" === e ? i.push({
                path: o.concat(r),
                value: null,
                type: "DELETE"
            }) : y.isPlainObject(e, !0) && y.modelPairToChangesImpl(n, o, e, r, i);
        });
    };
}(jQuery, fluid_3_0_0 = fluid_3_0_0 || {});

var berg = (fluid = fluid || require("infusion")).registerNamespace("berg");

!function() {
    "use strict";
    fluid.defaults("berg.clock", {
        gradeNames: [ "fluid.modelComponent" ],
        freq: 1,
        members: {
            time: 0,
            freq: "{that}.options.freq",
            tickDuration: {
                expander: {
                    funcName: "berg.clock.calcTickDuration",
                    args: "{that}.freq"
                }
            }
        },
        model: {
            isPlaying: !1
        },
        invokers: {
            start: "{that}.events.onStart.fire()",
            tick: "fluid.notImplemented()",
            stop: "{that}.events.onStop.fire()"
        },
        events: {
            onStart: null,
            onTick: null,
            onStop: null
        },
        listeners: {
            "onStart.updateState": {
                changePath: "isPlaying",
                value: !0
            },
            "onStop.updateState": {
                changePath: "isPlaying",
                value: !1
            },
            "onDestroy.stop": "{that}.stop()"
        }
    }), berg.clock.calcTickDuration = function(e) {
        return 1 / e;
    }, fluid.defaults("berg.clock.offline", {
        gradeNames: [ "berg.clock" ],
        invokers: {
            tick: {
                funcName: "berg.clock.offline.tick",
                args: [ "{that}" ]
            }
        }
    }), berg.clock.offline.tick = function(e) {
        e.time = e.time + e.tickDuration, e.events.onTick.fire(e.time, e.freq);
    }, fluid.defaults("berg.clock.realtime", {
        gradeNames: [ "berg.clock" ],
        members: {
            time: "@expand:berg.clock.realtime.now()"
        },
        invokers: {
            tick: {
                funcName: "berg.clock.realtime.tick",
                args: [ "{that}" ]
            }
        }
    }), berg.clock.realtime.now = function() {
        return performance.now() / 1e3;
    }, "undefined" == typeof performance && (berg.clock.realtime.now = function() {
        return Date.now() / 1e3;
    }), berg.clock.realtime.tick = function(e) {
        e.time = berg.clock.realtime.now(), e.events.onTick.fire(e.time, e.freq);
    };
}();

berg = (fluid = fluid || require("infusion")).registerNamespace("berg");

!function() {
    "use strict";
    fluid.registerNamespace("berg"), berg.priorityQueue = function() {
        var c = {
            items: [],
            push: function(e) {
                if (e) {
                    if (void 0 === e.priority) throw new Error("An item without a priority cannot be added to the queue.");
                    c.items.push(e), c.bubbleUp(c.items.length - 1);
                }
            },
            peek: function() {
                return c.items[0];
            },
            pop: function() {
                var e = c.items[0], t = c.items.pop();
                return 0 < c.items.length && (c.items[0] = t, c.sinkDown(0)), e;
            },
            remove: function(e) {
                for (var t = c.items.length, r = 0; r < t; r++) if (c.items[r] === e) {
                    var n = c.items.pop();
                    if (r === t - 1) break;
                    c.items[r] = n, c.bubbleUp(r), c.sinkDown(r);
                    break;
                }
            },
            size: function() {
                return c.items.length;
            },
            clear: function() {
                c.items.length = 0;
            },
            bubbleUp: function(e) {
                for (var t = c.items[e]; 0 < e; ) {
                    var r = e - 1 >> 1, n = c.items[r];
                    if (n.priority <= t.priority) break;
                    c.items[r] = t, c.items[e] = n, e = r;
                }
            },
            sinkDown: function(e) {
                for (var t, r = c.items.length, n = c.items[e]; ;) {
                    var o = 2 * (e + 1), a = o - 1, i = null;
                    if (a < r && (t = c.items[a]).priority < n.priority && (i = a), o < r) {
                        var s = null === i ? n : t;
                        c.items[o].priority < s.priority && (i = o);
                    }
                    if (null === i) break;
                    c.items[e] = c.items[i], c.items[i] = n, e = i;
                }
            }
        };
        return c;
    };
}();

berg = (fluid = fluid || require("infusion")).registerNamespace("berg");

!function() {
    "use strict";
    berg.getGlobalSelf = function() {
        return self;
    }, fluid.defaults("berg.postMessageSender", {
        gradeNames: [ "fluid.component" ],
        members: {
            messageTarget: "@expand:berg.getGlobalSelf()"
        },
        invokers: {
            postMessage: "berg.postMessageSender.postMessage({arguments}.0, {arguments}.1, {that}.messageTarget)"
        }
    }), berg.postMessageSender.postMessage = function(e, t, r) {
        if ("string" != typeof e) throw new Error("Can't post a message without a message type.");
        var n = {
            type: e,
            args: t
        };
        r.postMessage(n);
    }, fluid.defaults("berg.postMessageListener", {
        gradeNames: [ "fluid.component" ],
        members: {
            messageSource: "@expand:berg.getGlobalSelf()"
        },
        events: {
            onError: null
        },
        listeners: {
            onCreate: [ "berg.postMessageListener.bind({that})" ],
            onError: [ {
                namespace: "failOnError",
                funcName: "fluid.fail"
            } ]
        }
    }), berg.postMessageListener.bind = function(o) {
        o.messageSource.addEventListener("message", function(e) {
            var t = e.data;
            if (t.type || o.events.onError.fire("Received a remote message without a type. " + fluid.prettyPrintJSON(t)), 
            "create" !== t.type) {
                var r = o[t.type];
                o.options.invokers[t.type] && r || o.events.onError.fire("Received a message of type " + t.type + ", which did not resolve to a component invoker. Invokers: " + fluid.prettyPrintJSON(o.options.invokers));
                var n = fluid.makeArray(t.args);
                r.apply(null, n);
            }
        }, !1);
    };
}();

berg = (fluid = fluid || require("infusion")).registerNamespace("berg");

!function() {
    "use strict";
    fluid.defaults("berg.scheduler", {
        gradeNames: [ "fluid.modelComponent" ],
        members: {
            queue: "@expand:berg.priorityQueue()",
            lookahead: "@expand:berg.scheduler.calcLookahead({clock})"
        },
        model: {
            timeScale: 1
        },
        components: {
            clock: {
                type: "berg.clock.offline"
            }
        },
        invokers: {
            start: "{that}.events.onStart.fire()",
            stop: "{that}.events.onStop.fire()",
            tick: "berg.scheduler.tick({arguments}.0, {that})",
            schedule: "berg.scheduler.schedule({arguments}.0, {that})",
            once: "berg.scheduler.once({arguments}.0, {arguments}.1, {that})",
            repeat: {
                funcName: "berg.scheduler.repeat",
                args: [ "{arguments}.0", "{arguments}.1", "{arguments}.2", "{arguments}.3", "{that}" ]
            },
            clear: "{that}.queue.remove({arguments}.0)",
            clearAll: "{that}.queue.clear()",
            setTimeScale: {
                changePath: "timeScale",
                value: "{arguments}.0"
            },
            scheduleEvent: {
                funcName: "berg.scheduler.scheduleEvent",
                args: [ "{arguments}.0", "{that}" ]
            },
            invokeCallback: {
                funcName: "berg.scheduler.invokeCallback",
                args: [ "{arguments}.0", "{arguments}.1" ]
            }
        },
        modelListeners: {
            timeScale: {
                funcName: "berg.scheduler.scaleEventTimes",
                args: [ "{that}.queue", "{change}.value" ],
                excludeSource: "init"
            }
        },
        events: {
            onStart: null,
            onStop: null
        },
        listeners: {
            "onStart.startClock": "{clock}.start()",
            "{clock}.events.onTick": {
                func: "{scheduler}.tick"
            },
            "onStop.stopClock": "{clock}.stop()"
        }
    }), berg.scheduler.calcLookahead = function(e) {
        return e.tickDuration / 2;
    }, berg.scheduler.calcPriority = function(e, t, r) {
        return e + t * r;
    }, berg.scheduler.scaleEventTimes = function(e, t) {
        for (var r = 0; r < e.items.length; r++) {
            var n = e.items[r];
            n.priority = berg.scheduler.calcPriority(n.scheduledAt, n.time, t);
        }
    }, berg.scheduler.expandRepeatingEventSpec = function(e, t) {
        "number" != typeof t.time && (t.time = 0), "number" != typeof t.interval && (t.interval = 1 / t.freq), 
        t.end = "number" != typeof t.end ? 1 / 0 : t.end + e;
    }, berg.scheduler.validateEventSpec = function(e) {
        if ("repeat" === e.type && "number" != typeof e.freq && "number" != typeof e.interval) throw new Error("No freq or interval was specified for a repeating event: " + fluid.prettyPrintJSON(e));
        if ("number" != typeof e.time) throw new Error("No time was specified for scheduled event: " + fluid.prettyPrintJSON(e));
    }, berg.scheduler.invokeCallback = function(e, t) {
        t.callback(e, t);
    }, berg.scheduler.evaluateScoreEvent = function(e, t, r) {
        r.invokeCallback(e, t), "repeat" === t.type && t.end > e && (t.priority = berg.scheduler.calcPriority(e, t.interval, r.model.timeScale), 
        r.queue.push(t));
    }, berg.scheduler.expandEventSpec = function(e) {
        e.type || (e.type = "once"), e.id || (e.id = fluid.allocateGuid());
    }, berg.scheduler.scheduleEvent = function(e, t) {
        var r = t.clock.time, n = t.model.timeScale;
        return berg.scheduler.expandEventSpec(e), "repeat" === e.type && berg.scheduler.expandRepeatingEventSpec(r, e), 
        "number" != typeof e.scheduledAt && (e.scheduledAt = r), berg.scheduler.validateEventSpec(e), 
        e.priority = berg.scheduler.calcPriority(r, e.time, n), e.priority <= r ? berg.scheduler.evaluateScoreEvent(r, e, t) : t.queue.push(e), 
        e;
    }, berg.scheduler.scheduleEvents = function(e, t) {
        return e.forEach(function(e) {
            t.scheduleEvent(e);
        }), e;
    }, berg.scheduler.schedule = function(e, t) {
        return fluid.isArrayable(e) ? berg.scheduler.scheduleEvents(e, t) : t.scheduleEvent(e);
    }, berg.scheduler.once = function(e, t, r) {
        var n = {
            type: "once",
            time: e,
            callback: t
        };
        return r.scheduleEvent(n);
    }, berg.scheduler.repeat = function(e, t, r, n, o) {
        var a = {
            type: "repeat",
            freq: e,
            time: r,
            end: n,
            callback: t
        };
        return o.scheduleEvent(a);
    }, berg.scheduler.tick = function(e, t) {
        for (var r = t.queue.peek(); r && r.priority <= e + t.lookahead; ) t.queue.pop(), 
        berg.scheduler.evaluateScoreEvent(e, r, t), r = t.queue.peek();
    };
}();

berg = (fluid = fluid || require("infusion")).registerNamespace("berg");

!function() {
    "use strict";
    fluid.defaults("berg.scheduler.postMessage", {
        gradeNames: [ "berg.postMessageListener", "berg.postMessageSender", "berg.scheduler" ],
        invokers: {
            invokeCallback: {
                funcName: "berg.scheduler.postMessage.post",
                args: [ "invokeCallback", [ "{arguments}.0", "{arguments}.1" ], "{that}" ]
            }
        }
    }), berg.scheduler.postMessage.post = function(e, t, r) {
        r.postMessage(e, t);
    }, fluid.defaults("berg.scheduler.workerProxy", {
        gradeNames: [ "berg.scheduler", "berg.postMessageListener", "berg.postMessageSender" ],
        scriptPath: "../../dist/bergson-all-worker.js",
        remoteSchedulerOptions: {
            components: {
                clock: {
                    type: "berg.clock.setInterval",
                    options: {
                        freq: .01
                    }
                }
            }
        },
        members: {
            eventSpecMap: {},
            worker: "@expand:berg.scheduler.workerProxy.createWorker({that}.options.scriptPath)",
            messageTarget: "{that}.worker",
            messageSource: "{that}.worker"
        },
        components: {
            clock: {
                type: "berg.clock.offline"
            }
        },
        invokers: {
            start: "{that}.postMessage(start)",
            stop: "{that}.postMessage(stop)",
            tick: "fluid.identity()",
            invokeCallback: "berg.scheduler.workerProxy.invokeCallback({arguments}.0, {arguments}.1, {that})",
            scheduleEvent: "berg.scheduler.workerProxy.scheduleEvent({arguments}.0, {that})",
            clear: "{that}.postMessage(clear, {arguments}.0)",
            clearAll: "{that}.postMessage(clearAll)",
            setTimeScale: "{that}.postMessage(setTimeScale, {arguments}.0)"
        },
        listeners: {
            "onCreate.postSchedulerOptions": {
                func: "{that}.postMessage",
                args: [ "create", [ "berg.scheduler.postMessage", "{that}.options.remoteSchedulerOptions" ] ]
            },
            "onDestroy.terminateWorker": {
                this: "{that}.worker",
                method: "terminate"
            }
        }
    }), berg.scheduler.workerProxy.createWorker = function(e) {
        return new Worker(e);
    }, berg.scheduler.workerProxy.invokeCallback = function(e, t, r) {
        var n = r.eventSpecMap[t.id], o = n.callback;
        "function" == typeof o ? o(e, t) : r.events.onError.fire("A callback function was not found for score event: " + fluid.prettyPrintJSON(n));
    }, berg.scheduler.workerProxy.makeTransferrableCopy = function(e) {
        var t = fluid.copy(e);
        return delete t.callback, t;
    }, berg.scheduler.workerProxy.scheduleEvent = function(e, t) {
        berg.scheduler.expandEventSpec(e), t.eventSpecMap[e.id] = e;
        var r = berg.scheduler.workerProxy.makeTransferrableCopy(e);
        t.postMessage("scheduleEvent", r);
    };
}();

berg = (fluid = fluid || require("infusion")).registerNamespace("berg");

!function() {
    "use strict";
    fluid.defaults("berg.clock.raf", {
        gradeNames: [ "berg.clock.realtime" ],
        freq: 60,
        members: {
            requestID: null
        },
        invokers: {
            tick: {
                funcName: "berg.clock.raf.tick",
                args: [ "{that}", "{arguments}.0" ]
            }
        },
        listeners: {
            "onStart.requestNextTick": {
                priority: "after:updateState",
                funcName: "berg.clock.raf.requestNextTick",
                args: [ "{that}" ]
            },
            "onStop.cancelNextTick": {
                priority: "after:updateState",
                funcName: "berg.clock.raf.cancelNextTick",
                args: [ "{that}" ]
            }
        }
    }), berg.clock.raf.requestNextTick = function(e) {
        e.requestID = requestAnimationFrame(e.tick);
    }, berg.clock.raf.tick = function(e, t) {
        berg.clock.raf.requestNextTick(e);
        var r = t / 1e3;
        e.time = r, e.events.onTick.fire(r, e.freq);
    }, berg.clock.raf.cancelNextTick = function(e) {
        cancelAnimationFrame(e.requestID);
    };
}();

berg = (fluid = fluid || require("infusion")).registerNamespace("berg");

!function() {
    "use strict";
    fluid.defaults("berg.clock.setInterval", {
        gradeNames: [ "berg.clock.realtime" ],
        freq: 10,
        members: {
            intervalID: null
        },
        listeners: {
            "onStart.setInterval": {
                priority: "after:updateState",
                funcName: "berg.clock.setInterval.start",
                args: [ "{that}" ]
            },
            "onStop.clearInterval": {
                priority: "after:updateState",
                funcName: "berg.clock.setInterval.stop",
                args: [ "{that}" ]
            }
        }
    }), berg.clock.setInterval.start = function(e) {
        e.intervalID = setInterval(e.tick, 1e3 / e.freq);
    }, berg.clock.setInterval.stop = function(e) {
        clearInterval(e.intervalID);
    };
}();

berg = (fluid = fluid || require("infusion")).registerNamespace("berg");

!function() {
    "use strict";
    fluid.defaults("berg.clock.logger", {
        gradeNames: [ "fluid.component" ],
        numTicksToLog: 72e3,
        members: {
            tickCounter: 0,
            lastTickTime: null,
            interval: 0,
            intervalLog: "@expand:berg.clock.logger.initLog({that}.options.numTicksToLog)"
        },
        invokers: {
            log: "berg.clock.logger.log({that}, {clock})"
        },
        listeners: {
            "{clock}.events.onTick": [ "{that}.log()" ]
        }
    }), berg.clock.logger.initLog = function(e) {
        return new Float32Array(e);
    }, berg.clock.logger.log = function(e, t) {
        null !== e.lastTickTime ? e.tickCounter < e.options.numTicksToLog && (e.tickCounter++, 
        e.interval = t.time - e.lastTickTime, e.lastTickTime = t.time, e.intervalLog[e.tickCounter] = e.interval) : e.lastTickTime = t.time;
    };
}();

berg = (fluid = fluid || require("infusion")).registerNamespace("berg");

!function() {
    "use strict";
    berg.worker = function(e) {
        var t, r, n = typeof e;
        if ("function" == n) e = "(" + e.toString() + ")();"; else if ("string" != n) throw new Error("A berg.worker must be initialized with a String or a Function.");
        return t = window.Blob ? (r = new Blob([ e ], {
            type: "text/javascript"
        }), (window.URL || window.webkitURL).createObjectURL(r)) : "data:text/javascript;base64," + window.btoa(e), 
        new Worker(t);
    }, fluid.defaults("berg.clock.workerSetInterval", {
        gradeNames: [ "berg.clock.realtime", "berg.postMessageListener", "berg.postMessageSender" ],
        freq: 10,
        members: {
            worker: "@expand:berg.clock.workerSetInterval.createWorker()",
            messageTarget: "{that}.worker",
            messageSource: "{that}.worker"
        },
        listeners: {
            "onStart.postStart": {
                priority: "after:updateState",
                func: "{that}.postMessage",
                args: [ "start", [ {
                    freq: "{that}.options.freq"
                } ] ]
            },
            "onStop.postStop": {
                priority: "after:updateState",
                func: "{that}.postMessage",
                args: [ "stop" ]
            },
            "onDestroy.terminateWorker": {
                this: "{that}.worker",
                method: "terminate"
            }
        }
    }), berg.clock.workerSetInterval.createWorker = function() {
        return berg.worker(berg.clock.workerSetInterval.workerImpl);
    }, berg.clock.workerSetInterval.workerImpl = function() {
        var t = {
            workerClock: function(e) {
                var t = {
                    options: e || {},
                    intervalID: null,
                    start: function() {
                        t.intervalID = setInterval(t.tick, 1e3 / t.options.freq);
                    },
                    tick: function() {
                        self.postMessage({
                            type: "tick"
                        });
                    },
                    stop: function() {
                        clearInterval(t.intervalID);
                    }
                };
                return t;
            }
        };
        self.addEventListener("message", function(e) {
            "start" === e.data.type ? (t.clock = t.workerClock({
                freq: e.data.args[0].freq
            }), t.clock.start()) : "stop" === e.data.type && t.clock && t.clock.stop();
        }, !1);
    };
}();

berg = (fluid = fluid || require("infusion")).registerNamespace("berg");

!function() {
    "use strict";
    fluid.defaults("berg.clock.audioContext", {
        gradeNames: [ "berg.clock.realtime" ],
        blockSize: 256,
        mergePolicy: {
            "members.context": "noexpand"
        },
        members: {
            context: "@expand:berg.clock.audioContext.createContext()",
            freq: "@expand:berg.clock.audioContext.calcFreq({that}.context, {that}.options.blockSize)",
            time: "@expand:berg.clock.audioContext.now({that}.context)"
        },
        invokers: {
            tick: {
                funcName: "berg.clock.audioContext.tick",
                args: [ "{that}" ]
            }
        }
    }), berg.clock.audioContext.createContext = function() {
        return new (window.AudioContext || window.webkitAudioContext)();
    }, berg.clock.audioContext.calcFreq = function(e, t) {
        return e.sampleRate / t;
    }, berg.clock.audioContext.now = function(e) {
        return e.currentTime;
    }, berg.clock.audioContext.tick = function(e) {
        e.time = e.context.currentTime, e.events.onTick.fire(e.time, e.freq);
    }, fluid.defaults("berg.clock.autoAudioContext", {
        gradeNames: [ "berg.clock.audioContext" ],
        mergePolicy: {
            "members.scriptNode": "noexpand"
        },
        members: {
            scriptNode: {
                expander: {
                    funcName: "berg.clock.autoAudioContext.createScriptNode",
                    args: [ "{that}.context", "{that}.options.blockSize", "{that}.tick" ]
                }
            }
        },
        listeners: {
            "onStart.startAudioContext": {
                priority: "after:updateState",
                funcName: "berg.clock.autoAudioContext.start",
                args: [ "{that}.context", "{that}.scriptNode" ]
            },
            "onStop.stopAudioContext": {
                priority: "after:updateState",
                funcName: "berg.clock.autoAudioContext.stop",
                args: [ "{that}.context", "{that}.scriptNode" ]
            }
        }
    }), berg.clock.autoAudioContext.createScriptNode = function(e, t, r) {
        var n = e.createScriptProcessor(t, 1, 1);
        return n.onaudioprocess = r, n;
    }, berg.clock.autoAudioContext.start = function(e, t) {
        t.connect(e.destination), e.resume();
    }, berg.clock.autoAudioContext.stop = function(e, t) {
        t.disconnect(e.destination), t.onaudioprocess = void 0;
    };
}();