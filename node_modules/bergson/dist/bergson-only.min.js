/*! Bergson 0.14.1, Copyright 2019 Colin Clark | github.com/colinbdclark/bergson */


var berg = (fluid = fluid || require("infusion")).registerNamespace("berg");

!function() {
    "use strict";
    fluid.defaults("berg.clock", {
        gradeNames: [ "fluid.modelComponent" ],
        freq: 1,
        members: {
            time: 0,
            freq: "{that}.options.freq",
            tickDuration: {
                expander: {
                    funcName: "berg.clock.calcTickDuration",
                    args: "{that}.freq"
                }
            }
        },
        model: {
            isPlaying: !1
        },
        invokers: {
            start: "{that}.events.onStart.fire()",
            tick: "fluid.notImplemented()",
            stop: "{that}.events.onStop.fire()"
        },
        events: {
            onStart: null,
            onTick: null,
            onStop: null
        },
        listeners: {
            "onStart.updateState": {
                changePath: "isPlaying",
                value: !0
            },
            "onStop.updateState": {
                changePath: "isPlaying",
                value: !1
            },
            "onDestroy.stop": "{that}.stop()"
        }
    }), berg.clock.calcTickDuration = function(e) {
        return 1 / e;
    }, fluid.defaults("berg.clock.offline", {
        gradeNames: [ "berg.clock" ],
        invokers: {
            tick: {
                funcName: "berg.clock.offline.tick",
                args: [ "{that}" ]
            }
        }
    }), berg.clock.offline.tick = function(e) {
        e.time = e.time + e.tickDuration, e.events.onTick.fire(e.time, e.freq);
    }, fluid.defaults("berg.clock.realtime", {
        gradeNames: [ "berg.clock" ],
        members: {
            time: "@expand:berg.clock.realtime.now()"
        },
        invokers: {
            tick: {
                funcName: "berg.clock.realtime.tick",
                args: [ "{that}" ]
            }
        }
    }), berg.clock.realtime.now = function() {
        return performance.now() / 1e3;
    }, "undefined" == typeof performance && (berg.clock.realtime.now = function() {
        return Date.now() / 1e3;
    }), berg.clock.realtime.tick = function(e) {
        e.time = berg.clock.realtime.now(), e.events.onTick.fire(e.time, e.freq);
    };
}();

berg = (fluid = fluid || require("infusion")).registerNamespace("berg");

!function() {
    "use strict";
    fluid.registerNamespace("berg"), berg.priorityQueue = function() {
        var s = {
            items: [],
            push: function(e) {
                if (e) {
                    if (void 0 === e.priority) throw new Error("An item without a priority cannot be added to the queue.");
                    s.items.push(e), s.bubbleUp(s.items.length - 1);
                }
            },
            peek: function() {
                return s.items[0];
            },
            pop: function() {
                var e = s.items[0], t = s.items.pop();
                return 0 < s.items.length && (s.items[0] = t, s.sinkDown(0)), e;
            },
            remove: function(e) {
                for (var t = s.items.length, r = 0; r < t; r++) if (s.items[r] === e) {
                    var o = s.items.pop();
                    if (r === t - 1) break;
                    s.items[r] = o, s.bubbleUp(r), s.sinkDown(r);
                    break;
                }
            },
            size: function() {
                return s.items.length;
            },
            clear: function() {
                s.items.length = 0;
            },
            bubbleUp: function(e) {
                for (var t = s.items[e]; 0 < e; ) {
                    var r = e - 1 >> 1, o = s.items[r];
                    if (o.priority <= t.priority) break;
                    s.items[r] = t, s.items[e] = o, e = r;
                }
            },
            sinkDown: function(e) {
                for (var t, r = s.items.length, o = s.items[e]; ;) {
                    var n = 2 * (e + 1), a = n - 1, i = null;
                    if (a < r && (t = s.items[a]).priority < o.priority && (i = a), n < r) {
                        var c = null === i ? o : t;
                        s.items[n].priority < c.priority && (i = n);
                    }
                    if (null === i) break;
                    s.items[e] = s.items[i], s.items[i] = o, e = i;
                }
            }
        };
        return s;
    };
}();

berg = (fluid = fluid || require("infusion")).registerNamespace("berg");

!function() {
    "use strict";
    berg.getGlobalSelf = function() {
        return self;
    }, fluid.defaults("berg.postMessageSender", {
        gradeNames: [ "fluid.component" ],
        members: {
            messageTarget: "@expand:berg.getGlobalSelf()"
        },
        invokers: {
            postMessage: "berg.postMessageSender.postMessage({arguments}.0, {arguments}.1, {that}.messageTarget)"
        }
    }), berg.postMessageSender.postMessage = function(e, t, r) {
        if ("string" != typeof e) throw new Error("Can't post a message without a message type.");
        var o = {
            type: e,
            args: t
        };
        r.postMessage(o);
    }, fluid.defaults("berg.postMessageListener", {
        gradeNames: [ "fluid.component" ],
        members: {
            messageSource: "@expand:berg.getGlobalSelf()"
        },
        events: {
            onError: null
        },
        listeners: {
            onCreate: [ "berg.postMessageListener.bind({that})" ],
            onError: [ {
                namespace: "failOnError",
                funcName: "fluid.fail"
            } ]
        }
    }), berg.postMessageListener.bind = function(n) {
        n.messageSource.addEventListener("message", function(e) {
            var t = e.data;
            if (t.type || n.events.onError.fire("Received a remote message without a type. " + fluid.prettyPrintJSON(t)), 
            "create" !== t.type) {
                var r = n[t.type];
                n.options.invokers[t.type] && r || n.events.onError.fire("Received a message of type " + t.type + ", which did not resolve to a component invoker. Invokers: " + fluid.prettyPrintJSON(n.options.invokers));
                var o = fluid.makeArray(t.args);
                r.apply(null, o);
            }
        }, !1);
    };
}();

berg = (fluid = fluid || require("infusion")).registerNamespace("berg");

!function() {
    "use strict";
    fluid.defaults("berg.scheduler", {
        gradeNames: [ "fluid.modelComponent" ],
        members: {
            queue: "@expand:berg.priorityQueue()",
            lookahead: "@expand:berg.scheduler.calcLookahead({clock})"
        },
        model: {
            timeScale: 1
        },
        components: {
            clock: {
                type: "berg.clock.offline"
            }
        },
        invokers: {
            start: "{that}.events.onStart.fire()",
            stop: "{that}.events.onStop.fire()",
            tick: "berg.scheduler.tick({arguments}.0, {that})",
            schedule: "berg.scheduler.schedule({arguments}.0, {that})",
            once: "berg.scheduler.once({arguments}.0, {arguments}.1, {that})",
            repeat: {
                funcName: "berg.scheduler.repeat",
                args: [ "{arguments}.0", "{arguments}.1", "{arguments}.2", "{arguments}.3", "{that}" ]
            },
            clear: "{that}.queue.remove({arguments}.0)",
            clearAll: "{that}.queue.clear()",
            setTimeScale: {
                changePath: "timeScale",
                value: "{arguments}.0"
            },
            scheduleEvent: {
                funcName: "berg.scheduler.scheduleEvent",
                args: [ "{arguments}.0", "{that}" ]
            },
            invokeCallback: {
                funcName: "berg.scheduler.invokeCallback",
                args: [ "{arguments}.0", "{arguments}.1" ]
            }
        },
        modelListeners: {
            timeScale: {
                funcName: "berg.scheduler.scaleEventTimes",
                args: [ "{that}.queue", "{change}.value" ],
                excludeSource: "init"
            }
        },
        events: {
            onStart: null,
            onStop: null
        },
        listeners: {
            "onStart.startClock": "{clock}.start()",
            "{clock}.events.onTick": {
                func: "{scheduler}.tick"
            },
            "onStop.stopClock": "{clock}.stop()"
        }
    }), berg.scheduler.calcLookahead = function(e) {
        return e.tickDuration / 2;
    }, berg.scheduler.calcPriority = function(e, t, r) {
        return e + t * r;
    }, berg.scheduler.scaleEventTimes = function(e, t) {
        for (var r = 0; r < e.items.length; r++) {
            var o = e.items[r];
            o.priority = berg.scheduler.calcPriority(o.scheduledAt, o.time, t);
        }
    }, berg.scheduler.expandRepeatingEventSpec = function(e, t) {
        "number" != typeof t.time && (t.time = 0), "number" != typeof t.interval && (t.interval = 1 / t.freq), 
        t.end = "number" != typeof t.end ? 1 / 0 : t.end + e;
    }, berg.scheduler.validateEventSpec = function(e) {
        if ("repeat" === e.type && "number" != typeof e.freq && "number" != typeof e.interval) throw new Error("No freq or interval was specified for a repeating event: " + fluid.prettyPrintJSON(e));
        if ("number" != typeof e.time) throw new Error("No time was specified for scheduled event: " + fluid.prettyPrintJSON(e));
    }, berg.scheduler.invokeCallback = function(e, t) {
        t.callback(e, t);
    }, berg.scheduler.evaluateScoreEvent = function(e, t, r) {
        r.invokeCallback(e, t), "repeat" === t.type && t.end > e && (t.priority = berg.scheduler.calcPriority(e, t.interval, r.model.timeScale), 
        r.queue.push(t));
    }, berg.scheduler.expandEventSpec = function(e) {
        e.type || (e.type = "once"), e.id || (e.id = fluid.allocateGuid());
    }, berg.scheduler.scheduleEvent = function(e, t) {
        var r = t.clock.time, o = t.model.timeScale;
        return berg.scheduler.expandEventSpec(e), "repeat" === e.type && berg.scheduler.expandRepeatingEventSpec(r, e), 
        "number" != typeof e.scheduledAt && (e.scheduledAt = r), berg.scheduler.validateEventSpec(e), 
        e.priority = berg.scheduler.calcPriority(r, e.time, o), e.priority <= r ? berg.scheduler.evaluateScoreEvent(r, e, t) : t.queue.push(e), 
        e;
    }, berg.scheduler.scheduleEvents = function(e, t) {
        return e.forEach(function(e) {
            t.scheduleEvent(e);
        }), e;
    }, berg.scheduler.schedule = function(e, t) {
        return fluid.isArrayable(e) ? berg.scheduler.scheduleEvents(e, t) : t.scheduleEvent(e);
    }, berg.scheduler.once = function(e, t, r) {
        var o = {
            type: "once",
            time: e,
            callback: t
        };
        return r.scheduleEvent(o);
    }, berg.scheduler.repeat = function(e, t, r, o, n) {
        var a = {
            type: "repeat",
            freq: e,
            time: r,
            end: o,
            callback: t
        };
        return n.scheduleEvent(a);
    }, berg.scheduler.tick = function(e, t) {
        for (var r = t.queue.peek(); r && r.priority <= e + t.lookahead; ) t.queue.pop(), 
        berg.scheduler.evaluateScoreEvent(e, r, t), r = t.queue.peek();
    };
}();

berg = (fluid = fluid || require("infusion")).registerNamespace("berg");

!function() {
    "use strict";
    fluid.defaults("berg.scheduler.postMessage", {
        gradeNames: [ "berg.postMessageListener", "berg.postMessageSender", "berg.scheduler" ],
        invokers: {
            invokeCallback: {
                funcName: "berg.scheduler.postMessage.post",
                args: [ "invokeCallback", [ "{arguments}.0", "{arguments}.1" ], "{that}" ]
            }
        }
    }), berg.scheduler.postMessage.post = function(e, t, r) {
        r.postMessage(e, t);
    }, fluid.defaults("berg.scheduler.workerProxy", {
        gradeNames: [ "berg.scheduler", "berg.postMessageListener", "berg.postMessageSender" ],
        scriptPath: "../../dist/bergson-all-worker.js",
        remoteSchedulerOptions: {
            components: {
                clock: {
                    type: "berg.clock.setInterval",
                    options: {
                        freq: .01
                    }
                }
            }
        },
        members: {
            eventSpecMap: {},
            worker: "@expand:berg.scheduler.workerProxy.createWorker({that}.options.scriptPath)",
            messageTarget: "{that}.worker",
            messageSource: "{that}.worker"
        },
        components: {
            clock: {
                type: "berg.clock.offline"
            }
        },
        invokers: {
            start: "{that}.postMessage(start)",
            stop: "{that}.postMessage(stop)",
            tick: "fluid.identity()",
            invokeCallback: "berg.scheduler.workerProxy.invokeCallback({arguments}.0, {arguments}.1, {that})",
            scheduleEvent: "berg.scheduler.workerProxy.scheduleEvent({arguments}.0, {that})",
            clear: "{that}.postMessage(clear, {arguments}.0)",
            clearAll: "{that}.postMessage(clearAll)",
            setTimeScale: "{that}.postMessage(setTimeScale, {arguments}.0)"
        },
        listeners: {
            "onCreate.postSchedulerOptions": {
                func: "{that}.postMessage",
                args: [ "create", [ "berg.scheduler.postMessage", "{that}.options.remoteSchedulerOptions" ] ]
            },
            "onDestroy.terminateWorker": {
                this: "{that}.worker",
                method: "terminate"
            }
        }
    }), berg.scheduler.workerProxy.createWorker = function(e) {
        return new Worker(e);
    }, berg.scheduler.workerProxy.invokeCallback = function(e, t, r) {
        var o = r.eventSpecMap[t.id], n = o.callback;
        "function" == typeof n ? n(e, t) : r.events.onError.fire("A callback function was not found for score event: " + fluid.prettyPrintJSON(o));
    }, berg.scheduler.workerProxy.makeTransferrableCopy = function(e) {
        var t = fluid.copy(e);
        return delete t.callback, t;
    }, berg.scheduler.workerProxy.scheduleEvent = function(e, t) {
        berg.scheduler.expandEventSpec(e), t.eventSpecMap[e.id] = e;
        var r = berg.scheduler.workerProxy.makeTransferrableCopy(e);
        t.postMessage("scheduleEvent", r);
    };
}();

berg = (fluid = fluid || require("infusion")).registerNamespace("berg");

!function() {
    "use strict";
    fluid.defaults("berg.clock.raf", {
        gradeNames: [ "berg.clock.realtime" ],
        freq: 60,
        members: {
            requestID: null
        },
        invokers: {
            tick: {
                funcName: "berg.clock.raf.tick",
                args: [ "{that}", "{arguments}.0" ]
            }
        },
        listeners: {
            "onStart.requestNextTick": {
                priority: "after:updateState",
                funcName: "berg.clock.raf.requestNextTick",
                args: [ "{that}" ]
            },
            "onStop.cancelNextTick": {
                priority: "after:updateState",
                funcName: "berg.clock.raf.cancelNextTick",
                args: [ "{that}" ]
            }
        }
    }), berg.clock.raf.requestNextTick = function(e) {
        e.requestID = requestAnimationFrame(e.tick);
    }, berg.clock.raf.tick = function(e, t) {
        berg.clock.raf.requestNextTick(e);
        var r = t / 1e3;
        e.time = r, e.events.onTick.fire(r, e.freq);
    }, berg.clock.raf.cancelNextTick = function(e) {
        cancelAnimationFrame(e.requestID);
    };
}();

berg = (fluid = fluid || require("infusion")).registerNamespace("berg");

!function() {
    "use strict";
    fluid.defaults("berg.clock.setInterval", {
        gradeNames: [ "berg.clock.realtime" ],
        freq: 10,
        members: {
            intervalID: null
        },
        listeners: {
            "onStart.setInterval": {
                priority: "after:updateState",
                funcName: "berg.clock.setInterval.start",
                args: [ "{that}" ]
            },
            "onStop.clearInterval": {
                priority: "after:updateState",
                funcName: "berg.clock.setInterval.stop",
                args: [ "{that}" ]
            }
        }
    }), berg.clock.setInterval.start = function(e) {
        e.intervalID = setInterval(e.tick, 1e3 / e.freq);
    }, berg.clock.setInterval.stop = function(e) {
        clearInterval(e.intervalID);
    };
}();

berg = (fluid = fluid || require("infusion")).registerNamespace("berg");

!function() {
    "use strict";
    fluid.defaults("berg.clock.logger", {
        gradeNames: [ "fluid.component" ],
        numTicksToLog: 72e3,
        members: {
            tickCounter: 0,
            lastTickTime: null,
            interval: 0,
            intervalLog: "@expand:berg.clock.logger.initLog({that}.options.numTicksToLog)"
        },
        invokers: {
            log: "berg.clock.logger.log({that}, {clock})"
        },
        listeners: {
            "{clock}.events.onTick": [ "{that}.log()" ]
        }
    }), berg.clock.logger.initLog = function(e) {
        return new Float32Array(e);
    }, berg.clock.logger.log = function(e, t) {
        null !== e.lastTickTime ? e.tickCounter < e.options.numTicksToLog && (e.tickCounter++, 
        e.interval = t.time - e.lastTickTime, e.lastTickTime = t.time, e.intervalLog[e.tickCounter] = e.interval) : e.lastTickTime = t.time;
    };
}();

berg = (fluid = fluid || require("infusion")).registerNamespace("berg");

!function() {
    "use strict";
    berg.worker = function(e) {
        var t, r, o = typeof e;
        if ("function" == o) e = "(" + e.toString() + ")();"; else if ("string" != o) throw new Error("A berg.worker must be initialized with a String or a Function.");
        return t = window.Blob ? (r = new Blob([ e ], {
            type: "text/javascript"
        }), (window.URL || window.webkitURL).createObjectURL(r)) : "data:text/javascript;base64," + window.btoa(e), 
        new Worker(t);
    }, fluid.defaults("berg.clock.workerSetInterval", {
        gradeNames: [ "berg.clock.realtime", "berg.postMessageListener", "berg.postMessageSender" ],
        freq: 10,
        members: {
            worker: "@expand:berg.clock.workerSetInterval.createWorker()",
            messageTarget: "{that}.worker",
            messageSource: "{that}.worker"
        },
        listeners: {
            "onStart.postStart": {
                priority: "after:updateState",
                func: "{that}.postMessage",
                args: [ "start", [ {
                    freq: "{that}.options.freq"
                } ] ]
            },
            "onStop.postStop": {
                priority: "after:updateState",
                func: "{that}.postMessage",
                args: [ "stop" ]
            },
            "onDestroy.terminateWorker": {
                this: "{that}.worker",
                method: "terminate"
            }
        }
    }), berg.clock.workerSetInterval.createWorker = function() {
        return berg.worker(berg.clock.workerSetInterval.workerImpl);
    }, berg.clock.workerSetInterval.workerImpl = function() {
        var t = {
            workerClock: function(e) {
                var t = {
                    options: e || {},
                    intervalID: null,
                    start: function() {
                        t.intervalID = setInterval(t.tick, 1e3 / t.options.freq);
                    },
                    tick: function() {
                        self.postMessage({
                            type: "tick"
                        });
                    },
                    stop: function() {
                        clearInterval(t.intervalID);
                    }
                };
                return t;
            }
        };
        self.addEventListener("message", function(e) {
            "start" === e.data.type ? (t.clock = t.workerClock({
                freq: e.data.args[0].freq
            }), t.clock.start()) : "stop" === e.data.type && t.clock && t.clock.stop();
        }, !1);
    };
}();

var fluid;

berg = (fluid = fluid || require("infusion")).registerNamespace("berg");

!function() {
    "use strict";
    fluid.defaults("berg.clock.audioContext", {
        gradeNames: [ "berg.clock.realtime" ],
        blockSize: 256,
        mergePolicy: {
            "members.context": "noexpand"
        },
        members: {
            context: "@expand:berg.clock.audioContext.createContext()",
            freq: "@expand:berg.clock.audioContext.calcFreq({that}.context, {that}.options.blockSize)",
            time: "@expand:berg.clock.audioContext.now({that}.context)"
        },
        invokers: {
            tick: {
                funcName: "berg.clock.audioContext.tick",
                args: [ "{that}" ]
            }
        }
    }), berg.clock.audioContext.createContext = function() {
        return new (window.AudioContext || window.webkitAudioContext)();
    }, berg.clock.audioContext.calcFreq = function(e, t) {
        return e.sampleRate / t;
    }, berg.clock.audioContext.now = function(e) {
        return e.currentTime;
    }, berg.clock.audioContext.tick = function(e) {
        e.time = e.context.currentTime, e.events.onTick.fire(e.time, e.freq);
    }, fluid.defaults("berg.clock.autoAudioContext", {
        gradeNames: [ "berg.clock.audioContext" ],
        mergePolicy: {
            "members.scriptNode": "noexpand"
        },
        members: {
            scriptNode: {
                expander: {
                    funcName: "berg.clock.autoAudioContext.createScriptNode",
                    args: [ "{that}.context", "{that}.options.blockSize", "{that}.tick" ]
                }
            }
        },
        listeners: {
            "onStart.startAudioContext": {
                priority: "after:updateState",
                funcName: "berg.clock.autoAudioContext.start",
                args: [ "{that}.context", "{that}.scriptNode" ]
            },
            "onStop.stopAudioContext": {
                priority: "after:updateState",
                funcName: "berg.clock.autoAudioContext.stop",
                args: [ "{that}.context", "{that}.scriptNode" ]
            }
        }
    }), berg.clock.autoAudioContext.createScriptNode = function(e, t, r) {
        var o = e.createScriptProcessor(t, 1, 1);
        return o.onaudioprocess = r, o;
    }, berg.clock.autoAudioContext.start = function(e, t) {
        t.connect(e.destination), e.resume();
    }, berg.clock.autoAudioContext.stop = function(e, t) {
        t.disconnect(e.destination), t.onaudioprocess = void 0;
    };
}();