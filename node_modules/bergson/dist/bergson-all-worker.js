/*! Bergson 0.14.1, Copyright 2019 Colin Clark | github.com/colinbdclark/bergson */

/*
 * Definitions in this file taken from:
 *
 * jQuery JavaScript Library v1.6.1
 * http://jquery.com/
 *
 * This implementation is only intended to be used in contexts where the Fluid Infusion framework
 * is required to be used without a functioning DOM being available (node.js or other standalone contexts).
 * It includes the minimum definitions taken from jQuery required to operate the core of Fluid.js
 * without FluidView.js. Consult http://issues.fluidproject.org/browse/FLUID-4568 for more details.
 *
 * Copyright 2011, John Resig
 * Copyright The Infusion copyright holders
 * See the AUTHORS.md file at the top-level directory of this distribution and at
 * https://github.com/fluid-project/infusion/raw/master/AUTHORS.md.
 *
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 * Date: Thu May 12 15:04:36 2011 -0400
 */

/* global jQuery:true, global */
/* exported jQuery */

var fluid_3_0_0 = fluid_3_0_0 || {};
var fluid = fluid || fluid_3_0_0;

(function (fluid) {
    "use strict";

    // Save a reference to some core methods
    var toString = Object.prototype.toString;
    var hasOwn = Object.prototype.hasOwnProperty;
    var globalScope = typeof window !== "undefined" ? window :
        typeof self !== "undefined" ? self : global;
    // Map over jQuery in case of overwrite
    var _jQuery = globalScope.jQuery;
    // Map over the $ in case of overwrite
    var _$ = globalScope.$;

    var jQuery = fluid.jQueryStandalone = {

        // The current version of jQuery being used
        jquery: "1.6.1-fluidStandalone",

        noConflict: function (deep) {
            if (globalScope.$ === jQuery) {
                globalScope.$ = _$;
            }
            if (deep && globalScope.jQuery === jQuery) {
                globalScope.jQuery = _jQuery;
            }
            return jQuery;
        },

        isArray: Array.isArray || function (obj) {
            return toString.call(obj) === "[object Array]";
        },

        // A crude way of determining if an object is a window
        isWindow: function (obj) {
            return obj && typeof obj === "object" && "setInterval" in obj;
        },

        isPlainObject: function (obj) {
            // Must be an Object.
            // Because of IE, we also have to check the presence of the constructor property.
            // Make sure that DOM nodes and window objects don't pass through, as well
            if ( !obj || toString.call(obj) !== "[object Object]" || obj.nodeType || jQuery.isWindow( obj ) ) {
                return false;
            }

            // Not own constructor property must be Object
            if ( obj.constructor &&
                !hasOwn.call(obj, "constructor") &&
                !hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
                return false;
            }
            // Own properties are enumerated firstly, so to speed up,
            // if last one is own, then all properties are own.
            // TODO: Isn't this enormously expensive?
            var key;
            for (key in obj) {} // eslint-disable-line no-empty
            return key === undefined || hasOwn.call( obj, key );
        },

        trim: function (str) {
            return str.trim();
        },

        isEmptyObject: function (obj) {
            for ( var name in obj ) { // eslint-disable-line no-unused-vars
                return false;
            }
            return true;
        },

        extend: function () {
            var options,
                target = arguments[0] || {},
                i = 1,
                length = arguments.length,
                deep = false;

            // Handle a deep copy situation
            if (typeof target === "boolean") {
                deep = target;
                target = arguments[1] || {};
                // skip the boolean and the target
                i = 2;
            }

            // Handle case when target is a string or something (possible in deep copy)
            if (typeof target !== "object" && typeof(target) !== "function") {
                target = {};
            }

            for ( ; i < length; i++ ) {
                // Only deal with non-null/undefined values
                if ( (options = arguments[ i ]) !== null ) {
                    // Extend the base object
                    for (var name in options) {
                        var src = target[ name ];
                        var copy = options[ name ];

                        // Prevent never-ending loop
                        if ( target === copy ) {
                            continue;
                        }
                        var copyIsArray, clone;
                        // Recurse if we're merging plain objects or arrays
                        if (deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy))) ) {
                            if (copyIsArray) {
                                copyIsArray = false;
                                clone = src && jQuery.isArray(src) ? src : [];
                            } else {
                                clone = src && jQuery.isPlainObject(src) ? src : {};
                            }
                            // Never move original objects, clone them
                            target[name] = jQuery.extend( deep, clone, copy );
                        } else if (copy !== undefined) {
                            // Don't bring in undefined values
                            target[name] = copy;
                        }
                    }
                }
            }
            return target;
        }
    };

})(fluid_3_0_0);

var jQuery = fluid.jQueryStandalone;
;/*!
 * Fluid Infusion v3.0.0
 *
 * Infusion is distributed under the Educational Community License 2.0 and new BSD licenses:
 * http://wiki.fluidproject.org/display/fluid/Fluid+Licensing
 *
 * Copyright The Infusion copyright holders
 * See the AUTHORS.md file at the top-level directory of this distribution and at
 * https://github.com/fluid-project/infusion/raw/master/AUTHORS.md
 */
/*
Copyright The Infusion copyright holders
See the AUTHORS.md file at the top-level directory of this distribution and at
https://github.com/fluid-project/infusion/raw/master/AUTHORS.md.

Licensed under the Educational Community License (ECL), Version 2.0 or the New
BSD license. You may not use this file except in compliance with one these
Licenses.

You may obtain a copy of the ECL 2.0 License and BSD License at
https://github.com/fluid-project/infusion/raw/master/Infusion-LICENSE.txt

Includes code from Underscore.js 1.4.3
http://underscorejs.org
(c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.
Underscore may be freely distributed under the MIT license.
*/

/* global console */

var fluid_3_0_0 = fluid_3_0_0 || {};
var fluid = fluid || fluid_3_0_0;

(function ($, fluid) {
    "use strict";

    fluid.version = "Infusion 3.0.0";

    // Export this for use in environments like node.js, where it is useful for
    // configuring stack trace behaviour
    fluid.Error = Error;

    fluid.environment = {
        fluid: fluid
    };

    fluid.global = fluid.global || typeof window !== "undefined" ?
        window : typeof self !== "undefined" ? self : {};

    // A standard utility to schedule the invocation of a function after the current
    // stack returns. On browsers this defaults to setTimeout(func, 1) but in
    // other environments can be customised - e.g. to process.nextTick in node.js
    // In future, this could be optimised in the browser to not dispatch into the event queue
    fluid.invokeLater = function (func) {
        return setTimeout(func, 1);
    };

    // The following flag defeats all logging/tracing activities in the most performance-critical parts of the framework.
    // This should really be performed by a build-time step which eliminates calls to pushActivity/popActivity and fluid.log.
    fluid.defeatLogging = true;

    // This flag enables the accumulating of all "activity" records generated by pushActivity into a running trace, rather
    // than removing them from the stack record permanently when receiving popActivity. This trace will be consumed by
    // visual debugging tools.
    fluid.activityTracing = false;
    fluid.activityTrace = [];

    var activityParser = /(%\w+)/g;

    fluid.renderActivityArgument = function (arg) {
        if (fluid.isComponent(arg)) {
            return fluid.dumpComponentAndPath(arg);
        } else {
            return arg;
        }
    };

    // Renders a single activity element in a form suitable to be sent to a modern browser's console
    // unsupported, non-API function
    fluid.renderOneActivity = function (activity, nowhile) {
        var togo = nowhile === true ? [] : ["    while "];
        var message = activity.message;
        var index = activityParser.lastIndex = 0;
        while (true) {
            var match = activityParser.exec(message);
            if (match) {
                var key = match[1].substring(1);
                togo.push(message.substring(index, match.index));
                togo.push(fluid.renderActivityArgument(activity.args[key]));
                index = activityParser.lastIndex;
            }
            else {
                break;
            }
        }
        if (index < message.length) {
            togo.push(message.substring(index));
        }
        return togo;
    };

    // Renders an activity stack in a form suitable to be sent to a modern browser's console
    // unsupported, non-API function
    fluid.renderActivity = function (activityStack, renderer) {
        renderer = renderer || fluid.renderOneActivity;
        return fluid.transform(activityStack, renderer);
    };

    // Definitions for ThreadLocals - lifted here from
    // FluidIoC.js so that we can issue calls to fluid.describeActivity for debugging purposes
    // in the core framework

    // unsupported, non-API function
    fluid.singleThreadLocal = function (initFunc) {
        var value = initFunc();
        return function (newValue) {
            return newValue === undefined ? value : value = newValue;
        };
    };

    // Currently we only support single-threaded environments - ensure that this function
    // is not used on startup so it can be successfully monkey-patched
    // only remaining uses of threadLocals are for activity reporting and in the renderer utilities
    // unsupported, non-API function
    fluid.threadLocal = fluid.singleThreadLocal;

    // unsupported, non-API function
    fluid.globalThreadLocal = fluid.threadLocal(function () {
        return {};
    });

    // Return an array of objects describing the current activity
    // unsupported, non-API function
    fluid.getActivityStack = function () {
        var root = fluid.globalThreadLocal();
        if (!root.activityStack) {
            root.activityStack = [];
        }
        return root.activityStack;
    };

    // Return an array of objects describing the current activity
    // unsupported, non-API function
    fluid.describeActivity = fluid.getActivityStack;

    // Renders either the current activity or the supplied activity to the console
    fluid.logActivity = function (activity) {
        activity = activity || fluid.describeActivity();
        var rendered = fluid.renderActivity(activity).reverse();
        if (rendered.length > 0) {
            fluid.log("Current activity: ");
            fluid.each(rendered, function (args) {
                fluid.log.apply(null, args);
            });
        }
    };

    // Execute the supplied function with the specified activity description pushed onto the stack
    // unsupported, non-API function
    fluid.pushActivity = function (type, message, args) {
        var record = {type: type, message: message, args: args, time: new Date().getTime()};
        if (fluid.activityTracing) {
            fluid.activityTrace.push(record);
        }
        if (fluid.passLogLevel(fluid.logLevel.TRACE)) {
            fluid.log.apply(null, fluid.renderOneActivity(record, true));
        }
        var activityStack = fluid.getActivityStack();
        activityStack.push(record);
    };

    // Undo the effect of the most recent pushActivity, or multiple frames if an argument is supplied
    fluid.popActivity = function (popframes) {
        popframes = popframes || 1;
        if (fluid.activityTracing) {
            fluid.activityTrace.push({pop: popframes});
        }
        var activityStack = fluid.getActivityStack();
        var popped = activityStack.length - popframes;
        activityStack.length = popped < 0 ? 0 : popped;
    };
    // "this-ist" style Error so that we can distinguish framework errors whilst still retaining access to platform Error features
    // Solution taken from http://stackoverflow.com/questions/8802845/inheriting-from-the-error-object-where-is-the-message-property#answer-17936621
    fluid.FluidError = function (/*message*/) {
        var togo = Error.apply(this, arguments);
        this.message = togo.message;
        try { // This technique is necessary on IE11 since otherwise the stack entry is not filled in
            throw togo;
        } catch (togo) {
            this.stack = togo.stack;
        }
        return this;
    };
    fluid.FluidError.prototype = Object.create(Error.prototype);

    // The framework's built-in "log" failure handler - this logs the supplied message as well as any framework activity in progress via fluid.log
    fluid.logFailure = function (args, activity) {
        fluid.log.apply(null, [fluid.logLevel.FAIL, "ASSERTION FAILED: "].concat(args));
        fluid.logActivity(activity);
    };

    fluid.renderLoggingArg = function (arg) {
        return arg === undefined ? "undefined" : fluid.isPrimitive(arg) || !fluid.isPlainObject(arg) ? arg : JSON.stringify(arg);
    };

    // The framework's built-in "fail" failure handler - this throws an exception of type <code>fluid.FluidError</code>
    fluid.builtinFail = function (args /*, activity*/) {
        var message = fluid.transform(args, fluid.renderLoggingArg).join("");
        throw new fluid.FluidError("Assertion failure - check console for more details: " + message);
    };

    /**
     * Signals an error to the framework. The default behaviour is to log a structured error message and throw an exception. This strategy may be configured
     * by adding and removing suitably namespaced listeners to the special event <code>fluid.failureEvent</code>
     *
     * @param {String} message - The error message to log.
     *
     * All arguments after the first are passed on to (and should be suitable to pass on to) the native console.log
     * function.
     */
    fluid.fail = function (/* message, ... */) {
        var args = fluid.makeArray(arguments);
        var activity = fluid.makeArray(fluid.describeActivity()); // Take copy since we will destructively modify
        fluid.popActivity(activity.length); // clear any current activity - TODO: the framework currently has no exception handlers, although it will in time
        if (fluid.failureEvent) { // notify any framework failure prior to successfully setting up the failure event below
            fluid.failureEvent.fire(args, activity);
        } else {
            fluid.logFailure(args, activity);
            fluid.builtinFail(args, activity);
        }
    };

    fluid.notrycatch = false;

    // A wrapper for the try/catch/finally language feature, to aid debugging in the QUnit UI by means of exception breakpoints for
    // uncaught exceptions, since so many libraries, e.g. jQuery throw junk caught exceptions on startup
    fluid.tryCatch = function (tryfun, catchfun, finallyfun) {
        finallyfun = finallyfun || fluid.identity;
        if (fluid.notrycatch) {
            var togo = tryfun();
            finallyfun();
            return togo;
        } else {
            try {
                return tryfun();
            } catch (e) {
                if (catchfun) {
                    catchfun(e);
                } else {
                    throw (e);
                }
            } finally {
                finallyfun();
            }
        }
    };

    // TODO: rescued from kettleCouchDB.js - clean up in time
    fluid.expect = function (name, target, members) {
        fluid.transform(fluid.makeArray(members), function (key) {
            if (target[key] === undefined) {
                fluid.fail(name + " missing required member " + key);
            }
        });
    };

    // Logging

    /** Returns whether logging is enabled - legacy method
     * @return {Boolean} `true` if the current logging level exceeds `fluid.logLevel.IMPORTANT`
     */
    fluid.isLogging = function () {
        return logLevelStack[0].priority > fluid.logLevel.IMPORTANT.priority;
    };

    /** Determines whether the supplied argument is a valid logLevel marker
     * @param {Any} arg - The value to be tested
     * @return {Boolean} `true` if the supplied argument is a logLevel marker
     */
    fluid.isLogLevel = function (arg) {
        return fluid.isMarker(arg) && arg.priority !== undefined;
    };

    /** Check whether the current framework logging level would cause a message logged with the specified level to be
     * logged. Clients who issue particularly expensive log payload arguments are recommended to guard their logging
     * statements with this function
     * @param {LogLevel} testLogLevel - The logLevel value which the current logging level will be tested against.
     * Accepts one of the members of the <code>fluid.logLevel</code> structure.
     * @return {Boolean} Returns <code>true</code> if a message supplied at that log priority would be accepted at the current logging level.
     */

    fluid.passLogLevel = function (testLogLevel) {
        return testLogLevel.priority <= logLevelStack[0].priority;
    };

    /** Method to allow user to control the current framework logging level. The supplied level will be pushed onto a stack
     * of logging levels which may be popped via `fluid.popLogging`.
     * @param {Boolean|LogLevel} enabled - Either a boolean, for which <code>true</code>
     * represents <code>fluid.logLevel.INFO</code> and <code>false</code> represents <code>fluid.logLevel.IMPORTANT</code> (the default),
     * or else any other member of the structure <code>fluid.logLevel</code>
     * Messages whose priority is strictly less than the current logging level will not be shown by `fluid.log`
     */
    fluid.setLogging = function (enabled) {
        var logLevel;
        if (typeof enabled === "boolean") {
            logLevel = fluid.logLevel[enabled ? "INFO" : "IMPORTANT"];
        } else if (fluid.isLogLevel(enabled)) {
            logLevel = enabled;
        } else {
            fluid.fail("Unrecognised fluid logging level ", enabled);
        }
        logLevelStack.unshift(logLevel);
        fluid.defeatLogging = !fluid.isLogging();
    };

    fluid.setLogLevel = fluid.setLogging;

    /** Undo the effect of the most recent "setLogging", returning the logging system to its previous state
     * @return {LogLevel} The logLevel that was just popped
     */
    fluid.popLogging = function () {
        var togo = logLevelStack.length === 1 ? logLevelStack[0] : logLevelStack.shift();
        fluid.defeatLogging = !fluid.isLogging();
        return togo;
    };

    /** Actually do the work of logging <code>args</code> to the environment's console. If the standard "console"
     * stream is available, the message will be sent there.
     * @param {Array} args - The complete array of arguments to be logged
     */
    fluid.doBrowserLog = function (args) {
        if (typeof (console) !== "undefined") {
            if (console.debug) {
                console.debug.apply(console, args);
            } else if (typeof (console.log) === "function") {
                console.log.apply(console, args);
            }
        }
    };

    /* Log a message to a suitable environmental console. If the first argument to fluid.log is
     * one of the members of the <code>fluid.logLevel</code> structure, this will be taken as the priority
     * of the logged message - else if will default to <code>fluid.logLevel.INFO</code>. If the logged message
     * priority does not exceed that set by the most recent call to the <code>fluid.setLogging</code> function,
     * the message will not appear.
     */
    fluid.log = function (/* message /*, ... */) {
        var directArgs = fluid.makeArray(arguments);
        var userLogLevel = fluid.logLevel.INFO;
        if (fluid.isLogLevel(directArgs[0])) {
            userLogLevel = directArgs.shift();
        }
        if (fluid.passLogLevel(userLogLevel)) {
            fluid.loggingEvent.fire(directArgs);
        }
    };

    // Functional programming utilities.

    // Type checking functions

    /** Check whether the argument is a value other than null or undefined
     * @param {Any} value - The value to be tested
     * @return {Boolean} `true` if the supplied value is other than null or undefined
     */
    fluid.isValue = function (value) {
        return value !== undefined && value !== null;
    };

    /** Check whether the argument is a primitive type
     * @param {Any} value - The value to be tested
     * @return {Boolean} `true` if the supplied value is a JavaScript (ES5) primitive
     */
    fluid.isPrimitive = function (value) {
        var valueType = typeof (value);
        return !value || valueType === "string" || valueType === "boolean" || valueType === "number" || valueType === "function";
    };

    /** Determines whether the supplied object is an jQuery object. The strategy uses optimised inspection of the
     * constructor prototype since jQuery may not actually be loaded
     * @param {Any} totest - The value to be tested
     * @return {Boolean} `true` if the supplied value is a jQuery object
     */
    fluid.isJQuery = function (totest) {
        return Boolean(totest && totest.jquery && totest.constructor && totest.constructor.prototype
               && totest.constructor.prototype.jquery);
    };

    /** Determines whether the supplied object is an array. The strategy used is an optimised
     * approach taken from an earlier version of jQuery - detecting whether the toString() version
     * of the object agrees with the textual form [object Array], or else whether the object is a
     * jQuery object (the most common source of "fake arrays").
     * @param {Any} totest - The value to be tested
     * @return {Boolean} `true` if the supplied value is an array
     */
    // Note: The primary place jQuery->Array conversion is used in the framework is in dynamic components with a jQuery source.
    fluid.isArrayable = function (totest) {
        return Boolean(totest) && (Object.prototype.toString.call(totest) === "[object Array]" || fluid.isJQuery(totest));
    };

    /** Determines whether the supplied object is a plain JSON-forming container - that is, it is either a plain Object
     * or a plain Array. Note that this differs from jQuery's isPlainObject which does not pass Arrays.
     * @param {Any} totest - The object to be tested
     * @param {Boolean} [strict] - (optional) If `true`, plain Arrays will fail the test rather than passing.
     * @return {Boolean} - `true` if `totest` is a plain object, `false` otherwise.
     */
    fluid.isPlainObject = function (totest, strict) {
        var string = Object.prototype.toString.call(totest);
        if (string === "[object Array]") {
            return !strict;
        } else if (string !== "[object Object]") {
            return false;
        } // FLUID-5226: This inventive strategy taken from jQuery detects whether the object's prototype is directly Object.prototype by virtue of having an "isPrototypeOf" direct member
        return !totest.constructor || !totest.constructor.prototype || Object.prototype.hasOwnProperty.call(totest.constructor.prototype, "isPrototypeOf");
    };

    /** Returns a string typeCode representing the type of the supplied value at a coarse level.
     * Returns <code>primitive</code>, <code>array</code> or <code>object</code> depending on whether the supplied object has
     * one of those types, by use of the <code>fluid.isPrimitive</code>, <code>fluid.isPlainObject</code> and <code>fluid.isArrayable</code> utilities
     * @param {Any} totest - The value to be tested
     * @return {String} Either `primitive`, `array` or `object` depending on the type of the supplied value
     */
    fluid.typeCode = function (totest) {
        return fluid.isPrimitive(totest) || !fluid.isPlainObject(totest) ? "primitive" :
            fluid.isArrayable(totest) ? "array" : "object";
    };

    /** Determine whether the supplied value is an IoC reference. The test is passed if the value is a string whose
     * first character is "{" and has closing "}" character somewhere in the string
     * @param {Any} ref - The value to be tested
     * @return {Boolean} `true` if the supplied value is an IoC reference
     */
    fluid.isIoCReference = function (ref) {
        return typeof(ref) === "string" && ref.charAt(0) === "{" && ref.indexOf("}") > 0;
    };

    /** Determine whether the supplied value is a reference or an expander. The test is passed if either fluid.isIoCReference passes
     * or the value has an "expander" member
     * @param {Any} ref - The value to be tested
     * @return {Boolean} `true` if the supplied value is a reference or expander
     */
    fluid.isReferenceOrExpander = function (ref) {
        return ref && (fluid.isIoCReference(ref) || ref.expander);
    };

    fluid.isDOMNode = function (obj) {
      // This could be more sound, but messy:
      // http://stackoverflow.com/questions/384286/javascript-isdom-how-do-you-check-if-a-javascript-object-is-a-dom-object
      // The real problem is browsers like IE6, 7 and 8 which still do not feature a "constructor" property on DOM nodes
        return obj && typeof (obj.nodeType) === "number";
    };

    fluid.isComponent = function (obj) {
        return obj && obj.constructor === fluid.componentConstructor;
    };

    fluid.isUncopyable = function (totest) {
        return fluid.isPrimitive(totest) || !fluid.isPlainObject(totest);
    };

    fluid.isApplicable = function (totest) {
        return totest.apply && typeof(totest.apply) === "function";
    };

    /* A basic utility that returns its argument unchanged */
    fluid.identity = function (arg) {
        return arg;
    };

    /** A function which raises a failure if executed */
    fluid.notImplemented = function () {
        fluid.fail("This operation is not implemented");
    };

    /** Returns the first of its arguments if it is not `undefined`, otherwise returns the second.
     * @param {Any} a - The first argument to be tested for being `undefined`
     * @param {Any} b - The fallback argument, to be returned if `a` is `undefined`
     * @return {Any} `a` if it is not `undefined`, else `b`.
     */
    fluid.firstDefined = function (a, b) {
        return a === undefined ? b : a;
    };

    /* Return an empty container as the same type as the argument (either an array or hash). */
    fluid.freshContainer = function (tocopy) {
        return fluid.isArrayable(tocopy) ? [] : {};
    };

    fluid.copyRecurse = function (tocopy, segs) {
        if (segs.length > fluid.strategyRecursionBailout) {
            fluid.fail("Runaway recursion encountered in fluid.copy - reached path depth of " + fluid.strategyRecursionBailout + " via path of " + segs.join(".") +
                "this object is probably circularly connected. Either adjust your object structure to remove the circularity or increase fluid.strategyRecursionBailout");
        }
        if (fluid.isUncopyable(tocopy)) {
            return tocopy;
        } else {
            return fluid.transform(tocopy, function (value, key) {
                segs.push(key);
                var togo = fluid.copyRecurse(value, segs);
                segs.pop();
                return togo;
            });
        }
    };

    /* Performs a deep copy (clone) of its argument. This will guard against cloning a circular object by terminating if it reaches a path depth
     * greater than <code>fluid.strategyRecursionBailout</code>
     */

    fluid.copy = function (tocopy) {
        return fluid.copyRecurse(tocopy, []);
    };

    // TODO: Coming soon - reimplementation of $.extend using strategyRecursionBailout
    fluid.extend = $.extend;

    /* Corrected version of jQuery makeArray that returns an empty array on undefined rather than crashing.
     * We don't deal with as many pathological cases as jQuery */
    fluid.makeArray = function (arg) {
        var togo = [];
        if (arg !== null && arg !== undefined) {
            if (fluid.isPrimitive(arg) || fluid.isPlainObject(arg, true) || typeof(arg.length) !== "number") {
                togo.push(arg);
            }
            else {
                for (var i = 0; i < arg.length; ++i) {
                    togo[i] = arg[i];
                }
            }
        }
        return togo;
    };

    /** Pushes an element or elements onto an array, initialising the array as a member of a holding object if it is
     * not already allocated.
     * @param {Array|Object} holder - The holding object whose member is to receive the pushed element(s).
     * @param {String} member - The member of the <code>holder</code> onto which the element(s) are to be pushed
     * @param {Array|Object} topush - If an array, these elements will be added to the end of the array using Array.push.apply. If an object, it will be pushed to the end of the array using Array.push.
     */
    fluid.pushArray = function (holder, member, topush) {
        var array = holder[member] ? holder[member] : (holder[member] = []);
        if (fluid.isArrayable(topush)) {
            array.push.apply(array, topush);
        } else {
            array.push(topush);
        }
    };

    function transformInternal(source, togo, key, args) {
        var transit = source[key];
        for (var j = 0; j < args.length - 1; ++j) {
            transit = args[j + 1](transit, key);
        }
        togo[key] = transit;
    }

    /** Return an array or hash of objects, transformed by one or more functions. Similar to
     * jQuery.map, only will accept an arbitrary list of transformation functions and also
     * works on non-arrays.
     * @param {Array|Object} source - The initial container of objects to be transformed. If the source is
     * neither an array nor an object, it will be returned untransformed
     * @param {...Function} fn1, fn2, etc. - An arbitrary number of optional further arguments,
     * all of type Function, accepting the signature (object, index), where object is the
     * structure member to be transformed, and index is its key or index. Each function will be
     * applied in turn to each structure member, which will be replaced by the return value
     * from the function.
     * @return {Array|Object} - The finally transformed list, where each member has been replaced by the
     * original member acted on by the function or functions.
     */
    fluid.transform = function (source) {
        if (fluid.isPrimitive(source)) {
            return source;
        }
        var togo = fluid.freshContainer(source);
        if (fluid.isArrayable(source)) {
            for (var i = 0; i < source.length; ++i) {
                transformInternal(source, togo, i, arguments);
            }
        } else {
            for (var key in source) {
                transformInternal(source, togo, key, arguments);
            }
        }
        return togo;
    };

    /** Variety of Array.forEach which iterates over an array range
     * @param {Arrayable} array - The array to be iterated over
     * @param {Integer} start - The array index to start iterating at
     * @param {Integer} end - The limit of the array index for the iteration
     * @param {Function} func - A function accepting (value, key) for each iterated
     * object.
     */
    fluid.forEachInRange = function (array, start, end, func) {
        for (var i = start; i < end; ++i) {
            func(array[i], i);
        }
    };

    /** Return the last element of an array. If the array is of length 0, returns `undefined`.
     * @param {Arrayable} array - The array to be peeked into
     * @return {Any} start - The last element of the array
     */
    fluid.peek = function (array) {
        return array.length === 0 ? undefined : array[array.length - 1];
    };

    /** Better jQuery.each which works on hashes as well as having the arguments the right way round.
     * @param {Arrayable|Object} source - The container to be iterated over
     * @param {Function} func - A function accepting (value, key) for each iterated
     * object.
     */
    fluid.each = function (source, func) {
        if (fluid.isArrayable(source)) {
            for (var i = 0; i < source.length; ++i) {
                func(source[i], i);
            }
        } else {
            for (var key in source) {
                func(source[key], key);
            }
        }
    };

    fluid.make_find = function (find_if) {
        var target = find_if ? false : undefined;
        return function (source, func, deffolt) {
            var disp;
            if (fluid.isArrayable(source)) {
                for (var i = 0; i < source.length; ++i) {
                    disp = func(source[i], i);
                    if (disp !== target) {
                        return find_if ? source[i] : disp;
                    }
                }
            } else {
                for (var key in source) {
                    disp = func(source[key], key);
                    if (disp !== target) {
                        return find_if ? source[key] : disp;
                    }
                }
            }
            return deffolt;
        };
    };

    /** Scan through an array or hash of objects, terminating on the first member which
     * matches a predicate function.
     * @param {Arrayable|Object} source - The array or hash of objects to be searched.
     * @param {Function} func - A predicate function, acting on a member. A predicate which
     * returns any value which is not <code>undefined</code> will terminate
     * the search. The function accepts (object, index).
     * @param {Object} deflt - A value to be returned in the case no predicate function matches
     * a structure member. The default will be the natural value of <code>undefined</code>
     * @return The first return value from the predicate function which is not <code>undefined</code>
     */
    fluid.find = fluid.make_find(false);
    /* The same signature as fluid.find, only the return value is the actual element for which the
     * predicate returns a value different from <code>false</code>
     */
    fluid.find_if = fluid.make_find(true);

    /** Scan through an array of objects, "accumulating" a value over them
     * (may be a straightforward "sum" or some other chained computation). "accumulate" is the name derived
     * from the C++ STL, other names for this algorithm are "reduce" or "fold".
     * @param {Array} list - The list of objects to be accumulated over.
     * @param {Function} fn - An "accumulation function" accepting the signature (object, total, index) where
     * object is the list member, total is the "running total" object (which is the return value from the previous function),
     * and index is the index number.
     * @param {Object} arg - The initial value for the "running total" object.
     * @return {Object} the final running total object as returned from the final invocation of the function on the last list member.
     */
    fluid.accumulate = function (list, fn, arg) {
        for (var i = 0; i < list.length; ++i) {
            arg = fn(list[i], arg, i);
        }
        return arg;
    };

    /** Returns the sum of its two arguments. A useful utility to combine with fluid.accumulate to compute totals
     * @param {Number|Boolean} a - The first operand to be added
     * @param {Number|Boolean} b - The second operand to be added
     * @return {Number} The sum of the two operands
     **/
    fluid.add = function (a, b) {
        return a + b;
    };

    /** Scan through an array or hash of objects, removing those which match a predicate. Similar to
     * jQuery.grep, only acts on the list in-place by removal, rather than by creating
     * a new list by inclusion.
     * @param {Array|Object} source - The array or hash of objects to be scanned over. Note that in the case this is an array,
     * the iteration will proceed from the end of the array towards the front.
     * @param {Function} fn - A predicate function determining whether an element should be
     * removed. This accepts the standard signature (object, index) and returns a "truthy"
     * result in order to determine that the supplied object should be removed from the structure.
     * @param {Array|Object} [target] - (optional) A target object of the same type as <code>source</code>, which will
     * receive any objects removed from it.
     * @return {Array|Object} - <code>target</code>, containing the removed elements, if it was supplied, or else <code>source</code>
     * modified by the operation of removing the matched elements.
     */
    fluid.remove_if = function (source, fn, target) {
        if (fluid.isArrayable(source)) {
            for (var i = source.length - 1; i >= 0; --i) {
                if (fn(source[i], i)) {
                    if (target) {
                        target.unshift(source[i]);
                    }
                    source.splice(i, 1);
                }
            }
        } else {
            for (var key in source) {
                if (fn(source[key], key)) {
                    if (target) {
                        target[key] = source[key];
                    }
                    delete source[key];
                }
            }
        }
        return target || source;
    };

    /** Fills an array of given size with copies of a value or result of a function invocation
     * @param {Number} n - The size of the array to be filled
     * @param {Object|Function} generator - Either a value to be replicated or function to be called
     * @param {Boolean} applyFunc - If true, treat the generator value as a function to be invoked with
     * argument equal to the index position
     */

    fluid.generate = function (n, generator, applyFunc) {
        var togo = [];
        for (var i = 0; i < n; ++i) {
            togo[i] = applyFunc ? generator(i) : generator;
        }
        return togo;
    };

    /** Returns an array of size count, filled with increasing integers, starting at 0 or at the index specified by first.
     * @param {Number} count - Size of the filled array to be returned
     * @param {Number} [first] - (optional, defaults to 0) First element to appear in the array
     */

    fluid.iota = function (count, first) {
        first = first || 0;
        var togo = [];
        for (var i = 0; i < count; ++i) {
            togo[togo.length] = first++;
        }
        return togo;
    };

    /** Extracts a particular member from each top-level member of a container, returning a new container of the same type
     * @param {Array|Object} holder - The container to be filtered
     * @param {String|String[]} name - An EL path to be fetched from each top-level member
     * @return {Object} - The desired member component.
     */
    fluid.getMembers = function (holder, name) {
        return fluid.transform(holder, function (member) {
            return fluid.get(member, name);
        });
    };

    /** Accepts an object to be filtered, and an array of keys. Either all keys not present in
     * the array are removed, or only keys present in the array are returned.
     * @param {Array|Object} toFilter - The object to be filtered - this will be NOT modified by the operation (current implementation
     * passes through $.extend shallow algorithm)
     * @param {String[]} keys - The array of keys to operate with
     * @param {Boolean} exclude - If <code>true</code>, the keys listed are removed rather than included
     * @return {Object} the filtered object (the same object that was supplied as <code>toFilter</code>
     */
    fluid.filterKeys = function (toFilter, keys, exclude) {
        return fluid.remove_if($.extend({}, toFilter), function (value, key) {
            return exclude ^ (keys.indexOf(key) === -1);
        });
    };

    /* A convenience wrapper for <code>fluid.filterKeys</code> with the parameter <code>exclude</code> set to <code>true</code>
     *  Returns the supplied object with listed keys removed */
    fluid.censorKeys = function (toCensor, keys) {
        return fluid.filterKeys(toCensor, keys, true);
    };

    /* Return the keys in the supplied object as an array. Note that this will return keys found in the prototype chain as well as "own properties", unlike Object.keys() */
    fluid.keys = function (obj) {
        var togo = [];
        for (var key in obj) {
            togo.push(key);
        }
        return togo;
    };

    /* Return the values in the supplied object as an array */
    fluid.values = function (obj) {
        var togo = [];
        for (var key in obj) {
            togo.push(obj[key]);
        }
        return togo;
    };

    /*
     * Searches through the supplied object, and returns <code>true</code> if the supplied value
     * can be found
     */
    fluid.contains = function (obj, value) {
        return obj ? (fluid.isArrayable(obj) ? obj.indexOf(value) !== -1 : fluid.find(obj, function (thisValue) {
            if (value === thisValue) {
                return true;
            }
        })) : undefined;
    };

    /**
     * Searches through the supplied object for the first value which matches the one supplied.
     * @param {Object} obj - the Object to be searched through
     * @param {Object} value - the value to be found. This will be compared against the object's
     * member using === equality.
     * @return {String} The first key whose value matches the one supplied
     */
    fluid.keyForValue = function (obj, value) {
        return fluid.find(obj, function (thisValue, key) {
            if (value === thisValue) {
                return key;
            }
        });
    };

    /** Converts an array into an object whose keys are the elements of the array, each with the value "true"
     * @param {String[]} array - The array to be converted to a hash
     * @return hash {Object} An object with value <code>true</code> for each key taken from a member of <code>array</code>
     */

    fluid.arrayToHash = function (array) {
        var togo = {};
        fluid.each(array, function (el) {
            togo[el] = true;
        });
        return togo;
    };

    /** Applies a stable sorting algorithm to the supplied array and comparator (note that Array.sort in JavaScript is not specified
     * to be stable). The algorithm used will be an insertion sort, which whilst quadratic in time, will perform well
     * on small array sizes.
     * @param {Array} array - The array to be sorted. This input array will be modified in place.
     * @param {Function} func - A comparator returning >0, 0, or <0 on pairs of elements representing their sort order (same contract as Array.sort comparator)
     */

    fluid.stableSort = function (array, func) {
        for (var i = 0; i < array.length; i++) {
            var j, k = array[i];
            for (j = i; j > 0 && func(k, array[j - 1]) < 0; j--) {
                array[j] = array[j - 1];
            }
            array[j] = k;
        }
    };

    /* Converts a hash into an object by hoisting out the object's keys into an array element via the supplied String "key", and then transforming via an optional further function, which receives the signature
     * (newElement, oldElement, key) where newElement is the freshly cloned element, oldElement is the original hash's element, and key is the key of the element.
     * If the function is not supplied, the old element is simply deep-cloned onto the new element (same effect as transform fluid.transforms.deindexIntoArrayByKey).
     * The supplied hash will not be modified, unless the supplied function explicitly does so by modifying its 2nd argument.
     */
    fluid.hashToArray = function (hash, keyName, func) {
        var togo = [];
        fluid.each(hash, function (el, key) {
            var newEl = {};
            newEl[keyName] = key;
            if (func) {
                newEl = func(newEl, el, key) || newEl;
            } else {
                $.extend(true, newEl, el);
            }
            togo.push(newEl);
        });
        return togo;
    };

    /* Converts an array consisting of a mixture of arrays and non-arrays into the concatenation of any inner arrays
     * with the non-array elements
     */
    fluid.flatten = function (array) {
        var togo = [];
        fluid.each(array, function (element) {
            if (fluid.isArrayable(element)) {
                togo = togo.concat(element);
            } else {
                togo.push(element);
            }
        });
        return togo;
    };

    /**
     * Clears an object or array of its contents. For objects, each property is deleted.
     *
     * @param {Object|Array} target - the target to be cleared
     */
    fluid.clear = function (target) {
        if (fluid.isArrayable(target)) {
            target.length = 0;
        } else {
            for (var i in target) {
                delete target[i];
            }
        }
    };

   /**
    * @param {Boolean} ascending <code>true</code> if a comparator is to be returned which
    * sorts strings in descending order of length.
    * @return {Function} - A comparison function.
    */
    fluid.compareStringLength = function (ascending) {
        return ascending ? function (a, b) {
            return a.length - b.length;
        } : function (a, b) {
            return b.length - a.length;
        };
    };

    /**
     * Returns the converted integer if the input string can be converted to an integer. Otherwise, return NaN.
     * @param {String} string - A string to be returned in integer form.
     * @return {Number|NaN} - The numeric value if the string can be converted, otherwise, returns NaN.
     */
    fluid.parseInteger = function (string) {
        return isFinite(string) && ((string % 1) === 0) ? Number(string) : NaN;
    };

    /**
     * "Ponyfill" for Number.isInteger - can be removed once we drop support for IE11
     * @param {Any} value - A value to be tested for being an integer
     * @return {Boolean} `true` if the value is a Number and a finite integer
     */
    fluid.isInteger = function (value) {
        return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };

    /**
     * Derived from Sindre Sorhus's round-to node module ( https://github.com/sindresorhus/round-to ).
     * License: MIT
     *
     * Rounds the supplied number to at most the number of decimal places indicated by the scale, omitting any trailing 0s.
     * There are three possible rounding methods described below: "round", "ceil", "floor"
     * Round: Numbers are rounded away from 0 (i.e 0.5 -> 1, -0.5 -> -1).
     * Ceil: Numbers are rounded up
     * Floor: Numbers are rounded down
     * If the scale is invalid (i.e falsey, not a number, negative value), it is treated as 0.
     * If the scale is a floating point number, it is rounded to an integer.
     *
     * @param {Number} num - the number to be rounded
     * @param {Number} scale - the maximum number of decimal places to round to.
     * @param {String} [method] - (optional) Request a rounding method to use ("round", "ceil", "floor").
     *                          If nothing or an invalid method is provided, it will default to "round".
     * @return {Number} The num value rounded to the specified number of decimal places.
     */
    fluid.roundToDecimal = function (num, scale, method) {
        // treat invalid scales as 0
        scale = scale && scale >= 0 ? Math.round(scale) : 0;

        if (method === "ceil" || method === "floor") {
            // The following is derived from https://github.com/sindresorhus/round-to/blob/v2.0.0/index.js#L20
            return Number(Math[method](num + "e" + scale) + "e-" + scale);
        } else {
            // The following is derived from https://github.com/sindresorhus/round-to/blob/v2.0.0/index.js#L17
            var sign = num >= 0 ? 1 : -1; // manually calculating the sign because Math.sign is not supported in IE
            return Number(sign * (Math.round(Math.abs(num) + "e" + scale) + "e-" + scale));
        }
    };

    /**
     * Copied from Underscore.js 1.4.3 - see licence at head of this file
     *
     * Will execute the passed in function after the specified amount of time since it was last executed.
     * @param {Function} func - the function to execute
     * @param {Number} wait - the number of milliseconds to wait before executing the function
     * @param {Boolean} immediate - Whether to trigger the function at the start (true) or end (false) of
     *                              the wait interval.
     * @return {Function} - A function that can be called as though it were the original function.
     */
    fluid.debounce = function (func, wait, immediate) {
        var timeout, result;
        return function () {
            var context = this, args = arguments;
            var later = function () {
                timeout = null;
                if (!immediate) {
                    result = func.apply(context, args);
                }
            };
            var callNow = immediate && !timeout;
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
            if (callNow) {
                result = func.apply(context, args);
            }
            return result;
        };
    };

    /** Calls Object.freeze at each level of containment of the supplied object
     * @param {Any} tofreeze  - The material to freeze.
     * @return {Any} - The supplied argument, recursively frozen.
     */
    fluid.freezeRecursive = function (tofreeze) {
        if (fluid.isPlainObject(tofreeze)) {
            fluid.each(tofreeze, function (value) {
                fluid.freezeRecursive(value);
            });
            return Object.freeze(tofreeze);
        } else {
            return tofreeze;
        }
    };

    /* A set of special "marker values" used in signalling in function arguments and return values,
     * to partially compensate for JavaScript's lack of distinguished types. These should never appear
     * in JSON structures or other kinds of static configuration. An API specifically documents if it
     * accepts or returns any of these values, and if so, what its semantic is  - most are of private
     * use internal to the framework */

    fluid.marker = function () {};

    fluid.makeMarker = function (value, extra) {
        var togo = Object.create(fluid.marker.prototype);
        togo.value = value;
        $.extend(togo, extra);
        return Object.freeze(togo);
    };

    /* A special "marker object" representing that a distinguished
     * (probably context-dependent) value should be substituted.
     */
    fluid.VALUE = fluid.makeMarker("VALUE");

    /* A special "marker object" representing that no value is present (where
     * signalling using the value "undefined" is not possible - e.g. the return value from a "strategy") */
    fluid.NO_VALUE = fluid.makeMarker("NO_VALUE");

    /* A marker indicating that a value requires to be expanded after component construction begins */
    fluid.EXPAND = fluid.makeMarker("EXPAND");

    /* Determine whether an object is any marker, or a particular marker - omit the
     * 2nd argument to detect any marker
     */
    fluid.isMarker = function (totest, type) {
        if (!(totest instanceof fluid.marker)) {
            return false;
        }
        if (!type) {
            return true;
        }
        return totest.value === type.value;
    };

    fluid.logLevelsSpec = {
        "FATAL":      0,
        "FAIL":       5,
        "WARN":      10,
        "IMPORTANT": 12, // The default logging "off" level - corresponds to the old "false"
        "INFO":      15, // The default logging "on" level - corresponds to the old "true"
        "TRACE":     20
    };

    /* A structure holding all supported log levels as supplied as a possible first argument to fluid.log
     * Members with a higher value of the "priority" field represent lower priority logging levels */
    // Moved down here since it uses fluid.transform and fluid.makeMarker on startup
    fluid.logLevel = fluid.transform(fluid.logLevelsSpec, function (value, key) {
        return fluid.makeMarker(key, {priority: value});
    });
    var logLevelStack = [fluid.logLevel.IMPORTANT]; // The stack of active logging levels, with the current level at index 0


    // Model functions
    fluid.model = {}; // cannot call registerNamespace yet since it depends on fluid.model

    /* Copy a source "model" onto a target */
    fluid.model.copyModel = function (target, source) {
        fluid.clear(target);
        $.extend(true, target, source);
    };

    /** Parse an EL expression separated by periods (.) into its component segments.
     * @param {String} EL - The EL expression to be split
     * @return {String[]} the component path expressions.
     * TODO: This needs to be upgraded to handle (the same) escaping rules (as RSF), so that
     * path segments containing periods and backslashes etc. can be processed, and be harmonised
     * with the more complex implementations in fluid.pathUtil(data binding).
     */
    fluid.model.parseEL = function (EL) {
        return EL === "" ? [] : String(EL).split(".");
    };

    /* Compose an EL expression from two separate EL expressions. The returned
     * expression will be the one that will navigate the first expression, and then
     * the second, from the value reached by the first. Either prefix or suffix may be
     * the empty string */
    fluid.model.composePath = function (prefix, suffix) {
        return prefix === "" ? suffix : (suffix === "" ? prefix : prefix + "." + suffix);
    };

    /* Compose any number of path segments, none of which may be empty */
    fluid.model.composeSegments = function () {
        return fluid.makeArray(arguments).join(".");
    };

    /* Returns the index of the last occurrence of the period character . in the supplied string */
    fluid.lastDotIndex = function (path) {
        return path.lastIndexOf(".");
    };

    /* Returns all of an EL path minus its final segment - if the path consists of just one segment, returns "" -
     * WARNING - this method does not follow escaping rules */
    fluid.model.getToTailPath = function (path) {
        var lastdot = fluid.lastDotIndex(path);
        return lastdot === -1 ? "" : path.substring(0, lastdot);
    };

    /* Returns the very last path component of an EL path
     * WARNING - this method does not follow escaping rules */
    fluid.model.getTailPath = function (path) {
        var lastdot = fluid.lastDotIndex(path);
        return path.substring(lastdot + 1);
    };

    /* Helpful alias for old-style API */
    fluid.path = fluid.model.composeSegments;
    fluid.composePath = fluid.model.composePath;


    // unsupported, NON-API function
    fluid.requireDataBinding = function () {
        fluid.fail("Please include DataBinding.js in order to operate complex model accessor configuration");
    };

    fluid.model.setWithStrategy = fluid.model.getWithStrategy = fluid.requireDataBinding;

    // unsupported, NON-API function
    fluid.model.resolvePathSegment = function (root, segment, create, origEnv) {
        // TODO: This branch incurs a huge cost that we incur across the whole framework, just to support the DOM binder
        // usage. We need to either do something "schematic" or move to proxies
        // TODO: Most costs are incurred from fluid.compileMergePolicy, some from fluid.model.setChangedPath
        if (!origEnv && root.resolvePathSegment) {
            var togo = root.resolvePathSegment(segment);
            if (togo !== undefined) { // To resolve FLUID-6132
                return togo;
            }
        }
        if (create && root[segment] === undefined) {
            // This optimisation in this heavily used function has a fair effect
            return root[segment] = {};
        }
        return root[segment];
    };

    // unsupported, NON-API function
    fluid.model.parseToSegments = function (EL, parseEL, copy) {
        return typeof(EL) === "number" || typeof(EL) === "string" ? parseEL(EL) : (copy ? fluid.makeArray(EL) : EL);
    };

    // unsupported, NON-API function
    fluid.model.pathToSegments = function (EL, config) {
        var parser = config && config.parser ? config.parser.parse : fluid.model.parseEL;
        return fluid.model.parseToSegments(EL, parser);
    };

    // Overall strategy skeleton for all implementations of fluid.get/set
    fluid.model.accessImpl = function (root, EL, newValue, config, initSegs, returnSegs, traverser) {
        var segs = fluid.model.pathToSegments(EL, config);
        var initPos = 0;
        if (initSegs) {
            initPos = initSegs.length;
            segs = initSegs.concat(segs);
        }
        var uncess = newValue === fluid.NO_VALUE ? 0 : 1;
        root = traverser(root, segs, initPos, config, uncess);
        if (newValue === fluid.NO_VALUE || newValue === fluid.VALUE) { // get or custom
            return returnSegs ? {root: root, segs: segs} : root;
        }
        else { // set
            root[fluid.peek(segs)] = newValue;
        }
    };

    // unsupported, NON-API function
    fluid.model.accessSimple = function (root, EL, newValue, environment, initSegs, returnSegs) {
        return fluid.model.accessImpl(root, EL, newValue, environment, initSegs, returnSegs, fluid.model.traverseSimple);
    };

    // unsupported, NON-API function
    fluid.model.traverseSimple = function (root, segs, initPos, environment, uncess) {
        var origEnv = environment;
        var limit = segs.length - uncess;
        for (var i = 0; i < limit; ++i) {
            if (!root) {
                return undefined;
            }
            var segment = segs[i];
            if (environment && environment[segment]) {
                root = environment[segment];
            } else {
                root = fluid.model.resolvePathSegment(root, segment, uncess === 1, origEnv);
            }
            environment = null;
        }
        return root;
    };

    fluid.model.setSimple = function (root, EL, newValue, environment, initSegs) {
        fluid.model.accessSimple(root, EL, newValue, environment, initSegs, false);
    };

    /* Optimised version of fluid.get for uncustomised configurations */

    fluid.model.getSimple = function (root, EL, environment, initSegs) {
        if (EL === null || EL === undefined || EL.length === 0) {
            return root;
        }
        return fluid.model.accessSimple(root, EL, fluid.NO_VALUE, environment, initSegs, false);
    };

    /* Even more optimised version which assumes segs are parsed and no configuration */
    fluid.getImmediate = function (root, segs, i) {
        var limit = (i === undefined ? segs.length : i + 1);
        for (var j = 0; j < limit; ++j) {
            root = root ? root[segs[j]] : undefined;
        }
        return root;
    };

    // unsupported, NON-API function
    // Returns undefined to signal complex configuration which needs to be farmed out to DataBinding.js
    // any other return represents an environment value AND a simple configuration we can handle here
    fluid.decodeAccessorArg = function (arg3) {
        return (!arg3 || arg3 === fluid.model.defaultGetConfig || arg3 === fluid.model.defaultSetConfig) ?
            null : (arg3.type === "environment" ? arg3.value : undefined);
    };

    fluid.set = function (root, EL, newValue, config, initSegs) {
        var env = fluid.decodeAccessorArg(config);
        if (env === undefined) {
            fluid.model.setWithStrategy(root, EL, newValue, config, initSegs);
        } else {
            fluid.model.setSimple(root, EL, newValue, env, initSegs);
        }
    };

    /** Evaluates an EL expression by fetching a dot-separated list of members
     * recursively from a provided root.
     * @param {Object} root - The root data structure in which the EL expression is to be evaluated
     * @param {String|String[]} EL - The EL expression to be evaluated, or an array of path segments
     * @param {Object} [config] - An optional configuration or environment structure which can customise the fetch operation
     * @return {Any} The fetched data value.
     */

    fluid.get = function (root, EL, config, initSegs) {
        var env = fluid.decodeAccessorArg(config);
        return env === undefined ?
            fluid.model.getWithStrategy(root, EL, config, initSegs)
            : fluid.model.accessImpl(root, EL, fluid.NO_VALUE, env, null, false, fluid.model.traverseSimple);
    };

    /** Returns any value held at a particular global path. This may be an object or a function, depending on what has been stored there.
     * @param {String|String[]} path - The global path from which the value is to be fetched
     * @param {Object} [env] - [optional] An environmental overlay object which will be consulted before any lookups in the global namespace.
     * @return {Any} The value that was stored at the path, or undefined if there is none.
     */

    fluid.getGlobalValue = function (path, env) {
        if (path) {
            env = env || fluid.environment;
            return fluid.get(fluid.global, path, {type: "environment", value: env});
        }
    };

    /**
     * Allows for the binding to a "this-ist" function
     * @param {Object} obj - "this-ist" object to bind to
     * @param {Object} fnName - The name of the function to call.
     * @param {Object} args - Arguments to call the function with.
     * @return {Any} - The return value (if any) of the underlying function.
     */
    fluid.bind = function (obj, fnName, args) {
        return obj[fnName].apply(obj, fluid.makeArray(args));
    };

    /**
     * Allows for the calling of a function from an EL expression "functionPath", with the arguments "args", scoped to an framework version "environment".
     * @param {Object} functionPath - An EL expression
     * @param {Object} args - An array of arguments to be applied to the function, specified in functionPath
     * @param {Object} [environment] - (optional) The object to scope the functionPath to  (typically the framework root for version control)
     * @return {Any} - The return value from the invoked function.
     */
    fluid.invokeGlobalFunction = function (functionPath, args, environment) {
        var func = fluid.getGlobalValue(functionPath, environment);
        if (!func) {
            fluid.fail("Error invoking global function: " + functionPath + " could not be located");
        } else {
            return func.apply(null, fluid.isArrayable(args) ? args : fluid.makeArray(args));
        }
    };

    /* Registers a new global function at a given path */

    fluid.registerGlobalFunction = function (functionPath, func, env) {
        env = env || fluid.environment;
        fluid.set(fluid.global, functionPath, func, {type: "environment", value: env});
    };

    fluid.setGlobalValue = fluid.registerGlobalFunction;


    /** Ensures that the supplied path has an object allocated in the global Infusion namespace, and retrieves the current value.
     * If no value is stored, a fresh {} will be assigned at the path, and to all currently empty paths leading to the global namespace root.
     * In a browser environment, the global Infusion namespace is rooted in the global `window`.
     * @param {String|String[]} path - The global path at which the namespace is to be allocated.
     * @param {Object} [env] - [optional] An environmental overlay object which will be consulted before any lookups in the global namespace.
     * @return {Any} Any current value held at the supplied path - or a freshly allocated {} to be held at that path if it was previously empty
     */
    fluid.registerNamespace = function (path, env) {
        env = env || fluid.environment;
        var existing = fluid.getGlobalValue(path, env);
        if (!existing) {
            existing = {};
            fluid.setGlobalValue(path, existing, env);
        }
        return existing;
    };

    // stubs for two functions in FluidDebugging.js
    fluid.dumpEl = fluid.identity;
    fluid.renderTimestamp = fluid.identity;

    /*** The Fluid instance id ***/

    // unsupported, NON-API function
    fluid.generateUniquePrefix = function () {
        return (Math.floor(Math.random() * 1e12)).toString(36) + "-";
    };

    var fluid_prefix = fluid.generateUniquePrefix();

    fluid.fluidInstance = fluid_prefix;

    var fluid_guid = 1;

    /** Allocate a string value that will be unique within this Infusion instance (frame or process), and
     * globally unique with high probability (50% chance of collision after a million trials)
     * @return {String} A fresh unique id
     */

    fluid.allocateGuid = function () {
        return fluid_prefix + (fluid_guid++);
    };

    /*** The Fluid Event system. ***/

    fluid.registerNamespace("fluid.event");

    // Fluid priority system for encoding relative positions of, e.g. listeners, transforms, options, in lists

    fluid.extremePriority = 4e9; // around 2^32 - allows headroom of 21 fractional bits for sub-priorities
    fluid.priorityTypes = {
        first: -1,
        last: 1,
        before: 0,
        after: 0
    };
    // TODO: This should be properly done with defaults blocks and a much more performant fluid.indexDefaults
    fluid.extremalPriorities = {
        // a built-in definition to allow test infrastructure "last" listeners to sort after all impl listeners, and authoring/debugging listeners to sort after those
        // these are "priority intensities", and will be flipped for "first" listeners
        none: 0,
        transaction: 10,
        testing: 20,
        authoring: 30
    };

    // unsupported, NON-API function
    // TODO: Note - no "fixedOnly = true" sites remain in the framework
    fluid.parsePriorityConstraint = function (constraint, fixedOnly, site) {
        var segs = constraint.split(":");
        var type = segs[0];
        var lookup = fluid.priorityTypes[type];
        if (lookup === undefined) {
            fluid.fail("Invalid constraint type in priority field " + constraint + ": the only supported values are " + fluid.keys(fluid.priorityTypes).join(", ") + " or numeric");
        }
        if (fixedOnly && lookup === 0) {
            fluid.fail("Constraint type in priority field " + constraint + " is not supported in a " + site + " record - you must use either a numeric value or first, last");
        }
        return {
            type: segs[0],
            target: segs[1]
        };
    };

    // unsupported, NON-API function
    fluid.parsePriority = function (priority, count, fixedOnly, site) {
        priority = priority || 0;
        var togo = {
            count: count || 0,
            fixed: null,
            constraint: null,
            site: site
        };
        if (typeof(priority) === "number") {
            togo.fixed = -priority;
        } else {
            togo.constraint = fluid.parsePriorityConstraint(priority, fixedOnly, site);
        }
        var multiplier = togo.constraint ? fluid.priorityTypes[togo.constraint.type] : 0;
        if (multiplier !== 0) {
            var target = togo.constraint.target || "none";
            var extremal = fluid.extremalPriorities[target];
            if (extremal === undefined) {
                fluid.fail("Unrecognised extremal priority target " + target + ": the currently supported values are " + fluid.keys(fluid.extremalPriorities).join(", ") + ": register your value in fluid.extremalPriorities");
            }
            togo.fixed = multiplier * (fluid.extremePriority + extremal);
        }
        if (togo.fixed !== null) {
            togo.fixed += togo.count / 1024; // use some fractional bits to encode count bias
        }

        return togo;
    };

    fluid.renderPriority = function (parsed) {
        return parsed.constraint ? (parsed.constraint.target ? parsed.constraint.type + ":" + parsed.constraint.target : parsed.constraint.type ) : Math.floor(parsed.fixed);
    };

    // unsupported, NON-API function
    fluid.compareByPriority = function (recA, recB) {
        if (recA.priority.fixed !== null && recB.priority.fixed !== null) {
            return recA.priority.fixed - recB.priority.fixed;
        } else { // sort constraint records to the end
            // relies on JavaScript boolean coercion rules (ECMA 9.3 toNumber)
            return (recA.priority.fixed === null) - (recB.priority.fixed === null);
        }
    };

    fluid.honourConstraint = function (array, firstConstraint, c) {
        var constraint = array[c].priority.constraint;
        var matchIndex = fluid.find(array, function (element, index) {
            return element.namespace === constraint.target ? index : undefined;
        }, -1);
        if (matchIndex === -1) { // TODO: We should report an error during firing if this condition persists until then
            return true;
        } else if (matchIndex >= firstConstraint) {
            return false;
        } else {
            var offset = constraint.type === "after" ? 1 : 0;
            var target = matchIndex + offset;
            var temp = array[c];
            for (var shift = c; shift >= target; --shift) {
                array[shift] = array[shift - 1];
            }
            array[target] = temp;
            return true;
        }
    };

    // unsupported, NON-API function
    // Priorities accepted from users have higher numbers representing high priority (sort first) -
    fluid.sortByPriority = function (array) {
        fluid.stableSort(array, fluid.compareByPriority);

        var firstConstraint = fluid.find(array, function (element, index) {
            return element.priority.constraint && fluid.priorityTypes[element.priority.constraint.type] === 0 ? index : undefined;
        }, array.length);

        while (true) {
            if (firstConstraint === array.length) {
                return array;
            }
            var oldFirstConstraint = firstConstraint;
            for (var c = firstConstraint; c < array.length; ++c) {
                var applied = fluid.honourConstraint(array, firstConstraint, c);
                if (applied) {
                    ++firstConstraint;
                }
            }
            if (firstConstraint === oldFirstConstraint) {
                var holders = array.slice(firstConstraint);
                fluid.fail("Could not find targets for any constraints in " + holders[0].priority.site + " ", holders, ": none of the targets (" + fluid.getMembers(holders, "priority.constraint.target").join(", ") +
                    ") matched any namespaces of the elements in (", array.slice(0, firstConstraint), ") - this is caused by either an invalid or circular reference");
            }
        }
    };

    /** Parse a hash containing prioritised records (for example, as found in a ContextAwareness record) and return a sorted array of these records in priority order.
     * @param {Object} records - A hash of key names to prioritised records. Each record may contain an member `namespace` - if it does not, the namespace will be taken from the
     * record's key. It may also contain a `String` member `priority` encoding a priority with respect to these namespaces as document at http://docs.fluidproject.org/infusion/development/Priorities.html .
     * @param {String} name - A human-readable name describing the supplied records, which will be incorporated into the message of any error encountered when resolving the priorities
     * @return {Array} An array of the same elements supplied to `records`, sorted into priority order. The supplied argument `records` will not be modified.
     */
    fluid.parsePriorityRecords = function (records, name) {
        var array = fluid.hashToArray(records, "namespace", function (newElement, oldElement) {
            $.extend(newElement, oldElement);
            newElement.priority = fluid.parsePriority(oldElement.priority, 0, false, name);
        });
        fluid.sortByPriority(array);
        return array;
    };

    fluid.event.identifyListener = function (listener, soft) {
        if (typeof(listener) !== "string" && !listener.$$fluid_guid && !soft) {
            listener.$$fluid_guid = fluid.allocateGuid();
        }
        return listener.$$fluid_guid;
    };

    // unsupported, NON-API function
    fluid.event.impersonateListener = function (origListener, newListener) {
        fluid.event.identifyListener(origListener);
        newListener.$$fluid_guid = origListener.$$fluid_guid;
    };


    // unsupported, NON-API function
    fluid.event.sortListeners = function (listeners) {
        var togo = [];
        fluid.each(listeners, function (oneNamespace) {
            var headHard; // notify only the first listener with hard namespace - or else all if all are soft
            for (var i = 0; i < oneNamespace.length; ++i) {
                var thisListener = oneNamespace[i];
                if (!thisListener.softNamespace && !headHard) {
                    headHard = thisListener;
                }
            }
            if (headHard) {
                togo.push(headHard);
            } else {
                togo = togo.concat(oneNamespace);
            }
        });
        return fluid.sortByPriority(togo);
    };

    // unsupported, NON-API function
    fluid.event.resolveListener = function (listener) {
        var listenerName = listener.globalName || (typeof(listener) === "string" ? listener : null);
        if (listenerName) {
            var listenerFunc = fluid.getGlobalValue(listenerName);
            if (!listenerFunc) {
                fluid.fail("Unable to look up name " + listenerName + " as a global function");
            } else {
                listener = listenerFunc;
            }
        }
        return listener;
    };

    /* Generate a name for a component for debugging purposes */
    fluid.nameComponent = function (that) {
        return that ? "component with typename " + that.typeName + " and id " + that.id : "[unknown component]";
    };

    fluid.event.nameEvent = function (that, eventName) {
        return eventName + " of " + fluid.nameComponent(that);
    };

    /** Construct an "event firer" object which can be used to register and deregister
     * listeners, to which "events" can be fired. These events consist of an arbitrary
     * function signature. General documentation on the Fluid events system is at
     * http://docs.fluidproject.org/infusion/development/InfusionEventSystem.html .
     * @param {Object} options - A structure to configure this event firer. Supported fields:
     *     {String} name - a readable name for this firer to be used in diagnostics and debugging
     *     {Boolean} preventable - If <code>true</code> the return value of each handler will
     * be checked for <code>false</code> in which case further listeners will be shortcircuited, and this
     * will be the return value of fire()
     * @return {Object} - The newly-created event firer.
     */
    fluid.makeEventFirer = function (options) {
        options = options || {};
        var name = options.name || "<anonymous>";
        var that;

        var lazyInit = function () { // Lazy init function to economise on object references for events which are never listened to
            // The authoritative list of all listeners, a hash indexed by namespace, looking up to a stack (array) of
            // listener records in "burial order"
            that.listeners = {};
            // An index of all listeners by "id" - we should consider removing this since it is only used during removal
            // and because that.listeners is a hash of stacks we can't really accelerate removal by much
            that.byId = {};
            // The "live" list of listeners which will be notified in order on any firing. Recomputed on any use of
            // addListener/removeListener
            that.sortedListeners = [];
            // arguments after 3rd are not part of public API
            // listener as Object is used only by ChangeApplier to tunnel path, segs, etc as part of its "spec"
            /** Adds a listener to this event.
             * @param {Function|String} listener - The listener function to be added, or a global name resolving to a function. The signature of the function is arbitrary and matches that sent to event.fire()
             * @param {String} namespace - (Optional) A namespace for this listener. At most one listener with a particular namespace can be active on an event at one time. Removing successively added listeners with a particular
             * namespace will expose previously added ones in a stack idiom
             * @param {String|Number} priority - A priority for the listener relative to others, perhaps expressed with a constraint relative to the namespace of another - see
             * http://docs.fluidproject.org/infusion/development/Priorities.html
             * @param {String} softNamespace - An unsupported internal option that is not part of the public API.
             * @param {String} listenerId - An unsupported internal option that is not part of the public API.
             */
            that.addListener = function (listener, namespace, priority, softNamespace, listenerId) {
                var record;
                if (that.destroyed) {
                    fluid.fail("Cannot add listener to destroyed event firer " + that.name);
                }
                if (!listener) {
                    return;
                }
                if (fluid.isPlainObject(listener, true) && !fluid.isApplicable(listener)) {
                    record = listener;
                    listener = record.listener;
                    namespace = record.namespace;
                    priority = record.priority;
                    softNamespace = record.softNamespace;
                    listenerId = record.listenerId;
                }
                if (typeof(listener) === "string") {
                    listener = {globalName: listener};
                }
                var id = listenerId || fluid.event.identifyListener(listener);
                namespace = namespace || id;
                record = $.extend(record || {}, {
                    namespace: namespace,
                    listener: listener,
                    softNamespace: softNamespace,
                    listenerId: listenerId,
                    priority: fluid.parsePriority(priority, that.sortedListeners.length, false, "listeners")
                });
                that.byId[id] = record;

                var thisListeners = (that.listeners[namespace] = fluid.makeArray(that.listeners[namespace]));
                thisListeners[softNamespace ? "push" : "unshift"] (record);

                that.sortedListeners = fluid.event.sortListeners(that.listeners);
            };
            that.addListener.apply(null, arguments);
        };
        that = {
            eventId: fluid.allocateGuid(),
            name: name,
            ownerId: options.ownerId,
            typeName: "fluid.event.firer",
            destroy: function () {
                that.destroyed = true;
            },
            addListener: function () {
                lazyInit.apply(null, arguments);
            },
            /** Removes a listener previously registered with this event.
              * @param {Function|String} toremove - Either the listener function, the namespace of a listener (in which case a previous listener with that namespace may be uncovered) or an id sent to the undocumented
              * `listenerId` argument of `addListener
              */
            // Can be supplied either listener, namespace, or id (which may match either listener function's guid or original listenerId argument)
            removeListener: function (listener) {
                if (!that.listeners) { return; }
                var namespace, id, record;
                if (typeof (listener) === "string") {
                    namespace = listener;
                    record = that.listeners[namespace];
                    if (!record) { // it was an id and not a namespace - take the namespace from its record later
                        id = namespace;
                        namespace = null;
                    }
                }
                else if (typeof(listener) === "function") {
                    id = fluid.event.identifyListener(listener, true);
                    if (!id) {
                        fluid.fail("Cannot remove unregistered listener function ", listener, " from event " + that.name);
                    }
                }
                var rec = that.byId[id];
                var softNamespace = rec && rec.softNamespace;
                namespace = namespace || (rec && rec.namespace) || id;
                delete that.byId[id];
                record = that.listeners[namespace];
                if (record) {
                    if (softNamespace) {
                        fluid.remove_if(record, function (thisLis) {
                            return thisLis.listener.$$fluid_guid === id || thisLis.listenerId === id;
                        });
                    } else {
                        record.shift();
                    }
                    if (record.length === 0) {
                        delete that.listeners[namespace];
                    }
                }
                that.sortedListeners = fluid.event.sortListeners(that.listeners);
            },
            /* Fires this event to all listeners which are active. They will be notified in order of priority. The signature of this method is free. */
            fire: function () {
                var listeners = that.sortedListeners;
                if (!listeners || that.destroyed) { return; }
                for (var i = 0; i < listeners.length; ++i) {
                    var lisrec = listeners[i];
                    if (typeof(lisrec.listener) !== "function") {
                        lisrec.listener = fluid.event.resolveListener(lisrec.listener);
                    }
                    var listener = lisrec.listener;
                    var ret = listener.apply(null, arguments);
                    var value;
                    if (options.preventable && ret === false || that.destroyed) {
                        value = false;
                    }
                    if (value !== undefined) {
                        return value;
                    }
                }
            }
        };
        return that;
    };

    // unsupported, NON-API function
    // Fires to an event which may not be instantiated (in which case no-op) - primary modern usage is to resolve FLUID-5904
    fluid.fireEvent = function (component, eventName, args) {
        var firer = component.events && component.events[eventName];
        if (firer) {
            firer.fire.apply(null, fluid.makeArray(args));
        }
    };

    // unsupported, NON-API function
    fluid.event.addListenerToFirer = function (firer, value, namespace, wrapper) {
        wrapper = wrapper || fluid.identity;
        if (fluid.isArrayable(value)) {
            for (var i = 0; i < value.length; ++i) {
                fluid.event.addListenerToFirer(firer, value[i], namespace, wrapper);
            }
        } else if (typeof (value) === "function" || typeof (value) === "string") {
            wrapper(firer).addListener(value, namespace);
        } else if (value && typeof (value) === "object") {
            wrapper(firer).addListener(value.listener, namespace || value.namespace, value.priority, value.softNamespace, value.listenerId);
        }
    };

    // unsupported, NON-API function - non-IOC passthrough
    fluid.event.resolveListenerRecord = function (records) {
        return { records: records };
    };

    fluid.expandImmediate = function (material) {
        fluid.fail("fluid.expandImmediate could not be loaded - please include FluidIoC.js in order to operate IoC-driven event with descriptor " + material);
    };

    // unsupported, NON-API function
    fluid.mergeListeners = function (that, events, listeners) {
        fluid.each(listeners, function (value, key) {
            var firer, namespace;
            if (fluid.isIoCReference(key)) {
                firer = fluid.expandImmediate(key, that);
                if (!firer) {
                    fluid.fail("Error in listener record: key " + key + " could not be looked up to an event firer - did you miss out \"events.\" when referring to an event firer?");
                }
            } else {
                var keydot = key.indexOf(".");

                if (keydot !== -1) {
                    namespace = key.substring(keydot + 1);
                    key = key.substring(0, keydot);
                }
                if (!events[key]) {
                    fluid.fail("Listener registered for event " + key + " which is not defined for this component");
                }
                firer = events[key];
            }
            var record = fluid.event.resolveListenerRecord(value, that, key, namespace, true);
            fluid.event.addListenerToFirer(firer, record.records, namespace, record.adderWrapper);
        });
    };

    // unsupported, NON-API function
    fluid.eventFromRecord = function (eventSpec, eventKey, that) {
        var isIoCEvent = eventSpec && (typeof (eventSpec) !== "string" || fluid.isIoCReference(eventSpec));
        var event;
        if (isIoCEvent) {
            if (!fluid.event.resolveEvent) {
                fluid.fail("fluid.event.resolveEvent could not be loaded - please include FluidIoC.js in order to operate IoC-driven event with descriptor ",
                    eventSpec);
            } else {
                event = fluid.event.resolveEvent(that, eventKey, eventSpec);
            }
        } else {
            event = fluid.makeEventFirer({
                name: fluid.event.nameEvent(that, eventKey),
                preventable: eventSpec === "preventable",
                ownerId: that.id
            });
        }
        return event;
    };

    // unsupported, NON-API function
    fluid.mergeListenerPolicy = function (target, source, key) {
        if (typeof (key) !== "string") {
            fluid.fail("Error in listeners declaration - the keys in this structure must resolve to event names - got " + key + " from ", source);
        }
        // cf. triage in mergeListeners
        var hasNamespace = !fluid.isIoCReference(key) && key.indexOf(".") !== -1;
        return hasNamespace ? (source || target) : fluid.arrayConcatPolicy(target, source);
    };

    // unsupported, NON-API function
    fluid.makeMergeListenersPolicy = function (merger, modelRelay) {
        return function (target, source) {
            target = target || {};
            if (modelRelay && (fluid.isArrayable(source) || typeof(source.target) === "string")) { // This form allowed for modelRelay
                target[""] = merger(target[""], source, "");
            } else {
                fluid.each(source, function (listeners, key) {
                    target[key] = merger(target[key], listeners, key);
                });
            }
            return target;
        };
    };

    fluid.validateListenersImplemented = function (that) {
        var errors = [];
        fluid.each(that.events, function (event, name) {
            fluid.each(event.sortedListeners, function (lisrec) {
                if (lisrec.listener === fluid.notImplemented || lisrec.listener.globalName === "fluid.notImplemented") {
                    errors.push({name: name, namespace: lisrec.namespace, componentSource: fluid.model.getSimple(that.options.listeners, [name + "." + lisrec.namespace, 0, "componentSource"])});
                }
            });
        });
        return errors;
    };

    fluid.arrayConcatPolicy = function (target, source) {
        return fluid.makeArray(target).concat(fluid.makeArray(source));
    };

    /*** FLUID LOGGING SYSTEM ***/

    // This event represents the process of resolving the action of a request to fluid.log. Each listener shares
    // access to an array, shallow-copied from the original arguments list to fluid.log, which is assumed writeable
    // and which they may splice, transform, etc. before it is dispatched to the listener with namespace "log" which
    // actually performs the logging action
    fluid.loggingEvent = fluid.makeEventFirer({name: "logging event"});

    fluid.addTimestampArg = function (args) {
        var arg0 = fluid.renderTimestamp(new Date()) + ":  ";
        args.unshift(arg0);
    };

    fluid.loggingEvent.addListener(fluid.doBrowserLog, "log");
    // Not intended to be overridden - just a positional placeholder so that the priority of
    // actions filtering the log arguments before dispatching may be referred to it
    fluid.loggingEvent.addListener(fluid.identity, "filterArgs", "before:log");
    fluid.loggingEvent.addListener(fluid.addTimestampArg, "addTimestampArg", "after:filterArgs");

    /*** FLUID ERROR SYSTEM ***/

    fluid.failureEvent = fluid.makeEventFirer({name: "failure event"});

    fluid.failureEvent.addListener(fluid.builtinFail, "fail");
    fluid.failureEvent.addListener(fluid.logFailure, "log", "before:fail");

    /**
     * This function is deprecated and will be removed in the FLUID-6148 release.
     * Configure the behaviour of fluid.fail by pushing or popping a disposition record onto a stack.
     * @param {Number|Function} condition - Supply either a function, which will be called with two arguments, args (the complete arguments to
     * fluid.fail) and activity, an array of strings describing the current framework invocation state.
     * Or, the argument may be the number <code>-1</code> indicating that the previously supplied disposition should
     * be popped off the stack
     */
    // Put this back until we can push a kettle upgrade through the stack
    fluid.pushSoftFailure = function (condition) {
        fluid.log(fluid.logLevel.WARN, "fluid.pushSoftFailure is deprecated and will be removed in the FLUID-6148 release");
        if (typeof (condition) === "function") {
            fluid.failureEvent.addListener(condition, "fail");
        } else if (condition === -1) {
            fluid.failureEvent.removeListener("fail");
        } else if (typeof(condition) === "boolean") {
            fluid.fail("pushSoftFailure with boolean value is no longer supported");
        }
    };

    /*** DEFAULTS AND OPTIONS MERGING SYSTEM ***/

    // A function to tag the types of all Fluid components
    fluid.componentConstructor = function () {};

    /** Create a "type tag" component with no state but simply a type name and id. The most
     *  minimal form of Fluid component */
    // No longer a publically supported function - we don't abolish this because it is too annoying to prevent
    // circularity during the bootup of the IoC system if we try to construct full components before it is complete
    // unsupported, non-API function
    fluid.typeTag = function (type, id) {
        var that = Object.create(fluid.componentConstructor.prototype);
        that.typeName = type;
        that.id = id || fluid.allocateGuid();
        return that;
    };

    var gradeTick = 1; // tick counter for managing grade cache invalidation
    var gradeTickStore = {};

    fluid.defaultsStore = {};

    // unsupported, NON-API function
    // Recursively builds up "gradeStructure" in first argument. 2nd arg receives gradeNames to be resolved, with stronger grades at right (defaults order)
    // builds up gradeStructure.gradeChain pushed from strongest to weakest (reverse defaults order)
    fluid.resolveGradesImpl = function (gs, gradeNames) {
        gradeNames = fluid.makeArray(gradeNames);
        for (var i = gradeNames.length - 1; i >= 0; --i) { // from stronger to weaker
            var gradeName = gradeNames[i];
            if (gradeName && !gs.gradeHash[gradeName]) {
                var isDynamic = fluid.isIoCReference(gradeName);
                var options = (isDynamic ? null : fluid.rawDefaults(gradeName)) || {};
                var thisTick = gradeTickStore[gradeName] || (gradeTick - 1); // a nonexistent grade is recorded as just previous to current
                gs.lastTick = Math.max(gs.lastTick, thisTick);
                gs.gradeHash[gradeName] = true;
                gs.gradeChain.push(gradeName);
                var oGradeNames = fluid.makeArray(options.gradeNames);
                for (var j = oGradeNames.length - 1; j >= 0; --j) { // from stronger to weaker grades
                    // TODO: in future, perhaps restore mergedDefaultsCache function of storing resolved gradeNames for bare grades
                    fluid.resolveGradesImpl(gs, oGradeNames[j]);
                }
            }
        }
        return gs;
    };

    // unsupported, NON-API function
    fluid.resolveGradeStructure = function (defaultName, gradeNames) {
        var gradeStruct = {
            lastTick: 0,
            gradeChain: [],
            gradeHash: {}
        };
        // stronger grades appear to the right in defaults - dynamic grades are stronger still - FLUID-5085
        // we supply these to resolveGradesImpl with strong grades at the right
        fluid.resolveGradesImpl(gradeStruct, [defaultName].concat(fluid.makeArray(gradeNames)));
        gradeStruct.gradeChain.reverse(); // reverse into defaults order
        return gradeStruct;
    };

    fluid.hasGrade = function (options, gradeName) {
        return !options || !options.gradeNames ? false : fluid.contains(options.gradeNames, gradeName);
    };

    // unsupported, NON-API function
    fluid.resolveGrade = function (defaults, defaultName, gradeNames) {
        var gradeStruct = fluid.resolveGradeStructure(defaultName, gradeNames);
        // TODO: Fault in the merging algorithm does not actually treat arguments as immutable - failure in FLUID-5082 tests
        // due to listeners mergePolicy
        var mergeArgs = fluid.transform(gradeStruct.gradeChain, fluid.rawDefaults, fluid.copy);
        fluid.remove_if(mergeArgs, function (options) {
            return !options;
        });
        var mergePolicy = {};
        for (var i = 0; i < mergeArgs.length; ++i) {
            if (mergeArgs[i] && mergeArgs[i].mergePolicy) {
                mergePolicy = $.extend(true, mergePolicy, mergeArgs[i].mergePolicy);
            }
        }
        mergeArgs = [mergePolicy, {}].concat(mergeArgs);
        var mergedDefaults = fluid.merge.apply(null, mergeArgs);
        mergedDefaults.gradeNames = gradeStruct.gradeChain; // replace these since mergePolicy version is inadequate
        fluid.freezeRecursive(mergedDefaults);
        return {defaults: mergedDefaults, lastTick: gradeStruct.lastTick};
    };

    fluid.mergedDefaultsCache = {};

    // unsupported, NON-API function
    fluid.gradeNamesToKey = function (defaultName, gradeNames) {
        return defaultName + "|" + gradeNames.join("|");
    };

    // unsupported, NON-API function
    // The main entry point to acquire the fully merged defaults for a combination of defaults plus mixin grades - from FluidIoC.js as well as recursively within itself
    fluid.getMergedDefaults = function (defaultName, gradeNames) {
        gradeNames = fluid.makeArray(gradeNames);
        var key = fluid.gradeNamesToKey(defaultName, gradeNames);
        var mergedDefaults = fluid.mergedDefaultsCache[key];
        if (mergedDefaults) {
            var lastTick = 0; // check if cache should be invalidated through real latest tick being later than the one stored
            var searchGrades = mergedDefaults.defaults.gradeNames;
            for (var i = 0; i < searchGrades.length; ++i) {
                lastTick = Math.max(lastTick, gradeTickStore[searchGrades[i]] || 0);
            }
            if (lastTick > mergedDefaults.lastTick) {
                if (fluid.passLogLevel(fluid.logLevel.TRACE)) {
                    fluid.log(fluid.logLevel.TRACE, "Clearing cache for component " + defaultName + " with gradeNames ", searchGrades);
                }
                mergedDefaults = null;
            }
        }
        if (!mergedDefaults) {
            var defaults = fluid.rawDefaults(defaultName);
            if (!defaults) {
                return defaults;
            }
            mergedDefaults = fluid.mergedDefaultsCache[key] = fluid.resolveGrade(defaults, defaultName, gradeNames);
        }
        return mergedDefaults.defaults;
    };

    // unsupported, NON-API function
    /** Upgrades an element of an IoC record which designates a function to prepare for a {func, args} representation.
     * @param {Any} rec - If the record is of a primitive type,
     * @param {String} key - The key in the returned record to hold the function, this will default to `funcName` if `rec` is a `string` *not*
     * holding an IoC reference, or `func` otherwise
     * @return {Object} The original `rec` if it was not of primitive type, else a record holding { key : rec } if it was of primitive type.
     */
    fluid.upgradePrimitiveFunc = function (rec, key) {
        if (rec && fluid.isPrimitive(rec)) {
            var togo = {};
            togo[key || (typeof(rec) === "string" && rec.charAt(0) !== "{" ? "funcName" : "func")] = rec;
            togo.args = fluid.NO_VALUE;
            return togo;
        } else {
            return rec;
        }
    };

    // unsupported, NON-API function
    // Modify supplied options record to include "componentSource" annotation required by FLUID-5082
    // TODO: This function really needs to act recursively in order to catch listeners registered for subcomponents - fix with FLUID-5614
    fluid.annotateListeners = function (componentName, options) {
        options.listeners = fluid.transform(options.listeners, function (record) {
            var togo = fluid.makeArray(record);
            return fluid.transform(togo, function (onerec) {
                onerec = fluid.upgradePrimitiveFunc(onerec, "listener");
                onerec.componentSource = componentName;
                return onerec;
            });
        });
        options.invokers = fluid.transform(options.invokers, function (record) {
            record = fluid.upgradePrimitiveFunc(record);
            if (record) {
                record.componentSource = componentName;
            }
            return record;
        });
    };

    // Key structure: [["local"|"global"], workflowName] to {workflowType, priority, workflowOptions, gradeName, index}===workflowEntry
    fluid.workflowCache = {};
    // Sorted array of workflowEntry
    fluid.workflowCacheSorted = [];

    fluid.resortWorkflows = function (workflowType, baseIndex) {
        var thisCache = fluid.workflowCache[workflowType];
        var parsed = fluid.parsePriorityRecords(thisCache, workflowType + " workflows");
        parsed.forEach(function (oneParsed, index) {
            thisCache[oneParsed.namespace].index = index + baseIndex;
        });
        return parsed;
    };

    fluid.indexOneWorkflows = function (gradeName, workflowType, workflows, baseIndex) {
        fluid.each(workflows, function (oneWorkflow, workflowKey) {
            fluid.model.setSimple(fluid.workflowCache, [workflowType, workflowKey], {
                workflowType: workflowType,
                workflowName: workflowKey,
                priority: oneWorkflow.priority,
                gradeName: gradeName,
                workflowOptions: oneWorkflow
            });
        });
        return fluid.resortWorkflows(workflowType, baseIndex);
    };

    fluid.clearGradeWorkflows = function (gradeName, workflowType) {
        var cacheForType = fluid.workflowCache[workflowType];
        fluid.each(cacheForType, function (oneWorkflow, workflowKey) {
            if (oneWorkflow.gradeName === gradeName) {
                delete cacheForType[workflowKey];
            }
        });
    };

    fluid.indexGradeWorkflows = function (gradeName, options) {
        fluid.clearGradeWorkflows(gradeName, "global");
        fluid.clearGradeWorkflows(gradeName, "local");
        var sortedGlobal = fluid.indexOneWorkflows(gradeName, "global", fluid.getImmediate(options, ["workflows", "global"]), 0);
        var globalWorkflowCount = sortedGlobal.length;
        var sortedLocal = fluid.indexOneWorkflows(gradeName, "local", fluid.getImmediate(options, ["workflows", "local"]), globalWorkflowCount);
        fluid.workflowCacheSorted = sortedGlobal.concat(sortedLocal);
    };

    // unsupported, NON-API function
    fluid.rawDefaults = function (componentName) {
        var entry = fluid.defaultsStore[componentName];
        return entry && entry.options;
    };

    // unsupported, NON-API function
    fluid.registerRawDefaults = function (componentName, options) {
        fluid.pushActivity("registerRawDefaults", "registering defaults for grade %componentName with options %options",
            {componentName: componentName, options: options});
        var optionsCopy = fluid.expandCompact ? fluid.expandCompact(options) : fluid.copy(options);
        fluid.annotateListeners(componentName, optionsCopy);
        // TODO: consider moving workflows outside fluid.defaults system entirely since we special-case them so much
        fluid.indexGradeWorkflows(componentName, optionsCopy);
        delete optionsCopy.workflows;
        var callerInfo = fluid.getCallerInfo && fluid.getCallerInfo(6);
        fluid.freezeRecursive(optionsCopy);
        fluid.defaultsStore[componentName] = {
            options: optionsCopy,
            callerInfo: callerInfo
        };
        gradeTickStore[componentName] = gradeTick++;
        fluid.popActivity();
    };

    // unsupported, NON-API function
    fluid.doIndexDefaults = function (defaultName, defaults, index, indexSpec) {
        var requiredGrades = fluid.makeArray(indexSpec.gradeNames);
        for (var i = 0; i < requiredGrades.length; ++i) {
            if (!fluid.hasGrade(defaults, requiredGrades[i])) { return; }
        }
        var indexFunc = typeof(indexSpec.indexFunc) === "function" ? indexSpec.indexFunc : fluid.getGlobalValue(indexSpec.indexFunc);
        var keys = indexFunc(defaults) || [];
        for (var j = 0; j < keys.length; ++j) {
            fluid.pushArray(index, keys[j], defaultName);
        }
    };

    /** Evaluates an index specification over all the defaults records registered into the system.
     * @param {String} indexName - The name of this index record (currently ignored)
     * @param {Object} indexSpec - Specification of the index to be performed - fields:
     *     gradeNames: {String|String[]} List of grades that must be matched by this indexer
     *     indexFunc:  {String|Function} An index function which accepts a defaults record and returns an array of keys
     * @return A structure indexing keys to arrays of matched gradenames
     */
    // The expectation is that this function is extremely rarely used with respect to registration of defaults
    // in the system, so currently we do not make any attempts to cache the results. The field "indexName" is
    // supplied in case a future implementation chooses to implement caching
    fluid.indexDefaults = function (indexName, indexSpec) {
        var index = {};
        for (var defaultName in fluid.defaultsStore) {
            var defaults = fluid.getMergedDefaults(defaultName);
            fluid.doIndexDefaults(defaultName, defaults, index, indexSpec);
        }
        return index;
    };

    /**
     * Retrieves and stores a grade's configuration centrally.
     * @param {String} componentName - The name of the grade whose options are to be read or written
     * @param {Object} [options] - An (optional) object containing the options to be set
     * @return {Object|undefined} - If `options` is omitted, returns the defaults for `componentName`.  Otherwise,
     * creates an instance of the named component with the supplied options.
     */
    fluid.defaults = function (componentName, options) {
        if (options === undefined) {
            return fluid.getMergedDefaults(componentName);
        }
        else {
            if (options && options.options) {
                fluid.fail("Probable error in options structure for " + componentName +
                    " with option named \"options\" - perhaps you meant to write these options at top level in fluid.defaults? - ", options);
            }
            fluid.registerRawDefaults(componentName, options);
            var gradedDefaults = fluid.getMergedDefaults(componentName);
            if (!fluid.hasGrade(gradedDefaults, "fluid.function")) {
                fluid.makeComponentCreator(componentName);
            }
        }
    };

    fluid.validateCreatorGrade = function (message, componentName) {
        var defaults = fluid.getMergedDefaults(componentName);
        if (!defaults || !defaults.gradeNames || defaults.gradeNames.length === 0) {
            fluid.fail(message + " type " + componentName + " which does not have any gradeNames defined");
        } else if (!defaults.argumentMap) {
            var blankGrades = [];
            for (var i = 0; i < defaults.gradeNames.length; ++i) {
                var gradeName = defaults.gradeNames[i];
                var rawDefaults = fluid.rawDefaults(gradeName);
                if (!rawDefaults) {
                    blankGrades.push(gradeName);
                }
            }
            if (blankGrades.length === 0) {
                fluid.fail(message + " type " + componentName + " which is not derived from fluid.component");
            } else {
                fluid.fail("The grade hierarchy of component with type " + componentName + " is incomplete - it inherits from the following grade(s): " +
                 blankGrades.join(", ") + " for which the grade definitions are corrupt or missing. Please check the files which might include these " +
                 "grades and ensure they are readable and have been loaded by this instance of Infusion");
            }
        }
    };

    fluid.makeComponentCreator = function (componentName) {
        var creator = function () {
            fluid.validateCreatorGrade("Cannot make component creator for", componentName);
            return fluid.initFreeComponent(componentName, arguments);
        };
        var existing = fluid.getGlobalValue(componentName);
        if (existing) {
            $.extend(creator, existing);
        }
        fluid.setGlobalValue(componentName, creator);
    };

    fluid.emptyPolicy = fluid.freezeRecursive({});
    /** Dereference an element of a `CompiledMergePolicy` armoured with the `*` key, ensuring to return an object
     * which can be tested for mergePolicy properties such as `replace` without failure. This function always returns
     * an object even if `policy` or `policy.*` is empty.
     * @param {Object} policy - A trunk member of a `CompiledMergePolicy`
     * @return {Object} A leaf object which can be property-tested for a builtin mergePolicy.
     */
    // unsupported, NON-API function
    fluid.derefMergePolicy = function (policy) {
        return (policy ? policy["*"] : fluid.emptyPolicy) || fluid.emptyPolicy;
    };

    /** @typedef {Object} CompiledMergePolicyReturn
     * @property {Object} defaultValues - An map of options paths to IoC references holding the path elsewhere within
     *    the options structure from where the default value for them is to be taken
     * @property {CompiledMergePolicy} builtins - A structure isomorphic to the options structure, with node-specific
     *    metadata held in a leaf child named "*". This metadata holds a map of builtin mergePolicies to "*" as well
     *    as possibly a function member named `func`.
     * @property {Boolean} [hasDefaults] - `true` if the `defaultValues` object has any members
     */

    /** Accepts a mergePolicy as encoded in a component's options and outputs a "compiled" variant which is more suited
     * to random structure-directed access. This is isomorphic to the options structure itself, with node-specific metadata
     * housed in a leaf child named "*". Function policies will be attached to a leaf member named `func`, and
     * "default value merge policies" (references to other option paths) will be converted into IoC self-references
     * beginning with `{that}.options`.
     * @param {Object} mergePolicy - The `mergePolicy` options area of a component
     * @return {CompiledMergePolicyReturn} - Holds members:
     * A CompiledMergePolicy object housing the "compiled" rendering of the merge policy, in the member `builtins` and
     * any dereferenced default value policies in the member `defaultValues`
     */
    // Main entry point is in fluid.mergeComponentOptions
    // Note that there is currently no support for other than flat mergePolicies
    // unsupported, NON-API function
    fluid.compileMergePolicy = function (mergePolicy) {
        var builtins = {}, defaultValues = {};
        var togo = {builtins: builtins, defaultValues: defaultValues};

        if (!mergePolicy) {
            return togo;
        }
        fluid.each(mergePolicy, function (value, key) {
            var parsed = {}, builtin = true;
            if (typeof(value) === "function") {
                parsed.func = value;
            }
            else if (typeof(value) === "object") {
                parsed = value;
            }
            else if (!fluid.isDefaultValueMergePolicy(value)) {
                var split = value.split(/\s*,\s*/);
                for (var i = 0; i < split.length; ++i) {
                    parsed[split[i]] = true;
                }
            }
            else {
                // Convert to ginger self-reference - NB, this can only be parsed by IoC
                fluid.set(defaultValues, key, "{that}.options." + value);
                togo.hasDefaults = true;
                builtin = false;
            }
            if (builtin) {
                fluid.set(builtins, fluid.composePath(key, "*"), parsed);
            }
        });
        return togo;
    };

    // TODO: deprecate this method of detecting default value merge policies before 1.6 in favour of
    // explicit typed records a la ModelTransformations
    // unsupported, NON-API function
    fluid.isDefaultValueMergePolicy = function (policy) {
        return typeof(policy) === "string" &&
            (policy.indexOf(",") === -1 && !/replace|nomerge|noexpand/.test(policy));
    };

    // unsupported, NON-API function
    fluid.mergeOneImpl = function (thisTarget, thisSource, j, sources, newPolicy, newPolicyHolder, i, segs) {
        var togo = thisTarget;

        var primitiveTarget = fluid.isPrimitive(thisTarget);

        if (thisSource !== undefined) {
            if (!newPolicy.func && thisSource !== null && fluid.isPlainObject(thisSource) && !newPolicy.nomerge) {
                if (primitiveTarget) {
                    togo = thisTarget = fluid.freshContainer(thisSource);
                }
                // recursion is now external? We can't do it from here since sources are not all known
                // options.recurse(thisTarget, i + 1, segs, sources, newPolicyHolder, options);
            } else {
                sources[j] = undefined;
                if (newPolicy.func) {
                    togo = newPolicy.func.call(null, thisTarget, thisSource, newPolicyHolder, segs, i);
                } else {
                    togo = thisSource;
                }
            }
        }
        return togo;
    };
    // NB - same quadratic worry about these as in FluidIoC in the case the RHS trundler is live -
    // since at each regeneration step driving the RHS we are discarding the "cursor arguments" these
    // would have to be regenerated at each step - although in practice this can only happen once for
    // each object for all time, since after first resolution it will be concrete.
    function regenerateCursor(source, segs, limit, sourceStrategy) {
        for (var i = 0; i < limit; ++i) {
            source = sourceStrategy(source, segs[i], i, fluid.makeArray(segs)); // copy for FLUID-5243
        }
        return source;
    }

    function regenerateSources(sources, segs, limit, sourceStrategies) {
        var togo = [];
        for (var i = 0; i < sources.length; ++i) {
            var thisSource = regenerateCursor(sources[i], segs, limit, sourceStrategies[i]);
            if (thisSource !== undefined) {
                togo.push(thisSource);
            }
        }
        return togo;
    }

    // unsupported, NON-API function
    fluid.fetchMergeChildren = function (target, i, segs, sources, mergePolicy, options) {
        var thisPolicy = fluid.derefMergePolicy(mergePolicy);
        for (var j = sources.length - 1; j >= 0; --j) { // this direction now irrelevant - control is in the strategy
            var source = sources[j];
            // NB - this detection relies on strategy return being complete objects - which they are
            // although we need to set up the roots separately. We need to START the process of evaluating each
            // object root (sources) COMPLETELY, before we even begin! Even if the effect of this is to cause a
            // dispatch into ourselves almost immediately. We can do this because we can take control over our
            // TARGET objects and construct them early. Even if there is a self-dispatch, it will be fine since it is
            // DIRECTED and so will not trouble our "slow" detection of properties. After all self-dispatches end, control
            // will THEN return to "evaluation of arguments" (expander blocks) and only then FINALLY to this "slow"
            // traversal of concrete properties to do the final merge.
            if (source !== undefined) {
                fluid.each(source, function (newSource, name) {
                    var childPolicy = fluid.concreteTrundler(mergePolicy, name);
                    // 2nd arm of condition is an Outrageous bodge to fix FLUID-4930 further. See fluid.tests.retrunking in FluidIoCTests.js
                    // We make extra use of the old "evaluateFully" flag and ensure to flood any trunk objects again during final "initter" phase of merging.
                    // The problem is that a custom mergePolicy may have replaced the system generated trunk with a differently structured object which we must not
                    // corrupt. This work should properly be done with a set of dedicated provenance/progress records in a separate structure
                    if (!(name in target) || (options.evaluateFully && childPolicy === undefined && !fluid.isPrimitive(target[name]))) { // only request each new target key once -- all sources will be queried per strategy
                        segs[i] = name;
                        options.strategy(target, name, i + 1, segs, sources, mergePolicy);
                    }
                });
                if (thisPolicy.replace) { // this branch primarily deals with a policy of replace at the root
                    break;
                }
            }
        }
        return target;
    };

    // A special marker object which will be placed at a current evaluation point in the tree in order
    // to protect against circular evaluation
    fluid.inEvaluationMarker = Object.freeze({"__CURRENTLY_IN_EVALUATION__": true});

    // A path depth above which the core "process strategies" will bail out, assuming that the
    // structure has become circularly linked. Helpful in environments such as Firebug which will
    // kill the browser process if they happen to be open when a stack overflow occurs. Also provides
    // a more helpful diagnostic.
    fluid.strategyRecursionBailout = 50;

    // unsupported, NON-API function
    fluid.makeMergeStrategy = function (options) {
        var strategy = function (target, name, i, segs, sources, policy) {
            if (i > fluid.strategyRecursionBailout) {
                fluid.fail("Overflow/circularity in options merging, current path is ", segs, " at depth " , i, " - please protect components from merging using the \"nomerge\" merge policy");
            }
            if (fluid.isPrimitive(target)) { // For "use strict"
                return undefined; // Review this after FLUID-4925 since the only trigger is in slow component lookahead
            }
            if (fluid.isTracing) {
                fluid.tracing.pathCount.push(fluid.path(segs.slice(0, i)));
            }

            var oldTarget;
            if (name in target) { // bail out if our work has already been done
                oldTarget = target[name];
                if (!options.evaluateFully) { // see notes on this hack in "initter" - early attempt to deal with FLUID-4930
                    return oldTarget;
                }
            }
            else {
                if (target !== fluid.inEvaluationMarker) { // TODO: blatant "coding to the test" - this enables the simplest "re-trunking" in
                    // FluidIoCTests to function. In practice, we need to throw away this implementation entirely in favour of the
                    // "iterative deepening" model coming with FLUID-4925
                    target[name] = fluid.inEvaluationMarker;
                }
            }
            if (sources === undefined) { // recover our state in case this is an external entry point
                segs = fluid.makeArray(segs); // avoid trashing caller's segs
                sources = regenerateSources(options.sources, segs, i - 1, options.sourceStrategies);
                policy = regenerateCursor(options.mergePolicy, segs, i - 1, fluid.concreteTrundler);
            }
            var newPolicyHolder = fluid.concreteTrundler(policy, name);
            var newPolicy = fluid.derefMergePolicy(newPolicyHolder);

            var start, limit, mul;
            if (newPolicy.replace) {
                start = 1 - sources.length; limit = 0; mul = -1;
            }
            else {
                start = 0; limit = sources.length - 1; mul = +1;
            }
            var newSources = [];
            var thisTarget;

            for (var j = start; j <= limit; ++j) { // TODO: try to economise on this array and on gaps
                var k = mul * j;
                var thisSource = options.sourceStrategies[k](sources[k], name, i, segs); // Run the RH algorithm in "driving" mode
                if (thisSource !== undefined) {
                    if (!fluid.isPrimitive(thisSource)) {
                        newSources[k] = thisSource;
                    }
                    if (oldTarget === undefined) {
                        if (mul === -1) { // if we are going backwards, it is "replace"
                            thisTarget = target[name] = thisSource;
                            break;
                        }
                        else {
                            // write this in early, since early expansions may generate a trunk object which is written in to by later ones
                            thisTarget = fluid.mergeOneImpl(thisTarget, thisSource, j, newSources, newPolicy, newPolicyHolder, i, segs, options);
                            if (target !== fluid.inEvaluationMarker) {
                                target[name] = thisTarget;
                            }
                        }
                    }
                }
            }
            if (oldTarget !== undefined) {
                thisTarget = oldTarget;
            }
            if (newSources.length > 0) {
                if (fluid.isPlainObject(thisTarget)) {
                    fluid.fetchMergeChildren(thisTarget, i, segs, newSources, newPolicyHolder, options);
                }
            }
            if (oldTarget === undefined && newSources.length === 0) {
                delete target[name]; // remove the evaluation marker - nothing to evaluate
            }
            return thisTarget;
        };
        options.strategy = strategy;
        return strategy;
    };

    // A simple stand-in for "fluid.get" where the material is covered by a single strategy
    fluid.driveStrategy = function (root, pathSegs, strategy) {
        pathSegs = fluid.makeArray(pathSegs);
        for (var i = 0; i < pathSegs.length; ++i) {
            if (!root) {
                return undefined;
            }
            root = strategy(root, pathSegs[i], i + 1, pathSegs);
        }
        return root;
    };

    // A very simple "new inner trundler" that just performs concrete property access
    // Note that every "strategy" is also a "trundler" of this type, considering just the first two arguments
    fluid.concreteTrundler = function (source, seg) {
        return !source ? undefined : source[seg];
    };

    /** Merge a collection of options structures onto a target, following an optional policy.
     * This method is now used only for the purpose of merging "dead" option documents in order to
     * cache graded component defaults. Component option merging is now performed by the
     * fluid.makeMergeOptions pathway which sets up a deferred merging process. This function
     * will not be removed in the Fluid 2.0 release but it is recommended that users not call it
     * directly.
     * The behaviour of this function is explained more fully on
     * the page http://wiki.fluidproject.org/display/fluid/Options+Merging+for+Fluid+Components .
     * @param {Object|String} policy - A "policy object" specifiying the type of merge to be performed.
     * If policy is of type {String} it should take on the value "replace" representing
     * a static policy. If it is an
     * Object, it should contain a mapping of EL paths onto these String values, representing a
     * fine-grained policy. If it is an Object, the values may also themselves be EL paths
     * representing that a default value is to be taken from that path.
     * @param {...Object} options1, options2, .... - an arbitrary list of options structure which are to
     * be merged together. These will not be modified.
     */

    fluid.merge = function (policy /*, ... sources */) {
        var sources = Array.prototype.slice.call(arguments, 1);
        var compiled = fluid.compileMergePolicy(policy).builtins;
        var options = fluid.makeMergeOptions(compiled, sources, {});
        options.initter();
        return options.target;
    };

    /** Construct the core of the `mergeOptions` structure responsible for evaluating merged options.
     * This will eventually be housed in the shadow as `shadow.mergeOptions`.
     * The main entry point is `fluid.mergeComponentOptions` which will add other elements such as `mergeBlocks`
     */
    // unsupported, NON-API function
    fluid.makeMergeOptions = function (policy, sources, userOptions) {
        // note - we close over the supplied policy as a shared object reference - it will be updated during discovery
        var options = {
            mergePolicy: policy,
            sources: sources
        };
        options = $.extend(options, userOptions);
        options.target = options.target || fluid.freshContainer(options.sources[0]);
        options.sourceStrategies = options.sourceStrategies || fluid.generate(options.sources.length, fluid.concreteTrundler);
        options.initter = function () {
            // This hack is necessary to ensure that the FINAL evaluation doesn't balk when discovering a trunk path which was already
            // visited during self-driving via the expander. This bi-modality is sort of rubbish, but we currently don't have "room"
            // in the strategy API to express when full evaluation is required - and the "flooding API" is not standardised. See FLUID-4930
            options.evaluateFully = true;
            fluid.fetchMergeChildren(options.target, 0, [], options.sources, options.mergePolicy, options);
        };
        fluid.makeMergeStrategy(options);
        return options;
    };

    // unsupported, NON-API function
    fluid.transformOptions = function (options, transRec) {
        fluid.expect("Options transformation record", transRec, ["transformer", "config"]);
        var transFunc = fluid.getGlobalValue(transRec.transformer);
        return transFunc.call(null, options, transRec.config);
    };

    // unsupported, NON-API function
    fluid.findMergeBlocks = function (mergeBlocks, recordType) {
        return fluid.remove_if(fluid.makeArray(mergeBlocks), function (block) { return block.recordType !== recordType; });
    };

    // unsupported, NON-API function
    fluid.transformOptionsBlocks = function (mergeBlocks, transformOptions, recordTypes) {
        fluid.each(recordTypes, function (recordType) {
            var blocks = fluid.findMergeBlocks(mergeBlocks, recordType);
            fluid.each(blocks, function (block) {
                var source = block.source ? "source" : "target"; // TODO: Problem here with irregular presentation of options which consist of a reference in their entirety
                block[block.simple || source === "target" ? "target" : "source"] = fluid.transformOptions(block[source], transformOptions);
            });
        });
    };

    // unsupported, NON-API function
    fluid.dedupeDistributionNamespaces = function (mergeBlocks) { // to implement FLUID-5824
        var byNamespace = {};
        fluid.remove_if(mergeBlocks, function (mergeBlock) {
            var ns = mergeBlock.namespace;
            if (ns) {
                if (byNamespace[ns] && byNamespace[ns] !== mergeBlock.contextThat.id) {  // source check for FLUID-5835
                    return true;
                } else {
                    byNamespace[ns] = mergeBlock.contextThat.id;
                }
            }
        });
    };

    // The types of merge record the system supports, with the weakest records first
    fluid.mergeRecordTypes = {
        defaults:           1000,
        defaultValueMerge:  900,
        lensedComponents:    800,
        subcomponentRecord: 700,
        user:               600,
        distribution:       100 // and above
    };

    // Utility used in the framework (primarily with distribution assembly), unconnected with new ChangeApplier
    // unsupported, NON-API function
    fluid.model.applyChangeRequest = function (model, request) {
        var segs = request.segs;
        if (segs.length === 0) {
            if (request.type === "ADD") {
                $.extend(true, model, request.value);
            } else {
                fluid.clear(model);
            }
        } else if (request.type === "ADD") {
            fluid.model.setSimple(model, request.segs, request.value);
        } else {
            for (var i = 0; i < segs.length - 1; ++i) {
                model = model[segs[i]];
                if (!model) {
                    return;
                }
            }
            var last = fluid.peek(segs);
            delete model[last];
        }
    };

    /** Delete the value in the supplied object held at the specified path
     * @param {Object} target - The object holding the value to be deleted (possibly empty)
     * @param {String[]} segs - the path of the value to be deleted
     */
    // unsupported, NON-API function
    fluid.destroyValue = function (target, segs) {
        if (target) {
            fluid.model.applyChangeRequest(target, {type: "DELETE", segs: segs});
        }
    };

    /**
     * Merges the component's declared defaults, as obtained from fluid.defaults(),
     * with the user's specified overrides.
     *
     * @param {Component} that - The instance to attach the options to
     * @param {Potentia} potentia - The potentia record supplied for this construction
     * @param {MergeRecords} lightMerge - A structure as produced from `fluid.lightMergeRecords` performing light pre-merging of
     * options records
     * @return {MergeOptions} The mergeOptions structure ready to be mounted in the component's shadow
     */
    // unsupported, NON-API function
    fluid.mergeComponentOptions = function (that, potentia, lightMerge) {
        fluid.validateCreatorGrade("Cannot construct component of", lightMerge.type);
        var sharedMergePolicy = {};

        // FROM HERE we notify the instantiator, fabricate destroy, etc.
        var mergeBlocks = fluid.expandComponentOptions(sharedMergePolicy, potentia, lightMerge, that);

        var options = {}; // ultimate target
        var sourceStrategies = [], sources = [];
        var baseMergeOptions = {
            target: options,
            sourceStrategies: sourceStrategies
        };
        // Called both from here and from IoC whenever there is a change of block content or arguments which
        // requires them to be resorted and rebound
        var updateBlocks = function () {
            fluid.each(mergeBlocks, function (block) {
                if (fluid.isPrimitive(block.priority)) {
                    block.priority = fluid.parsePriority(block.priority, 0, false, "options distribution");
                }
            });
            fluid.sortByPriority(mergeBlocks);
            fluid.dedupeDistributionNamespaces(mergeBlocks);
            sourceStrategies.length = 0;
            sources.length = 0;
            fluid.each(mergeBlocks, function (block) {
                sourceStrategies.push(block.strategy);
                sources.push(block.target);
            });
        };
        updateBlocks();
        var mergeOptions = fluid.makeMergeOptions(sharedMergePolicy, sources, baseMergeOptions);
        mergeOptions.mergeBlocks = mergeBlocks;
        mergeOptions.updateBlocks = updateBlocks;
        mergeOptions.destroyValue = function (segs) { // This method is a temporary hack to assist FLUID-5091
            for (var i = 0; i < mergeBlocks.length; ++i) {
                if (!mergeBlocks[i].immutableTarget) {
                    fluid.destroyValue(mergeBlocks[i].target, segs);
                }
            }
            fluid.destroyValue(baseMergeOptions.target, segs);
        };

        var compiledPolicy;
        var mergePolicy;
        function computeMergePolicy() {
            // Decode the now available mergePolicy
            mergePolicy = fluid.driveStrategy(options, "mergePolicy", mergeOptions.strategy);
            mergePolicy = $.extend({}, fluid.rootMergePolicy, mergePolicy);
            compiledPolicy = fluid.compileMergePolicy(mergePolicy);
            // TODO: expandComponentOptions has already put some builtins here - performance implications of the now huge
            // default mergePolicy material need to be investigated as well as this deep merge
            $.extend(true, sharedMergePolicy, compiledPolicy.builtins); // ensure it gets broadcast to all sharers
        }
        computeMergePolicy();
        mergeOptions.computeMergePolicy = computeMergePolicy;

        if (compiledPolicy.hasDefaults) {
            mergeBlocks.push(fluid.generateExpandBlock({
                options: compiledPolicy.defaultValues,
                recordType: "defaultValueMerge",
                priority: fluid.mergeRecordTypes.defaultValueMerge
            }, that, {}));
            updateBlocks();
        }
        that.options = options;
        fluid.driveStrategy(options, "gradeNames", mergeOptions.strategy);

        fluid.deliverOptionsStrategy(that, options, mergeOptions); // do this early to broadcast and receive "distributeOptions"

        fluid.computeComponentAccessor(that, potentia.localRecord);

        var transformOptions = fluid.driveStrategy(options, "transformOptions", mergeOptions.strategy);
        if (transformOptions) {
            fluid.transformOptionsBlocks(mergeBlocks, transformOptions, ["user", "subcomponentRecord"]);
            updateBlocks(); // because the possibly simple blocks may have changed target
        }

        if (!baseMergeOptions.target.mergePolicy) {
            computeMergePolicy();
        }

        return mergeOptions;
    };

    // The Fluid Component System proper

    // The base system grade definitions

    fluid.defaults("fluid.function", {});

    /** Invoke a global function by name and named arguments. A courtesy to allow declaratively encoded function calls
     * to use named arguments rather than bare arrays.
     * @param {String} name - A global name which can be resolved to a Function. The defaults for this name must
     * resolve onto a grade including "fluid.function". The defaults record should also contain an entry
     * <code>argumentMap</code>, a hash of argument names onto indexes.
     * @param {Object} spec - A named hash holding the argument values to be sent to the function. These will be looked
     * up in the <code>argumentMap</code> and resolved into a flat list of arguments.
     * @return {Any} The return value from the function
     */
    fluid.invokeGradedFunction = function (name, spec) {
        var defaults = fluid.defaults(name);
        if (!defaults || !defaults.argumentMap || !fluid.hasGrade(defaults, "fluid.function")) {
            fluid.fail("Cannot look up name " + name +
                " to a function with registered argumentMap - got defaults ", defaults);
        }
        var args = [];
        fluid.each(defaults.argumentMap, function (value, key) {
            args[value] = spec[key];
        });
        return fluid.invokeGlobalFunction(name, args);
    };

    fluid.noNamespaceDistributionPrefix = "no-namespace-distribution-";

    fluid.mergeOneDistribution = function (target, source, key) {
        var namespace = source.namespace || key || fluid.noNamespaceDistributionPrefix + fluid.allocateGuid();
        source.namespace = namespace;
        target[namespace] = $.extend(true, {}, target[namespace], source);
    };

    fluid.distributeOptionsPolicy = function (target, source) {
        target = target || {};
        if (fluid.isArrayable(source)) {
            for (var i = 0; i < source.length; ++i) {
                fluid.mergeOneDistribution(target, source[i]);
            }
        } else if (typeof(source.target) === "string") {
            fluid.mergeOneDistribution(target, source);
        } else {
            fluid.each(source, function (oneSource, key) {
                fluid.mergeOneDistribution(target, oneSource, key);
            });
        }
        return target;
    };

    fluid.mergingArray = function () {};
    fluid.mergingArray.prototype = [];

    // Defer all evaluation of all nested members to hack FLUID-5668
    fluid.deferringMergePolicy = function (target, source, mergePolicyHolder) {
        target = target || {};
        fluid.each(source, function (oneSource, key) {
            if (!target[key]) {
                target[key] = new fluid.mergingArray();
            }
            if (fluid.derefMergePolicy(mergePolicyHolder[key]).replace) {
                target[key].length = 0;
            }
            if (oneSource instanceof fluid.mergingArray) {
                target[key].push.apply(target[key], oneSource);
            } else if (oneSource !== undefined) {
                target[key].push(oneSource);
            }
        });
        return target;
    };

    fluid.invokerStrategies = fluid.arrayToHash(["func", "funcName", "listener", "this", "method", "changePath", "value"]);

    // Resolve FLUID-5741, FLUID-5184 by ensuring that we avoid mixing incompatible invoker strategies
    fluid.invokersMergePolicy = function (target, source) {
        target = target || {};
        fluid.each(source, function (oneInvoker, name) {
            if (!oneInvoker) {
                target[name] = oneInvoker;
                return;
            } else {
                oneInvoker = fluid.upgradePrimitiveFunc(oneInvoker);
            }
            var oneT = target[name];
            if (!oneT) {
                oneT = target[name] = {};
            }
            for (var key in fluid.invokerStrategies) {
                if (key in oneInvoker) {
                    for (var key2 in fluid.invokerStrategies) {
                        oneT[key2] = undefined; // can't delete since stupid driveStrategy bug from recordStrategy reinstates them
                    }
                }
            }
            $.extend(oneT, oneInvoker);
        });
        return target;
    };

    fluid.rootMergePolicy = fluid.freezeRecursive({
        gradeNames: fluid.arrayConcatPolicy,
        distributeOptions: fluid.distributeOptionsPolicy,
        members: {
            noexpand: true,
            func: fluid.deferringMergePolicy
        },
        invokers: {
            noexpand: true,
            func: fluid.invokersMergePolicy
        },
        components: {
            noexpand: true,
            // We use this dim mergePolicy since i) there is enough room in the records for provenance information, and
            // ii) noone can try to consume this, e.g. to find type/createOnEvent before it hits a potentia anyway
            func: fluid.deferringMergePolicy
        },
        dynamicComponents: {
            noexpand: true,
            func: fluid.deferringMergePolicy
        },
        transformOptions: "replace",
        listeners: fluid.makeMergeListenersPolicy(fluid.mergeListenerPolicy)
    });

    fluid.defaults("fluid.component", {
        mergePolicy: fluid.rootMergePolicy,
        argumentMap: {
            options: 0
        },
        workflows: {
            local: {
                concludeComponentObservation: {
                    funcName: "fluid.concludeComponentObservation",
                    priority: "first"
                },
                concludeComponentInit: {
                    funcName: "fluid.concludeComponentInit",
                    waitIO: true,
                    priority: "last"
                }
            }
        },
        events: { // Three standard lifecycle points common to all components
            onCreate:     null,
            onDestroy:    null,
            afterDestroy: null
        }
    });

    /* Compute a "nickname" given a fully qualified typename, by returning the last path
     * segment.
     */
    fluid.computeNickName = function (typeName) {
        var segs = fluid.model.parseEL(typeName);
        return fluid.peek(segs);
    };

    /** Returns <code>true</code> if the supplied reference holds a component which has been destroyed
     * @param {Component} that - A reference to a component
     * @return {Boolean} `true` if the reference is to a component which has been destroyed
     **/

    fluid.isDestroyed = function (that) {
        return that.lifecycleStatus === "destroyed" || that.lifecycleStatus === "destroying";
    };

    // Computes a name for a component appearing at the global root which is globally unique, from its nickName and id
    fluid.computeGlobalMemberName = function (type, id) {
        var nickName = fluid.computeNickName(type);
        return nickName + "-" + id;
    };

    // unsupported, NON-API function
    // After some error checking, this *is* the component creator function
    fluid.initFreeComponent = function (type, initArgs) {
        var id = fluid.allocateGuid();
        // TODO: Perhaps one day we will support a directive which allows the user to select a current component
        // root for free components other than the global root
        var path = [fluid.computeGlobalMemberName(type, id)];
        var userRecord = {
            recordType: "user",
            type: type
        };
        var upDefaults = fluid.defaults(type);
        // TODO: We only support these two signatures now, probably abolish argumentMap if it weren't for "graded functions"
        // Or else write a proper mergePolicy for argumentMaps
        var argMap = fluid.defaults(upDefaults.argumentMap.container !== undefined ?
            "fluid.viewComponent" : "fluid.component").argumentMap;
        fluid.each(argMap, function (index, name) {
            var arg = initArgs[index];
            userRecord[name] = name === "options" ? fluid.expandCompact(arg, true) : arg;
        });
        var potentia = {
            type: "create",
            path: path,
            componentId: id,
            records: [userRecord]
        };
        var transRec = fluid.registerPotentia(potentia);
        var shadow = fluid.commitPotentiae(transRec.transactionId);
        var returned = false;
        // This registration MUST go last otherwise we mask the catch->reject handler in bindDeferredComponent
        transRec.promise.then(null, function (e) {
            if (!returned) {
                throw e;
            }
        });
        returned = true;
        return shadow && shadow.that;
    };

    // ******* SELECTOR ENGINE *********

    // selector regexps copied from jQuery - recent versions correct the range to start C0
    // The initial portion of the main character selector: "just add water" to add on extra
    // accepted characters, as well as the "\\\\." -> "\." portion necessary for matching
    // period characters escaped in selectors
    var charStart = "(?:[\\w\\u00c0-\\uFFFF*_-";

    fluid.simpleCSSMatcher = {
        regexp: new RegExp("([#.]?)(" + charStart + "]|\\\\.)+)", "g"),
        charToTag: {
            "": "tag",
            "#": "id",
            ".": "clazz"
        }
    };

    fluid.IoCSSMatcher = {
        regexp: new RegExp("([&#]?)(" + charStart + "]|\\.|\\/)+)", "g"),
        charToTag: {
            "": "context",
            "&": "context",
            "#": "id"
        }
    };

    var childSeg = new RegExp("\\s*(>)?\\s*", "g");
//    var whiteSpace = new RegExp("^\\w*$");

    // Parses a selector expression into a data structure holding a list of predicates
    // 2nd argument is a "strategy" structure, e.g.  fluid.simpleCSSMatcher or fluid.IoCSSMatcher
    // unsupported, non-API function
    fluid.parseSelector = function (selstring, strategy) {
        var togo = [];
        selstring = selstring.trim();
        //ws-(ss*)[ws/>]
        var regexp = strategy.regexp;
        regexp.lastIndex = 0;
        var lastIndex = 0;
        while (true) {
            var atNode = []; // a list of predicates at a particular node
            var first = true;
            while (true) {
                var segMatch = regexp.exec(selstring);
                if (!segMatch) {
                    break;
                }
                if (segMatch.index !== lastIndex) {
                    if (first) {
                        fluid.fail("Error in selector string - cannot match child selector expression starting at " + selstring.substring(lastIndex));
                    }
                    else {
                        break;
                    }
                }
                var thisNode = {};
                var text = segMatch[2];
                var targetTag = strategy.charToTag[segMatch[1]];
                if (targetTag) {
                    thisNode[targetTag] = text;
                }
                atNode[atNode.length] = thisNode;
                lastIndex = regexp.lastIndex;
                first = false;
            }
            childSeg.lastIndex = lastIndex;
            var fullAtNode = {predList: atNode};
            var childMatch = childSeg.exec(selstring);
            if (!childMatch || childMatch.index !== lastIndex) {
                fluid.fail("Error in selector string - can not match child selector expression at " + selstring.substring(lastIndex));
            }
            if (childMatch[1] === ">") {
                fullAtNode.child = true;
            }
            togo[togo.length] = fullAtNode;
            // >= test here to compensate for IE bug http://blog.stevenlevithan.com/archives/exec-bugs
            if (childSeg.lastIndex >= selstring.length) {
                break;
            }
            lastIndex = childSeg.lastIndex;
            regexp.lastIndex = childSeg.lastIndex;
        }
        return togo;
    };

    // Message resolution and templating

    /**
     *
     * Take an original object and represent it using top-level sub-elements whose keys are EL Paths.  For example,
     * `originalObject` might look like:
     *
     * ```
     * {
     *   deep: {
     *     path: {
     *       value: "foo",
     *       emptyObject: {},
     *       array: [ "peas", "porridge", "hot"]
     *     }
     *   }
     * }
     * ```
     *
     * Calling `fluid.flattenObjectKeys` on this would result in a new object that looks like:
     *
     * ```
     * {
     *   "deep": "[object Object]",
     *   "deep.path": "[object Object]",
     *   "deep.path.value": "foo",
     *   "deep.path.array": "peas,porridge,hot",
     *   "deep.path.array.0": "peas",
     *   "deep.path.array.1": "porridge",
     *   "deep.path.array.2": "hot"
     * }
     * ```
     *
     * This function preserves the previous functionality of displaying an entire object using its `toString` function,
     * which is why many of the paths above resolve to "[object Object]".
     *
     * This function is an unsupported non-API function that is used in by `fluid.stringTemplate` (see below).
     *
     * @param {Object} originalObject - An object.
     * @return {Object} A representation of the original object that only contains top-level sub-elements whose keys are EL Paths.
     */
    // unsupported, non-API function
    fluid.flattenObjectPaths = function (originalObject) {
        var flattenedObject = {};
        fluid.each(originalObject, function (value, key) {
            if (value !== null && typeof value === "object") {
                var flattenedSubObject = fluid.flattenObjectPaths(value);
                fluid.each(flattenedSubObject, function (subValue, subKey) {
                    flattenedObject[key + "." + subKey] = subValue;
                });
                if (typeof fluid.get(value, "toString") === "function") {
                    flattenedObject[key] = value.toString();
                }
            }
            else {
                flattenedObject[key] = value;
            }
        });
        return flattenedObject;
    };

    /**
     *
     * Simple string template system.  Takes a template string containing tokens in the form of "%value" or
     * "%deep.path.to.value".  Returns a new string with the tokens replaced by the specified values.  Keys and values
     * can be of any data type that can be coerced into a string.
     *
     * @param {String} template - A string that contains placeholders for tokens of the form `%token` embedded into it.
     * @param {Object.<String.String>} values - A map of token names to the values which should be interpolated.
     * @return {String} The text of `template` whose tokens have been interpolated with values.
     */
    fluid.stringTemplate = function (template, values) {
        var flattenedValues = fluid.flattenObjectPaths(values);
        var keys = fluid.keys(flattenedValues);
        keys = keys.sort(fluid.compareStringLength());
        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            var templatePlaceholder = "%" + key;
            var replacementValue = flattenedValues[key];

            var indexOfPlaceHolder = -1;
            while ((indexOfPlaceHolder = template.indexOf(templatePlaceholder)) !== -1) {
                template = template.slice(0, indexOfPlaceHolder) + replacementValue + template.slice(indexOfPlaceHolder + templatePlaceholder.length);
            }
        }
        return template;
    };

})(jQuery, fluid_3_0_0);
;/*!
 Copyright 2011 unscriptable.com / John Hann
 Copyright The Infusion copyright holders
 See the AUTHORS.md file at the top-level directory of this distribution and at
 https://github.com/fluid-project/infusion/raw/master/AUTHORS.md.

 License MIT
*/

var fluid_3_0_0 = fluid_3_0_0 || {};

(function ($, fluid) {
    "use strict";

// Light fluidification of minimal promises library. See original gist at
// https://gist.github.com/unscriptable/814052 for limitations and commentary

// This implementation provides what could be described as "flat promises" with
// no support for structured programming idioms involving promise composition.
// It provides what a proponent of mainstream promises would describe as
// a "glorified callback aggregator"

    fluid.promise = function () {
        var that = {
            // TODO: We probably can and should replace these with actual events, especially once we optimise out
            // "byId" and perhaps also experiment with whether Object.defineProperty creates less garbage than that-ism
            onResolve: [],
            onReject: [],
            onCancel: []
            // disposition: "resolve"/"reject"/"cancel"
            // value: Any
        };
        that.then = function (onResolve, onReject, onCancel) {
            fluid.promise.pushHandler(that, onResolve, "onResolve", "resolve");
            fluid.promise.pushHandler(that, onReject, "onReject", "reject");
            fluid.promise.pushHandler(that, onCancel, "onCancel", "cancel");
            return that;
        };
        that.resolve = function (value) {
            if (that.disposition) {
                if (that.disposition !== "cancel") {
                    fluid.fail("Error: resolving promise ", that,
                        " which has already received \"" + that.disposition + "\"");
                }
            } else {
                that.complete("resolve", that.onResolve, value);
            }
            return that;
        };
        that.reject = function (reason) {
            if (that.disposition) {
                if (that.disposition !== "cancel") {
                    fluid.fail("Error: rejecting promise ", that,
                        "which has already received \"" + that.disposition + "\"");
                }
            } else {
                that.complete("reject", that.onReject, reason);
            }
            return that;
        };
        that.cancel = function (reason) {
            if (!that.disposition) {
                that.complete("cancel", that.onCancel, reason);
            }
        };
        // PRIVATE, NON-API METHOD
        that.complete = function (which, queue, arg) {
            that.disposition = which;
            that.value = arg;
            for (var i = 0; i < queue.length; ++i) {
                queue[i](arg);
            }
            delete that.onResolve;
            delete that.onReject;
            delete that.onCancel;
        };
        return that;
    };

    fluid.promise.pushHandler = function (promise, handler, eventName, disposition) {
        if (handler) {
            if (promise.disposition) {
                if (promise.disposition === disposition) {
                    handler(promise.value);
                }
            } else {
                promise[eventName].push(handler);
            }
        }
    };

    /* Any object with a member <code>then</code> of type <code>function</code> passes this test.
     * This includes essentially every known variety, including jQuery promises.
     */
    fluid.isPromise = function (totest) {
        return totest && typeof(totest.then) === "function";
    };

    /** Coerces any value to a promise
     * @param {Any} promiseOrValue - The value to be coerced
     * @return {Promise} - If the supplied value is already a promise, it is returned unchanged.
     * Otherwise a fresh promise is created with the value as resolution and returned
     */
    fluid.toPromise = function (promiseOrValue) {
        if (fluid.isPromise(promiseOrValue)) {
            return promiseOrValue;
        } else {
            var togo = fluid.promise();
            togo.resolve(promiseOrValue);
            return togo;
        }
    };

    /** Chains the resolution methods of one promise (target) so that they follow those of another (source).
     * That is, whenever source resolves, target will resolve, or when source rejects, target will reject, with the
     * same payloads in each case.
     * @param {Promise} source - The promise that the target promise will subscribe to
     * @param {Promise} target - The promise to which notifications will be forwarded from the source
     */
    fluid.promise.follow = function (source, target) {
        source.then(target.resolve, target.reject);
    };

    /** Returns a promise whose resolved value is mapped from the source promise or value by the supplied function.
     * @param {Object|Promise} source - An object or promise whose value is to be mapped
     * @param {Function} func - A function which will map the resolved promise value
     * @return {Promise} - A promise for the resolved mapped value.
     */
    fluid.promise.map = function (source, func) {
        var promise = fluid.toPromise(source);
        var togo = fluid.promise();
        promise.then(function (value) {
            var mapped = func(value);
            if (fluid.isPromise(mapped)) {
                fluid.promise.follow(mapped, togo);
            } else {
                togo.resolve(mapped);
            }
        }, function (error) {
            togo.reject(error);
        });
        return togo;
    };

    /** Construct a `sequencer` which is a general skeleton structure for all sequential promise algorithms,
     * e.g. transform, reduce, sequence, etc.
     * These accept a variable "strategy" pair to customise the interchange of values and final return
     * @param {Array} sources - Array of values, promises, or tasks
     * @param {Object} options - Algorithm-static options structure to be supplied to any task function discovered within
     * `sources`
     * @param {fluid.promise.strategy} strategy - A pair of function members `invokeNext` and `resolveResult` which determine the particular
     * sequential promise algorithm to be operated.
     * @return {fluid.promise.sequencer} A `sequencer` structure which will operate the algorithm and holds its state.
     */
    fluid.promise.makeSequencer = function (sources, options, strategy) {
        if (!fluid.isArrayable(sources)) {
            fluid.fail("fluid.promise sequence algorithms must be supplied an array as source");
        }
        return {
            sources: sources,
            resolvedSources: [], // the values of "sources" only with functions invoked (an array of promises or values)
            index: 0,
            strategy: strategy,
            options: options, // available to be supplied to each listener
            returns: [],
            sequenceStarted: false,
            promise: fluid.promise() // the final return value
        };
    };

    fluid.promise.progressSequence = function (that, retValue) {
        that.returns.push(retValue);
        that.index++;
        // No we dun't have no tail recursion elimination
        fluid.promise.resumeSequence(that);
    };

    fluid.promise.processSequenceReject = function (that, error) { // Allow earlier promises in the sequence to wrap the rejection supplied by later ones (FLUID-5584)
        for (var i = that.index - 1; i >= 0; --i) {
            var resolved = that.resolvedSources[i];
            var accumulator = fluid.isPromise(resolved) && typeof(resolved.accumulateRejectionReason) === "function" ? resolved.accumulateRejectionReason : fluid.identity;
            error = accumulator(error);
        }
        that.promise.reject(error);
    };

    fluid.promise.resumeSequence = function (that) {
        that.sequenceStarted = true;
        if (that.index === that.sources.length) {
            that.promise.resolve(that.strategy.resolveResult(that));
        } else {
            var value = that.strategy.invokeNext(that);
            that.resolvedSources[that.index] = value;
            if (fluid.isPromise(value)) {
                value.then(function (retValue) {
                    fluid.promise.progressSequence(that, retValue);
                }, function (error) {
                    fluid.promise.processSequenceReject(that, error);
                });
            } else {
                fluid.promise.progressSequence(that, value);
            }
        }
    };

    // SEQUENCE ALGORITHM APPLYING PROMISES

    fluid.promise.makeSequenceStrategy = function () {
        return {
            invokeNext: function (that) {
                var source = that.sources[that.index];
                return typeof(source) === "function" ? source(that.options) : source;
            },
            resolveResult: function (that) {
                return that.returns;
            }
        };
    };

    // accepts an array of values, promises or functions returning promises - in the case of functions returning promises,
    // will assure that at most one of these is "in flight" at a time - that is, the succeeding function will not be invoked
    // until the promise at the preceding position has resolved
    fluid.promise.sequence = function (sources, options) {
        var sequencer = fluid.promise.makeSequencer(sources, options, fluid.promise.makeSequenceStrategy());
        sequencer.promise.sequencer = sequencer; // An aid to debuggability
        fluid.promise.resumeSequence(sequencer);
        return sequencer.promise;
    };

    // TRANSFORM ALGORITHM APPLYING PROMISES

    fluid.promise.makeTransformerStrategy = function () {
        return {
            invokeNext: function (that) {
                var lisrec = that.sources[that.index];
                lisrec.listener = fluid.event.resolveListener(lisrec.listener);
                var value = lisrec.listener.apply(null, [that.returns[that.index], that.options]);
                return value;
            },
            resolveResult: function (that) {
                return that.returns[that.index];
            }
        };
    };

    // Construct a "mini-object" managing the process of a sequence of transforms,
    // each of which may be synchronous or return a promise
    fluid.promise.makeTransformer = function (listeners, payload, options) {
        listeners.unshift({listener:
            function () {
                return payload;
            }
        });
        var sequencer = fluid.promise.makeSequencer(listeners, options, fluid.promise.makeTransformerStrategy());
        sequencer.returns.push(null); // first dummy return from initial entry
        fluid.promise.resumeSequence(sequencer);
        return sequencer;
    };

    fluid.promise.filterNamespaces = function (listeners, namespaces) {
        if (!namespaces) {
            return listeners;
        }
        return fluid.remove_if(fluid.makeArray(listeners), function (element) {
            return element.namespace && !element.softNamespace && !fluid.contains(namespaces, element.namespace);
        });
    };

   /** Top-level API to operate a Fluid event which manages a sequence of
     * chained transforms. Rather than being a standard listener accepting the
     * same payload, each listener to the event accepts the payload returned by the
     * previous listener, and returns either a transformed payload or else a promise
     * yielding such a payload.
     * @param {fluid.eventFirer} event - A Fluid event to which the listeners are to be interpreted as
     * elements cooperating in a chained transform. Each listener will receive arguments <code>(payload, options)</code> where <code>payload</code>
     * is the (successful, resolved) return value of the previous listener, and <code>options</code> is the final argument to this function
     * @param {Object|Promise} payload - The initial payload input to the transform chain
     * @param {Object} options - A free object containing options governing the transform. Fields interpreted at this top level are:
     *     reverse {Boolean}: <code>true</code> if the listeners are to be called in reverse order of priority (typically the case for an inverse transform)
     *     filterTransforms {Array}: An array of listener namespaces. If this field is set, only the transform elements whose listener namespaces listed in this array will be applied.
     * @return {fluid.promise} A promise which will yield either the final transformed value, or the response of the first transform which fails.
     */
    fluid.promise.fireTransformEvent = function (event, payload, options) {
        options = options || {};
        var listeners = options.reverse ? fluid.makeArray(event.sortedListeners).reverse() :
                fluid.makeArray(event.sortedListeners);
        listeners = fluid.promise.filterNamespaces(listeners, options.filterNamespaces);
        var transformer = fluid.promise.makeTransformer(listeners, payload, options);
        return transformer.promise;
    };


})(jQuery, fluid_3_0_0);
;/*
Copyright The Infusion copyright holders
See the AUTHORS.md file at the top-level directory of this distribution and at
https://github.com/fluid-project/infusion/raw/master/AUTHORS.md.

Licensed under the Educational Community License (ECL), Version 2.0 or the New
BSD license. You may not use this file except in compliance with one these
Licenses.

You may obtain a copy of the ECL 2.0 License and BSD License at
https://github.com/fluid-project/infusion/raw/master/Infusion-LICENSE.txt
*/

var fluid_3_0_0 = fluid_3_0_0 || {};

(function ($, fluid) {
    "use strict";

    /** Render a timestamp from a Date object into a helpful fixed format for debug logs to millisecond accuracy
     * @param {Date} date - The date to be rendered
     * @return {String} - A string format consisting of hours:minutes:seconds.millis for the datestamp padded to fixed with
     */

    fluid.renderTimestamp = function (date) {
        var zeropad = function (num, width) {
            if (!width) { width = 2; }
            var numstr = (num === undefined ? "" : num.toString());
            return "00000".substring(5 - width + numstr.length) + numstr;
        };
        return zeropad(date.getHours()) + ":" + zeropad(date.getMinutes()) + ":" + zeropad(date.getSeconds()) + "." + zeropad(date.getMilliseconds(), 3);
    };

    fluid.isTracing = false;

    fluid.registerNamespace("fluid.tracing");

    fluid.tracing.pathCount = [];

    fluid.tracing.summarisePathCount = function (pathCount) {
        pathCount = pathCount || fluid.tracing.pathCount;
        var togo = {};
        for (var i = 0; i < pathCount.length; ++i) {
            var path = pathCount[i];
            if (!togo[path]) {
                togo[path] = 1;
            }
            else {
                ++togo[path];
            }
        }
        var toReallyGo = [];
        fluid.each(togo, function (el, path) {
            toReallyGo.push({path: path, count: el});
        });
        toReallyGo.sort(function (a, b) {return b.count - a.count;});
        return toReallyGo;
    };

    fluid.tracing.condensePathCount = function (prefixes, pathCount) {
        prefixes = fluid.makeArray(prefixes);
        var prefixCount = {};
        fluid.each(prefixes, function (prefix) {
            prefixCount[prefix] = 0;
        });
        var togo = [];
        fluid.each(pathCount, function (el) {
            var path = el.path;
            if (!fluid.find(prefixes, function (prefix) {
                if (path.indexOf(prefix) === 0) {
                    prefixCount[prefix] += el.count;
                    return true;
                }
            })) {
                togo.push(el);
            }
        });
        fluid.each(prefixCount, function (count, path) {
            togo.unshift({path: path, count: count});
        });
        return togo;
    };

    // Exception stripping code taken from https://github.com/emwendelin/javascript-stacktrace/blob/master/stacktrace.js
    // BSD licence, see header

    fluid.detectStackStyle = function (e) {
        var style = "other";
        var stackStyle = {
            offset: 0
        };
        if (e.arguments) {
            style = "chrome";
        } else if (typeof window !== "undefined" && window.opera && e.stacktrace) {
            style = "opera10";
        } else if (e.stack) {
            style = "firefox";
            // Detect FireFox 4-style stacks which are 1 level less deep
            stackStyle.offset = e.stack.indexOf("Trace exception") === -1 ? 1 : 0;
        } else if (typeof window !== "undefined" && window.opera && !("stacktrace" in e)) { //Opera 9-
            style = "opera";
        }
        stackStyle.style = style;
        return stackStyle;
    };

    fluid.obtainException = function () {
        try {
            throw new Error("Trace exception");
        }
        catch (e) {
            return e;
        }
    };

    var stackStyle = fluid.detectStackStyle(fluid.obtainException());

    fluid.registerNamespace("fluid.exceptionDecoders");

    fluid.decodeStack = function () {
        if (stackStyle.style !== "firefox") {
            return null;
        }
        var e = fluid.obtainException();
        return fluid.exceptionDecoders[stackStyle.style](e);
    };

    fluid.exceptionDecoders.firefox = function (e) {
        var delimiter = "at ";
        var lines = e.stack.replace(/(?:\n@:0)?\s+$/m, "").replace(/^\(/gm, "{anonymous}(").split("\n");
        return fluid.transform(lines, function (line) {
            line = line.replace(/\)/g, "");
            var atind = line.indexOf(delimiter);
            return atind === -1 ? [line] : [line.substring(atind + delimiter.length), line.substring(0, atind)];
        });
    };

    // Main entry point for callers.
    fluid.getCallerInfo = function (atDepth) {
        atDepth = (atDepth || 3) - stackStyle.offset;
        var stack = fluid.decodeStack();
        var element = stack && stack[atDepth][0];
        if (element) {
            var lastslash = element.lastIndexOf("/");
            if (lastslash === -1) {
                lastslash = 0;
            }
            var nextColon = element.indexOf(":", lastslash);
            return {
                path: element.substring(0, lastslash),
                filename: element.substring(lastslash + 1, nextColon),
                index: element.substring(nextColon + 1)
            };
        } else {
            return null;
        }
    };

    /** Generates a string for padding purposes by replicating a character a given number of times
     * @param {Character} c - A character to be used for padding
     * @param {Integer} count - The number of times to repeat the character
     * @return A string of length <code>count</code> consisting of repetitions of the supplied character
     */
    // UNOPTIMISED
    fluid.generatePadding = function (c, count) {
        var togo = "";
        for (var i = 0; i < count; ++i) {
            togo += c;
        }
        return togo;
    };

    // Marker so that we can render a custom string for properties which are not direct and concrete
    fluid.SYNTHETIC_PROPERTY = Object.freeze({});

    // utility to avoid triggering custom getter code which could throw an exception - e.g. express 3.x's request object
    fluid.getSafeProperty = function (obj, key) {
        var desc = Object.getOwnPropertyDescriptor(obj, key); // supported on all of our environments - is broken on IE8
        return desc && !desc.get ? obj[key] : fluid.SYNTHETIC_PROPERTY;
    };

    function printImpl(obj, small, options) {
        function out(str) {
            options.output += str;
        }
        var big = small + options.indentChars, isFunction = typeof(obj) === "function";
        if (options.maxRenderChars !== undefined && options.output.length > options.maxRenderChars) {
            return true;
        }
        if (obj === null) {
            out("null");
        } else if (obj === undefined) {
            out("undefined"); // NB - object invalid for JSON interchange
        } else if (obj === fluid.SYNTHETIC_PROPERTY) {
            out("[Synthetic property]");
        } else if (fluid.isPrimitive(obj) && !isFunction) {
            out(JSON.stringify(obj));
        }
        else {
            if (options.stack.indexOf(obj) !== -1) {
                out("(CIRCULAR)"); // NB - object invalid for JSON interchange
                return;
            }
            options.stack.push(obj);
            var i;
            if (fluid.isArrayable(obj)) {
                if (obj.length === 0) {
                    out("[]");
                } else {
                    out("[\n" + big);
                    for (i = 0; i < obj.length; ++i) {
                        if (printImpl(obj[i], big, options)) {
                            return true;
                        }
                        if (i !== obj.length - 1) {
                            out(",\n" + big);
                        }
                    }
                    out("\n" + small + "]");
                }
            }
            else {
                out("{" + (isFunction ? " Function" : "") + "\n" + big); // NB - Function object invalid for JSON interchange
                var keys = fluid.keys(obj);
                for (i = 0; i < keys.length; ++i) {
                    var key = keys[i];
                    var value = fluid.getSafeProperty(obj, key);
                    out(JSON.stringify(key) + ": ");
                    if (printImpl(value, big, options)) {
                        return true;
                    }
                    if (i !== keys.length - 1) {
                        out(",\n" + big);
                    }
                }
                out("\n" + small + "}");
            }
            options.stack.pop();
        }
        return;
    }

    /** Render a complex JSON object into a nicely indented format suitable for human readability.
     * @param {Object} obj - The object to be rendered
     * @param {Object} options - An options structure governing the rendering process. This supports the following options:
     *     <code>indent</code> {Integer} the number of space characters to be used to indent each level of containment (default value: 4)
     *     <code>maxRenderChars</code> {Integer} rendering the object will cease once this number of characters has been generated
     * @return {String} - The generated output.
     */
    fluid.prettyPrintJSON = function (obj, options) {
        options = $.extend({indent: 4, stack: [], output: ""}, options);
        options.indentChars = fluid.generatePadding(" ", options.indent);
        printImpl(obj, "", options);
        return options.output;
    };

    /**
     * Dumps a DOM element into a readily recognisable form for debugging - produces a
     * "semi-selector" summarising its tag name, class and id, whichever are set.
     *
     * @param {jQueryable} element - The element to be dumped
     * @return {String} - A string representing the element.
     */
    fluid.dumpEl = function (element) {
        var togo;

        if (!element) {
            return "null";
        }
        if (element.nodeType === 3 || element.nodeType === 8) {
            return "[data: " + element.data + "]";
        }
        if (element.nodeType === 9) {
            return "[document: location " + element.location + "]";
        }
        if (!element.nodeType && fluid.isArrayable(element)) {
            togo = "[";
            for (var i = 0; i < element.length; ++i) {
                togo += fluid.dumpEl(element[i]);
                if (i < element.length - 1) {
                    togo += ", ";
                }
            }
            return togo + "]";
        }
        element = $(element);
        togo = element.get(0).tagName;
        if (element.id) {
            togo += "#" + element.id;
        }
        if (element.attr("class")) {
            togo += "." + element.attr("class");
        }
        return togo;
    };

    /** BEGIN IOC DEBUGGING METHODS **/
    fluid["debugger"] = function () {
        debugger; // eslint-disable-line no-debugger
    };

    fluid.defaults("fluid.debuggingProbe", {
        gradeNames: ["fluid.component"]
    });

    // probe looks like:
    // target: {preview other}.listeners.eventName
    // priority: first/last
    // func: console.log/fluid.log/fluid.debugger
    fluid.probeToDistribution = function (probe) {
        var instantiator = fluid.globalInstantiator;
        var parsed = fluid.parseContextReference(probe.target);
        var segs = fluid.model.parseToSegments(parsed.path, instantiator.parseEL, true);
        if (segs[0] !== "options") {
            segs.unshift("options"); // compensate for this insanity until we have the great options flattening
        }
        var parsedPriority = fluid.parsePriority(probe.priority);
        if (parsedPriority.constraint && !parsedPriority.constraint.target) {
            parsedPriority.constraint.target = "authoring";
        }
        return {
            target: "{/ " + parsed.context + "}." + instantiator.composeSegments.apply(null, segs),
            record: {
                func: probe.func,
                funcName: probe.funcName,
                args: probe.args,
                priority: fluid.renderPriority(parsedPriority)
            }
        };
    };

    fluid.registerProbes = function (probes) {
        var probeDistribution = fluid.transform(probes, fluid.probeToDistribution);
        var memberName = "fluid_debuggingProbe_" + fluid.allocateGuid();
        fluid.construct([memberName], {
            type: "fluid.debuggingProbe",
            distributeOptions: probeDistribution
        });
        return memberName;
    };

    fluid.deregisterProbes = function (probeName) {
        fluid.destroy([probeName]);
    };

    /** END IOC DEBUGGING METHODS **/

})(jQuery, fluid_3_0_0);
;/*
Copyright The Infusion copyright holders
See the AUTHORS.md file at the top-level directory of this distribution and at
https://github.com/fluid-project/infusion/raw/master/AUTHORS.md.

Licensed under the Educational Community License (ECL), Version 2.0 or the New
BSD license. You may not use this file except in compliance with one these
Licenses.

You may obtain a copy of the ECL 2.0 License and BSD License at
https://github.com/fluid-project/infusion/raw/master/Infusion-LICENSE.txt
*/

var fluid_3_0_0 = fluid_3_0_0 || {};

(function ($, fluid) {
    "use strict";

    /** NOTE: The contents of this file are by default NOT PART OF THE PUBLIC FLUID API unless explicitly annotated before the function **/

    /* The Fluid "IoC System proper" - resolution of references and
     * completely automated instantiation of declaratively defined
     * component trees */

    fluid.visitComponentChildren = function (that, visitor, options, segs) {
        segs = segs || [];
        var shadow = fluid.shadowForComponent(that);
        for (var name in shadow.childComponents) {
            var component = shadow.childComponents[name];
            if (options.visited && options.visited[component.id]) {
                continue;
            }
            segs.push(name);
            if (options.visited) { // recall that this is here because we may run into a component that has been cross-injected which might otherwise cause cyclicity
                options.visited[component.id] = true;
            }
            if (visitor(component, name, segs, segs.length - 1)) {
                return true;
            }
            if (!options.flat) {
                fluid.visitComponentChildren(component, visitor, options, segs);
            }
            segs.pop();
        }
    };

    fluid.getContextHash = function (instantiator, that) {
        var shadow = instantiator.idToShadow[that.id];
        return shadow && shadow.contextHash;
    };

    fluid.componentHasGrade = function (that, gradeName) {
        var contextHash = fluid.getContextHash(fluid.globalInstantiator, that);
        return !!(contextHash && contextHash[gradeName]);
    };

    // A variant of fluid.visitComponentChildren that supplies the signature expected for fluid.matchIoCSelector
    // this is: thatStack, contextHashes, memberNames, i - note, the supplied arrays are NOT writeable and shared through the iteration
    fluid.visitComponentsForMatching = function (that, options, visitor) {
        var instantiator = fluid.getInstantiator(that);
        options = $.extend({
            visited: {},
            instantiator: instantiator
        }, options);
        var thatStack = [that];
        var contextHashes = [fluid.getContextHash(instantiator, that)];
        var visitorWrapper = function (component, name, segs) {
            thatStack.length = 1;
            contextHashes.length = 1;
            for (var i = 0; i < segs.length; ++i) {
                var child = thatStack[i][segs[i]];
                thatStack[i + 1] = child;
                contextHashes[i + 1] = fluid.getContextHash(instantiator, child) || {};
            }
            return visitor(component, thatStack, contextHashes, segs, segs.length);
        };
        fluid.visitComponentChildren(that, visitorWrapper, options, []);
    };

    fluid.getMemberNames = function (instantiator, thatStack) {
        if (thatStack.length === 0) { // Odd edge case for FLUID-6126 from fluid.computeDistributionPriority
            return [];
        } else {
            var path = instantiator.idToPath(fluid.peek(thatStack).id);
            var segs = instantiator.parseEL(path);
                // TODO: we should now have no longer shortness in the stack
            segs.unshift.apply(segs, fluid.generate(thatStack.length - segs.length, ""));
            return segs;
        }
    };

    // thatStack contains an increasing list of MORE SPECIFIC thats.
    // this visits all components starting from the current location (end of stack)
    // in visibility order UP the tree.
    fluid.visitComponentsForVisibility = function (instantiator, thatStack, visitor, options) {
        options = options || {
            visited: {},
            flat: true,
            instantiator: instantiator
        };
        var memberNames = fluid.getMemberNames(instantiator, thatStack);
        for (var i = thatStack.length - 1; i >= 0; --i) {
            var that = thatStack[i];

            // explicitly visit the direct parent first
            options.visited[that.id] = true;
            if (visitor(that, memberNames[i], memberNames, i)) {
                return;
            }

            if (fluid.visitComponentChildren(that, visitor, options, memberNames)) {
                return;
            }
            memberNames.pop();
        }
    };

    fluid.mountStrategy = function (prefix, root, toMount) {
        var offset = prefix.length;
        return function (target, name, i, segs) {
            if (i <= prefix.length) { // Avoid OOB to not trigger deoptimisation!
                return;
            }
            for (var j = 0; j < prefix.length; ++j) {
                if (segs[j] !== prefix[j]) {
                    return;
                }
            }
            return toMount(target, name, i - prefix.length, segs.slice(offset));
        };
    };

    fluid.invokerFromRecord = function (invokerec, name, that) {
        fluid.pushActivity("makeInvoker", "beginning instantiation of invoker with name %name and record %record as child of %that",
            {name: name, record: invokerec, that: that});
        var invoker = invokerec ? fluid.makeInvoker(that, invokerec, name) : undefined;
        fluid.popActivity();
        return invoker;
    };

    fluid.memberFromRecord = function (memberrecs, name, that) {
        var shadow = fluid.shadowForComponent(that);
        var togo;
        for (var i = 0; i < memberrecs.length; ++i) { // memberrecs is the special "fluid.mergingArray" type which is not Arrayable
            var expanded = fluid.expandImmediate(memberrecs[i], that, shadow.localRecord);
            if (!fluid.isPlainObject(togo)) { // poor man's "merge" algorithm to hack FLUID-5668 for now
                togo = expanded;
            } else {
                togo = $.extend(true, togo, expanded);
            }
        }
        return togo;
    };

    fluid.resourceFromRecord = function (resourceRec, name, that) {
        var resourceFetcher = fluid.getForComponent(that, "resourceFetcher");
        var resourceSpec = resourceFetcher.resourceSpecs[name];
        var oneFetcher = new fluid.fetchResources.FetchOne(resourceSpec, resourceFetcher);
        var promise = oneFetcher.resourceSpec.promise;
        if (!promise.disposition) {
            var transRec = fluid.currentTreeTransaction();
            transRec.pendingIO.push(promise);
        } // No error handling here since the error handler added in workflows will abort the whole transaction
        return oneFetcher;
    };

    /** Produce a "strategy" object which mechanises the work of converting a block of options material into a
     * a live piece of component machinery to be mounted onto the component - e.g. an invoker, event, member or resource
     * @param {Component} that - The component currently instantiating
     * @param {Object} options - The component's currently evaluating options structure
     * @param {Strategy} optionsStrategy - A "strategy" function which can drive further evaluation of the options structure
     * @param {String} recordPath - A single path segment into the options structure which indexes the options records to be consumed
     * @param {Function} recordMaker - A function converting an evaluated block of options into the material to be mounted,
     * e.g. `fluid.invokerFromRecord`. Signature to this function is (Object options, String key, Component that).
     * @param {String} prefix - Any prefix to be added to the path into options in order to generate the path into the final mounted material
     * @param {Object} [exceptions] - Hack for FLUID-5668. Some exceptions to not undergo "flood" initialisation during `initter` since they
     * self-initialise by some customised scheme
     * @return {RecordStrategy} - A structure with two function members -
     *    {Strategy} strategy: A upstream function strategy by which evaluation of the mounted material can itself be driven
     *    {Function} initter: A function which can be used to trigger final "flood" initialisation of all material which has not so far been
     *    referenced.
     */
    fluid.recordStrategy = function (that, options, optionsStrategy, recordPath, recordMaker, prefix, exceptions) {
        prefix = prefix || [];
        return {
            strategy: function (target, name, i) {
                if (i !== 1) { // Strange hack added for forgotten reason
                    return;
                }
                var record = fluid.driveStrategy(options, [recordPath, name], optionsStrategy);
                if (record === undefined) {
                    return;
                }
                fluid.set(target, [name], fluid.inEvaluationMarker);
                var member = recordMaker(record, name, that);
                fluid.set(target, [name], member);
                return member;
            },
            initter: function () {
                var records = fluid.driveStrategy(options, recordPath, optionsStrategy) || {};
                for (var name in records) {
                    if (!exceptions || !exceptions[name]) {
                        fluid.getForComponent(that, prefix.concat([name]));
                    }
                }
            }
        };
    };

    fluid.makeDistributionRecord = function (contextThat, sourceRecord, sourcePath, targetSegs, exclusions, sourceType) {
        sourceType = sourceType || "distribution";
        fluid.pushActivity("makeDistributionRecord", "Making distribution record from source record %sourceRecord path %sourcePath to target path %targetSegs", {sourceRecord: sourceRecord, sourcePath: sourcePath, targetSegs: targetSegs});

        var source = fluid.copy(fluid.get(sourceRecord, sourcePath));
        fluid.each(exclusions, function (exclusion) {
            fluid.model.applyChangeRequest(source, {segs: exclusion, type: "DELETE"});
        });

        var record = {options: {}};
        fluid.model.applyChangeRequest(record, {segs: targetSegs, type: "ADD", value: source});
        fluid.checkComponentRecord(record, fluid.componentRecordExpected);
        fluid.popActivity();
        return $.extend(record, {contextThat: contextThat, recordType: sourceType});
    };

    // Part of the early "distributeOptions" workflow. Given the description of the blocks to be distributed, assembles "canned" records
    // suitable to be either registered into the shadow record for later or directly pushed to an existing component, as well as honouring
    // any "removeSource" annotations by removing these options from the source block.
    fluid.filterBlocks = function (contextThat, sourceBlocks, sourceSegs, targetSegs, exclusions, removeSource) {
        var togo = [];
        fluid.each(sourceBlocks, function (block) {
            var source = fluid.get(block.source, sourceSegs);
            if (source !== undefined) {
                togo.push(fluid.makeDistributionRecord(contextThat, block.source, sourceSegs, targetSegs, exclusions, "distribution"));
                var rescued = $.extend({}, source);
                if (removeSource) {
                    fluid.model.applyChangeRequest(block.source, {segs: sourceSegs, type: "DELETE"});
                }
                fluid.each(exclusions, function (exclusion) {
                    var orig = fluid.get(rescued, exclusion);
                    fluid.set(block.source, sourceSegs.concat(exclusion), orig);
                });
            }
        });
        return togo;
    };

    // Use this peculiar signature since the actual component and shadow itself may not exist yet. Perhaps clean up with FLUID-4925
    fluid.noteCollectedDistribution = function (parentShadow, memberName, distribution) {
        fluid.model.setSimple(parentShadow, ["collectedDistributions", memberName, distribution.id], true);
    };

    fluid.isCollectedDistribution = function (parentShadow, memberName, distribution) {
        return fluid.model.getSimple(parentShadow, ["collectedDistributions", memberName, distribution.id]);
    };

    fluid.clearCollectedDistributions = function (parentShadow, memberName) {
        fluid.model.applyChangeRequest(parentShadow, {segs: ["collectedDistributions", memberName], type: "DELETE"});
    };

    fluid.collectDistributions = function (distributedBlocks, parentShadow, distribution, thatStack, contextHashes, memberNames, i) {
        var lastMember = fluid.peek(memberNames);
        if (!fluid.isCollectedDistribution(parentShadow, lastMember, distribution) &&
                fluid.matchIoCSelector(distribution.selector, thatStack, contextHashes, memberNames, i)) {
            distributedBlocks.push.apply(distributedBlocks, fluid.copy(distribution.blocks));
            fluid.noteCollectedDistribution(parentShadow, lastMember, distribution);
        }
    };

    // Slightly silly function to clean up the "appliedDistributions" records. In general we need to be much more aggressive both
    // about clearing instantiation garbage (e.g. onCreate and most of the shadow)
    // as well as caching frequently-used records such as the "thatStack" which
    // would mean this function could be written in a sensible way
    fluid.registerCollectedClearer = function (shadow, parentShadow, memberName) {
        if (!shadow.collectedClearer && parentShadow) {
            shadow.collectedClearer = function () {
                fluid.clearCollectedDistributions(parentShadow, memberName);
            };
        }
    };

    fluid.receiveDistributions = function (parentThat, gradeNames, memberName, that) {
        var instantiator = fluid.getInstantiator(parentThat || that);
        var thatStack = instantiator.getThatStack(parentThat || that); // most specific is at end
        thatStack.unshift(fluid.rootComponent);
        var memberNames = fluid.getMemberNames(instantiator, thatStack);
        var shadows = fluid.transform(thatStack, function (thisThat) {
            return instantiator.idToShadow[thisThat.id];
        });
        var parentShadow = shadows[shadows.length - (parentThat ? 1 : 2)];
        var contextHashes = fluid.getMembers(shadows, "contextHash");
        if (parentThat) { // if called before construction of component from initComponentShell
            memberNames.push(memberName);
            contextHashes.push(fluid.gradeNamesToHash(gradeNames));
            thatStack.push(that);
        } else {
            fluid.registerCollectedClearer(fluid.peek(shadows), parentShadow, fluid.peek(memberNames));
        }
        var distributedBlocks = [];
        for (var i = 0; i < thatStack.length - 1; ++i) {
            fluid.each(shadows[i].distributions, function (distribution) { // eslint-disable-line no-loop-func
                fluid.collectDistributions(distributedBlocks, parentShadow, distribution, thatStack, contextHashes, memberNames, i);
            });
        }
        return distributedBlocks;
    };

    fluid.computeTreeDistance = function (path1, path2) {
        var i = 0;
        while (i < path1.length && i < path2.length && path1[i] === path2[i]) {
            ++i;
        }
        return path1.length + path2.length - 2*i; // eslint-disable-line space-infix-ops
    };

    // Called from applyDistributions (immediate application route) as well as mergeRecordsToList (pre-instantiation route) AS WELL AS assembleCreatorArguments (pre-pre-instantiation route)
    fluid.computeDistributionPriority = function (targetThat, distributedBlock) {
        if (!distributedBlock.priority) {
            var instantiator = fluid.getInstantiator(targetThat);
            var targetStack = instantiator.getThatStack(targetThat);
            var targetPath = fluid.getMemberNames(instantiator, targetStack);
            var sourceStack = instantiator.getThatStack(distributedBlock.contextThat);
            var sourcePath = fluid.getMemberNames(instantiator, sourceStack);
            var distance = fluid.computeTreeDistance(targetPath, sourcePath);
            distributedBlock.priority = fluid.mergeRecordTypes.distribution - distance;
        }
        return distributedBlock;
    };

    // convert "preBlocks" as produced from fluid.filterBlocks into "real blocks" suitable to be used by the expansion machinery.
    fluid.applyDistributions = function (that, preBlocks, targetShadow) {
        var distributedBlocks = fluid.transform(preBlocks, function (preBlock) {
            return fluid.generateExpandBlock(preBlock, that, targetShadow.mergePolicy);
        }, function (distributedBlock) {
            return fluid.computeDistributionPriority(that, distributedBlock);
        });
        var mergeOptions = targetShadow.mergeOptions;
        mergeOptions.mergeBlocks.push.apply(mergeOptions.mergeBlocks, distributedBlocks);
        mergeOptions.updateBlocks();
        return distributedBlocks;
    };

    // TODO: This implementation is obviously poor and has numerous flaws - in particular it does no backtracking as well as matching backwards through the selector
    /** Match a parsed IoC selector against a selection of data structures representing a component's tree context.
     * @param {ParsedSelector} selector - A parsed selector structure as returned from `fluid.parseSelector`.
     * @param {Component[]} thatStack - An array of components ascending up the tree from the component being matched,
     * which will be held in the last position.
     * @param {Object[]} contextHashes - An array of context hashes as cached in the component's shadows - a hash to
     * `true`/"memberName" depending on the reason the context matches
     * @param {String[]} [memberNames] - An array of member names of components in their parents. This is only used in the distributeOptions route.
     * @param {Number} i - One plus the index of the IoCSS head component within `thatStack` - all components before this
     * index will be ignored for matching. Will have value `1` in the queryIoCSelector route.
     * @return {Boolean} `true` if the selector matches the leaf component at the end of `thatStack`
     */
    fluid.matchIoCSelector = function (selector, thatStack, contextHashes, memberNames, i) {
        var thatpos = thatStack.length - 1;
        var selpos = selector.length - 1;
        while (true) {
            var isChild = selector[selpos].child;
            var mustMatchHere = thatpos === thatStack.length - 1 || isChild;

            var that = thatStack[thatpos];
            var selel = selector[selpos];
            var match = true;
            for (var j = 0; j < selel.predList.length; ++j) {
                var pred = selel.predList[j];
                var context = pred.context;
                if (context && context !== "*" && !(contextHashes[thatpos][context] || memberNames[thatpos] === context)) {
                    match = false;
                    break;
                }
                if (pred.id && that.id !== pred.id) {
                    match = false;
                    break;
                }
            }
            if (selpos === 0 && thatpos > i && mustMatchHere && isChild) {
                match = false; // child selector must exhaust stack completely - FLUID-5029
            }
            if (match) {
                if (selpos === 0) {
                    return true;
                }
                --thatpos;
                --selpos;
            }
            else {
                if (mustMatchHere) {
                    return false;
                }
                else {
                    --thatpos;
                }
            }
            if (thatpos < i) {
                return false;
            }
        }
    };

    /** Query for all components matching a selector in a particular tree
     * @param {Component} root - The root component at which to start the search
     * @param {String} selector - An IoCSS selector, in form of a string. Note that since selectors supplied to this function implicitly
     * match downwards, they need not contain the "head context" followed by whitespace required in the distributeOptions form. E.g.
     * simply <code>"fluid.viewComponent"</code> will match all viewComponents below the root.
     * @param {Boolean} flat - [Optional] <code>true</code> if the search should just be performed at top level of the component tree
     * Note that with <code>flat=false</code> this search will scan every component in the tree and may well be very slow.
     * @return {Component[]} The list of all components matching the selector
     */
    // supported, PUBLIC API function
    fluid.queryIoCSelector = function (root, selector, flat) {
        var parsed = fluid.parseSelector(selector, fluid.IoCSSMatcher);
        var togo = [];

        fluid.visitComponentsForMatching(root, {flat: flat}, function (that, thatStack, contextHashes) {
            if (fluid.matchIoCSelector(parsed, thatStack, contextHashes, [], 1)) {
                togo.push(that);
            }
        });
        return togo;
    };

    fluid.isIoCSSSelector = function (context) {
        return context.indexOf(" ") !== -1; // simple-minded check for an IoCSS reference
    };

    fluid.pushDistributions = function (targetHead, selector, target, blocks) {
        var targetShadow = fluid.shadowForComponent(targetHead);
        var id = fluid.allocateGuid();
        var distribution = {
            id: id, // This id is used in clearDistributions
            target: target, // Here for improved debuggability - info is duplicated in "selector"
            selector: selector,
            blocks: blocks
        };
        Object.freeze(distribution);
        Object.freeze(distribution.blocks);
        distribution.blocks.forEach(function (block) {
            fluid.freezeRecursive(block.options);
        });
        fluid.pushArray(targetShadow, "distributions", distribution);
        return id;
    };

    fluid.clearDistribution = function (targetHeadId, id) {
        var targetHeadShadow = fluid.globalInstantiator.idToShadow[targetHeadId];
        // By FLUID-6193, the head component may already have been destroyed, in which case the distributions are gone,
        // and we have leaked only its id. In theory we may want to re-establish the distribution if the head is
        // re-created, but that is a far wider issue.
        if (targetHeadShadow) {
            fluid.remove_if(targetHeadShadow.distributions, function (distribution) {
                return distribution.id === id;
            });
        }
    };

    fluid.clearDistributions = function (shadow) {
        fluid.each(shadow.outDistributions, function (outDist) {
            fluid.clearDistribution(outDist.targetHeadId, outDist.distributionId);
        });
    };

    // Modifies a parsed selector to extract and remove its head context which will be matched upwards
    fluid.extractSelectorHead = function (parsedSelector) {
        var predList = parsedSelector[0].predList;
        var context = predList[0].context;
        predList.length = 0;
        return context;
    };

    fluid.parseExpectedOptionsPath = function (path, role) {
        var segs = fluid.model.parseEL(path);
        if (segs[0] !== "options") {
            fluid.fail("Error in options distribution path ", path, " - only " + role + " paths beginning with \"options\" are supported");
        }
        return segs.slice(1);
    };

    fluid.replicateProperty = function (source, property, targets) {
        if (source[property] !== undefined) {
            fluid.each(targets, function (target) {
                target[property] = source[property];
            });
        }
    };

    fluid.undistributableOptions = ["gradeNames", "distributeOptions", "argumentMap", "mergePolicy"]; // automatically added to "exclusions" of every distribution

    fluid.distributeOptionsOne = function (that, record, targetRef, selector, context) {
        fluid.pushActivity("distributeOptions", "parsing distributeOptions block %record %that ", {that: that, record: record});
        var targetHead = fluid.resolveContext(context, that);
        if (!targetHead) {
            fluid.fail("Error in options distribution record ", record, " - could not resolve context {" + context + "} to a head component");
        }
        var thatShadow = fluid.shadowForComponent(that);
        var targetSegs = fluid.model.parseEL(targetRef.path);
        var preBlocks;
        if (record.record !== undefined) {
            preBlocks = [(fluid.makeDistributionRecord(that, record.record, [], targetSegs, []))];
        }
        else {
            var source = fluid.parseContextReference(record.source);
            if (source.context !== "that") {
                fluid.fail("Error in options distribution record ", record, " only a source context of {that} is supported");
            }
            var sourceSegs = fluid.parseExpectedOptionsPath(source.path, "source");
            var fullExclusions = fluid.makeArray(record.exclusions).concat(sourceSegs.length === 0 ? fluid.undistributableOptions : []);

            var exclusions = fluid.transform(fullExclusions, function (exclusion) {
                return fluid.model.parseEL(exclusion);
            });

            preBlocks = fluid.filterBlocks(that, thatShadow.mergeOptions.mergeBlocks, sourceSegs, targetSegs, exclusions, record.removeSource);
            thatShadow.mergeOptions.updateBlocks(); // perhaps unnecessary
        }
        fluid.replicateProperty(record, "priority", preBlocks);
        fluid.replicateProperty(record, "namespace", preBlocks);
        // TODO: inline material has to be expanded in its original context!

        if (selector) {
            var distributionId = fluid.pushDistributions(targetHead, selector, record.target, preBlocks);
            thatShadow.outDistributions = thatShadow.outDistributions || [];
            thatShadow.outDistributions.push({
                targetHeadId: targetHead.id,
                distributionId: distributionId
            });
        }
        else { // The component exists now, we must rebalance it
            var targetShadow = fluid.shadowForComponent(targetHead);
            fluid.applyDistributions(that, preBlocks, targetShadow);
        }
        fluid.popActivity();
    };

    /* Evaluate the `distributeOptions` block in the options of a component, and mount the distribution in the appropriate
     * shadow for components yet to be constructed, or else apply it immediately to the merge blocks of any target
     * which is currently in evaluation.
     * This occurs early during the evaluation phase of the source component, during `fluid.computeComponentAccessor`
     */
    fluid.distributeOptions = function (that, optionsStrategy) {
        var records = fluid.driveStrategy(that.options, "distributeOptions", optionsStrategy);
        fluid.each(records, function distributeOptionsOne(record) {
            if (typeof(record.target) !== "string") {
                fluid.fail("Error in options distribution record ", record, " a member named \"target\" must be supplied holding an IoC reference");
            }
            if (typeof(record.source) === "string" ^ record.record === undefined) {
                fluid.fail("Error in options distribution record ", record, ": must supply either a member \"source\" holding an IoC reference or a member \"record\" holding a literal record");
            }
            var targetRef = fluid.parseContextReference(record.target);
            var selector, context;
            if (fluid.isIoCSSSelector(targetRef.context)) {
                selector = fluid.parseSelector(targetRef.context, fluid.IoCSSMatcher);
                context = fluid.extractSelectorHead(selector);
            }
            else {
                context = targetRef.context;
            }
            if (context === "/" || context === "that") {
                fluid.distributeOptionsOne(that, record, targetRef, selector, context);
            } else {
                var transRec = fluid.currentTreeTransaction();
                transRec.deferredDistributions.push({that: that, record: record, targetRef: targetRef, selector: selector, context: context});
            }
        });
    };

    fluid.gradeNamesToHash = function (gradeNames) {
        var contextHash = {};
        fluid.each(gradeNames, function (gradeName) {
            contextHash[gradeName] = true;
            contextHash[fluid.computeNickName(gradeName)] = true;
        });
        return contextHash;
    };

    fluid.cacheShadowGrades = function (that, shadow) {
        var contextHash = fluid.gradeNamesToHash(that.options && that.options.gradeNames || [that.typeName]);
        if (!contextHash[shadow.memberName]) {
            contextHash[shadow.memberName] = "memberName"; // This is filtered out again in recordComponent - TODO: Ensure that ALL resolution uses the scope chain eventually
        }
        shadow.contextHash = contextHash;
        fluid.each(contextHash, function (troo, context) {
            shadow.ownScope[context] = that;
            if (shadow.parentShadow && shadow.parentShadow.that.type !== "fluid.rootComponent") {
                shadow.parentShadow.childrenScope[context] = that;
            }
        });
    };

    // First sequence point where the mergeOptions strategy is delivered from Fluid.js - here we take care
    // of both receiving and transmitting options distributions
    fluid.deliverOptionsStrategy = function (that, target, mergeOptions) {
        var shadow = fluid.shadowForComponent(that, shadow);
        fluid.cacheShadowGrades(that, shadow);
        shadow.mergeOptions = mergeOptions;
    };

    /** Dynamic grade closure algorithm - the following 4 functions share access to a small record structure "rec" which is
     * constructed at the start of fluid.computeDynamicGrades
     */

    fluid.collectDistributedGrades = function (rec) {
        // Receive distributions first since these may cause arrival of more contextAwareness blocks.
        var distributedBlocks = fluid.receiveDistributions(null, null, null, rec.that);
        if (distributedBlocks.length > 0) {
            var readyBlocks = fluid.applyDistributions(rec.that, distributedBlocks, rec.shadow);
            var gradeNamesList = fluid.transform(fluid.getMembers(readyBlocks, ["source", "gradeNames"]), fluid.makeArray);
            fluid.accumulateDynamicGrades(rec, fluid.flatten(gradeNamesList));
        }
    };

    fluid.flattenGradeName = function (gradeName) {
        return typeof(gradeName) === "string" ? gradeName : JSON.stringify(gradeName);
    };

    // Apply a batch of freshly acquired plain dynamic grades to the target component and recompute its options
    fluid.applyDynamicGrades = function (rec) {
        rec.oldGradeNames = fluid.makeArray(rec.gradeNames);
        // Note that this crude algorithm doesn't allow us to determine which grades are "new" and which not // TODO: can no longer interpret comment
        var newDefaults = fluid.copy(fluid.getMergedDefaults(rec.that.typeName, rec.gradeNames));
        rec.gradeNames.length = 0; // acquire derivatives of dynamic grades (FLUID-5054)
        rec.gradeNames.push.apply(rec.gradeNames, newDefaults.gradeNames);

        fluid.each(rec.gradeNames, function (gradeName) {
            if (!fluid.isReferenceOrExpander(gradeName)) {
                rec.seenGrades[gradeName] = true;
            }
        });

        var shadow = rec.shadow;
        fluid.cacheShadowGrades(rec.that, shadow);
        // This cheap strategy patches FLUID-5091 for now - some more sophisticated activity will take place
        // at this site when we have a full fix for FLUID-5028
        shadow.mergeOptions.destroyValue(["mergePolicy"]);
        // TODO: Why do we do this given as we decided we are not responsive to it?
        shadow.mergeOptions.destroyValue(["components"]);
        shadow.mergeOptions.destroyValue(["invokers"]);

        rec.defaultsBlock.source = newDefaults;
        shadow.mergeOptions.updateBlocks();
        shadow.mergeOptions.computeMergePolicy(); // TODO: we should really only do this if its content changed - this implies moving all options evaluation over to some (cheap) variety of the ChangeApplier

        fluid.accumulateDynamicGrades(rec, newDefaults.gradeNames);
    };

    // Filter some newly discovered grades into their plain and dynamic queues
    fluid.accumulateDynamicGrades = function (rec, newGradeNames) {
        fluid.each(newGradeNames, function (gradeName) {
            var flatGradeName = fluid.flattenGradeName(gradeName);
            if (!rec.seenGrades[flatGradeName]) {
                if (fluid.isReferenceOrExpander(gradeName)) {
                    rec.rawDynamic.push(gradeName);
                    rec.seenGrades[flatGradeName] = true;
                } else if (!fluid.contains(rec.oldGradeNames, gradeName)) {
                    rec.plainDynamic.push(gradeName);
                }
            }
        });
    };

    fluid.computeDynamicGrades = function (that, shadow, strategy) {
        delete that.options.gradeNames; // Recompute gradeNames for FLUID-5012 and others
        var gradeNames = fluid.driveStrategy(that.options, "gradeNames", strategy); // Just acquire the reference and force eval of mergeBlocks "target", contents are wrong
        gradeNames.length = 0;
        // TODO: In complex distribution cases, a component might end up with multiple default blocks
        var defaultsBlock = fluid.findMergeBlocks(shadow.mergeOptions.mergeBlocks, "defaults")[0];

        var rec = {
            that: that,
            shadow: shadow,
            defaultsBlock: defaultsBlock,
            gradeNames: gradeNames, // remember that this array is globally shared
            seenGrades: {},
            plainDynamic: [],
            rawDynamic: []
        };
        fluid.each(shadow.mergeOptions.mergeBlocks, function (block) { // acquire parents of earlier blocks before applying later ones
            gradeNames.push.apply(gradeNames, fluid.makeArray(block.target && block.target.gradeNames));
            fluid.applyDynamicGrades(rec);
        });
        fluid.collectDistributedGrades(rec);
        while (true) {
            while (rec.plainDynamic.length > 0) {
                gradeNames.push.apply(gradeNames, rec.plainDynamic);
                rec.plainDynamic.length = 0;
                fluid.applyDynamicGrades(rec);
                fluid.collectDistributedGrades(rec);
            }
            if (rec.rawDynamic.length > 0) {
                var expanded = fluid.expandImmediate(rec.rawDynamic.shift(), that, shadow.localRecord);
                if (typeof(expanded) === "function") {
                    expanded = expanded();
                }
                if (expanded) {
                    rec.plainDynamic = rec.plainDynamic.concat(expanded);
                }
            } else {
                break;
            }
        }

        if (shadow.collectedClearer) {
            shadow.collectedClearer();
            delete shadow.collectedClearer;
        }
    };

    /* Second sequence point for mergeComponentOptions from Fluid.js - here we construct all further
     * strategies required on the IoC side and mount them into the shadow's getConfig for universal use
     * We also evaluate and broadcast any options distributions from the options' `distributeOptions`
     */

    fluid.computeComponentAccessor = function (that, localRecord) {
        var instantiator = fluid.globalInstantiator;
        var shadow = fluid.shadowForComponent(that);
        shadow.localRecord = localRecord;
        // TODO: Presumably we can now simply resolve this from within the shadow potentia itself
        var options = that.options;
        var strategy = shadow.mergeOptions.strategy;
        var optionsStrategy = fluid.mountStrategy(["options"], options, strategy);

        shadow.invokerStrategy = fluid.recordStrategy(that, options, strategy, "invokers", fluid.invokerFromRecord);

        shadow.eventStrategyBlock = fluid.recordStrategy(that, options, strategy, "events", fluid.eventFromRecord, ["events"]);
        var eventStrategy = fluid.mountStrategy(["events"], that, shadow.eventStrategyBlock.strategy);

        shadow.memberStrategy = fluid.recordStrategy(that, options, strategy, "members", fluid.memberFromRecord, null, {model: true, modelRelay: true});
        // TODO: this is all hugely inefficient since we query every scheme for every path, whereas
        // we should know perfectly well what kind of scheme there will be for a path, especially once we have resolved
        // FLUID-5761, FLUID-5244
        shadow.getConfig = {strategies: [fluid.model.funcResolverStrategy, fluid.concreteStrategy,
            optionsStrategy, shadow.invokerStrategy.strategy, shadow.memberStrategy.strategy, eventStrategy]};

        fluid.computeDynamicGrades(that, shadow, strategy, shadow.mergeOptions.mergeBlocks);
        if (shadow.contextHash["fluid.resourceLoader"]) {
            shadow.resourceStrategyBlock = fluid.recordStrategy(that, options, strategy, "resources", fluid.resourceFromRecord, ["resources"]);
            var resourceStrategy = fluid.mountStrategy(["resources"], that, shadow.resourceStrategyBlock.strategy);
            shadow.getConfig.strategies.push(resourceStrategy);
            that.resources = {};
        }

        fluid.distributeOptions(that, strategy);
        if (shadow.contextHash["fluid.resolveRoot"]) {
            var memberName;
            if (shadow.contextHash["fluid.resolveRootSingle"]) {
                var singleRootType = fluid.getForComponent(that, ["options", "singleRootType"]);
                if (!singleRootType) {
                    fluid.fail("Cannot register object with grades " + Object.keys(shadow.contextHash).join(", ") + " as fluid.resolveRootSingle since it has not defined option singleRootType");
                }
                memberName = fluid.typeNameToMemberName(singleRootType);
            } else {
                memberName = fluid.computeGlobalMemberName(that.typeName, that.id);
            }
            var parent = fluid.resolveRootComponent;
            if (parent[memberName]) {
                instantiator.clearComponent(parent, memberName);
            }
            instantiator.recordKnownComponent(parent, that, memberName, false);
        }

        return shadow.getConfig;
    };

    // About the SHADOW:
    // This holds a record of IoC information for each instantiated component.
    // It is allocated at: instantiator's "recordComponent"
    // It is destroyed at: instantiator's "clearConcreteComponent"
    // Contents:
    //     path {String} Principal allocated path (point of construction) in tree
    //     that {Component} The component itself
    //     contextHash {String to Boolean} Map of context names which this component matches
    //     mergePolicy, mergeOptions: Machinery for last phase of options merging
    //     localRecord: The "local record" of special contexts for local resolution, e.g. {arguments}, {source}, etc.
    //     invokerStrategy, eventStrategyBlock, memberStrategy, getConfig: Junk required to operate the accessor
    //     listeners: Listeners registered during this component's construction, to be cleared during clearListeners
    //     distributions, collectedClearer: Managing options distributions
    //     outDistributions: A list of distributions registered from this component, signalling from distributeOptions to clearDistributions
    //     ownScope: A hash of names to components which are in scope from this component - populated in cacheShadowGrades
    //     childrenScope: A hash of names to components which are in scope because they are children of this component (BELOW own ownScope in resolution order)
    //     potentia: The original potentia record as supplied to registerPotentia
    //     childComponents: Hash of key names to subcomponents
    //     lightMergeComponents, lightMergeDynamicComponents: signalling between fluid.processComponentShell and fluid.concludeComponentObservation
    //     modelSourcedDynamicComponents: signalling between fluid.processComponentShell and fluid.initModel

    fluid.shadowForComponent = function (component) {
        var instantiator = fluid.getInstantiator(component);
        return instantiator && component ? instantiator.idToShadow[component.id] : null;
    };

    // Access the member at a particular path in a component, forcing it to be constructed gingerly if necessary
    // supported, PUBLIC API function
    fluid.getForComponent = function (component, path) {
        var segs = fluid.model.pathToSegments(path, getConfig);
        if (segs.length === 0) {
            return component;
        }
        var shadow = fluid.shadowForComponent(component);
        var getConfig = shadow ? shadow.getConfig : undefined;
        var next = fluid.get(component, segs[0], getConfig);
        // Remove this appalling travesty when we eliminate fluid.get, merging, etc. in the FLUID-6143 rewrite
        if (fluid.isComponent(next)) {
            return fluid.getForComponent(next, segs.slice(1));
        } else {
            return fluid.get(component, path, getConfig);
        }
    };

    // The EL segment resolver strategy for resolving concrete members
    fluid.concreteStrategy = function (component, thisSeg, index, segs) {
        var atval = component[thisSeg];
        if (atval === fluid.inEvaluationMarker && index === segs.length) {
            fluid.fail("Error in component configuration - a circular reference was found during evaluation of path segment \"" + thisSeg +
                "\": for more details, see the activity records following this message in the console, or issue fluid.setLogging(fluid.logLevel.TRACE) when running your application");
        }
        if (index > 1) {
            return atval;
        }
        if (atval === undefined && component.hasOwnProperty(thisSeg)) { // avoid recomputing properties that have been explicitly evaluated to undefined
            return fluid.NO_VALUE;
        }
        return atval;
    };

    // Listed in dependence order
    fluid.frameworkGrades = ["fluid.component", "fluid.modelComponent", "fluid.viewComponent", "fluid.rendererComponent"];

    fluid.filterBuiltinGrades = function (gradeNames) {
        return fluid.remove_if(fluid.makeArray(gradeNames), function (gradeName) {
            return fluid.frameworkGrades.indexOf(gradeName) !== -1;
        });
    };

    fluid.dumpGradeNames = function (that) {
        return that.options && that.options.gradeNames ?
            " gradeNames: " + JSON.stringify(fluid.filterBuiltinGrades(that.options.gradeNames)) : "";
    };

    fluid.dumpThat = function (that) {
        return "{ typeName: \"" + that.typeName + "\"" + fluid.dumpGradeNames(that) + " id: " + that.id + "}";
    };

    fluid.dumpThatStack = function (thatStack, instantiator) {
        var togo = fluid.transform(thatStack, function (that) {
            var path = instantiator.idToPath(that.id);
            return fluid.dumpThat(that) + (path ? (" - path: " + path) : "");
        });
        return togo.join("\n");
    };

    fluid.dumpComponentPath = function (that) {
        var path = fluid.pathForComponent(that);
        return path ? fluid.pathUtil.composeSegments.apply(null, path) : "** no path registered for component **";
    };

    fluid.dumpComponentAndPath = function (that) {
        return "component " + fluid.dumpThat(that) + " at path " + fluid.dumpComponentPath(that);
    };

    fluid.resolveContext = function (context, that, fast) {
        if (context === "that") {
            return that;
        } else if (context === "/") {
            return fluid.rootComponent;
        }
        // TODO: Check performance impact of this type check introduced for FLUID-5903 in a very sensitive corner
        if (typeof(context) === "object") {
            var innerContext = fluid.resolveContext(context.context, that, fast);
            if (!fluid.isComponent(innerContext)) {
                fluid.triggerMismatchedPathError(context.context, that);
            }
            var rawValue = fluid.getForComponent(innerContext, context.path);
            // TODO: Terrible, slow dispatch for this route
            var expanded = fluid.expandOptions(rawValue, that);
            if (!fluid.isComponent(expanded)) {
                fluid.fail("Unable to resolve recursive context expression " + fluid.renderContextReference(context) + ": the directly resolved value of " + rawValue +
                     " did not resolve to a component in the scope of component ", that, ": got ", expanded);
            }
            return expanded;
        } else {
            var foundComponent;
            var instantiator = fluid.globalInstantiator; // fluid.getInstantiator(that); // this hash lookup takes over 1us!
            if (fast) {
                var shadow = instantiator.idToShadow[that.id];
                return shadow.ownScope[context];
            } else {
                var thatStack = instantiator.getFullStack(that);
                fluid.visitComponentsForVisibility(instantiator, thatStack, function (component, memberName) {
                    var shadow = fluid.shadowForComponent(component);
                    var scopeValue = shadow.contextHash[context];
                    // Replace "memberName" member of contextHash from original site with memberName from injection site -
                    // need to mirror "fast" action of recordComponent in composing childrenScope
                    if (scopeValue && scopeValue !== "memberName" || context === memberName) {
                        foundComponent = component;
                        return true; // YOUR VISIT IS AT AN END!!
                    }
                });
                return foundComponent;
            }
        }
    };

    fluid.triggerMismatchedPathError = function (parsed, parentThat) {
        var ref = fluid.renderContextReference(parsed);
        fluid.fail("Failed to resolve reference " + ref + " - could not match context with name " +
            parsed.context + " from " + fluid.dumpComponentAndPath(parentThat));
    };

    fluid.makeStackFetcher = function (parentThat, localRecord, fast) {
        var fetcher = function (parsed) {
            if (parentThat && parentThat.lifecycleStatus === "destroyed") {
                fluid.fail("Cannot resolve reference " + fluid.renderContextReference(parsed) + " from component " + fluid.dumpThat(parentThat) + " which has been destroyed");
            }
            var context = parsed.context;
            if (localRecord && context in localRecord) {
                return fluid.get(localRecord[context], parsed.path);
            }
            var foundComponent = fluid.resolveContext(context, parentThat, fast);
            if (!foundComponent && parsed.path !== "") {
                fluid.triggerMismatchedPathError(parsed, parentThat);
            }
            return fluid.getForComponent(foundComponent, parsed.path);
        };
        return fetcher;
    };

    // TODO: Hoist all calls to this to a single expander per shadow
    fluid.makeStackResolverOptions = function (parentThat, localRecord, fast) {
        return $.extend(fluid.copy(fluid.rawDefaults("fluid.makeExpandOptions")), {
            localRecord: localRecord || {},
            fetcher: fluid.makeStackFetcher(parentThat, localRecord, fast),
            contextThat: parentThat,
            exceptions: {members: {model: true, modelRelay: true}}
        });
    };

    fluid.clearListeners = function (shadow) {
        // TODO: bug here - "afterDestroy" listeners will be unregistered already unless they come from this component
        fluid.each(shadow.listeners, function (rec) {
            rec.event.removeListener(rec.listenerId || rec.listener);
        });
        delete shadow.listeners;
    };

    fluid.recordListener = function (event, listener, shadow, listenerId) {
        if (event.ownerId !== shadow.that.id) { // don't bother recording listeners registered from this component itself
            fluid.pushArray(shadow, "listeners", {event: event, listener: listener, listenerId: listenerId});
        }
    };

    fluid.constructScopeObjects = function (instantiator, parent, child, childShadow) {
        var parentShadow = parent ? instantiator.idToShadow[parent.id] : null;
        childShadow.childrenScope = parentShadow ? Object.create(parentShadow.ownScope) : {};
        childShadow.ownScope = Object.create(childShadow.childrenScope);
        childShadow.parentShadow = parentShadow;
        childShadow.childComponents = {};
        fluid.cacheShadowGrades(child, childShadow);
    };

    fluid.clearChildrenScope = function (instantiator, parentShadow, child, childShadow) {
        fluid.each(childShadow.contextHash, function (troo, context) {
            if (parentShadow.childrenScope[context] === child) {
                delete parentShadow.childrenScope[context]; // TODO: ambiguous resolution
            }
        });
    };

    // unsupported, NON-API function
    fluid.doDestroy = function (that, name, parent) {
        if (that.lifecycleStatus === "destroyed") {
            fluid.fail("Cannot destroy " + fluid.dumpComponentAndPath(that) + " which has already been destroyed");
        }
        fluid.fireEvent(that, "onDestroy", [that, name || "", parent]);
        that.lifecycleStatus = "destroyed";
        for (var key in that.events) {
            if (key !== "afterDestroy" && typeof(that.events[key].destroy) === "function") {
                that.events[key].destroy();
            }
        }
        if (that.applier) { // TODO: Break this out into the grade's destroyer
            that.applier.destroy();
        }
    };

    // potentia II records look a lot like change records -
    // action: "create"/"destroy"
    // record: { type: "componentType", etc.}
    // applied: true

    // unsupported, non-API function - however, this structure is of considerable interest to those debugging
    // into IoC issues. The structures idToShadow and pathToComponent contain a complete map of the component tree
    // forming the surrounding scope
    fluid.instantiator = function () {
        var that = fluid.typeTag("instantiator");
        $.extend(that, {
            lifecycleStatus: "constructed",
            pathToComponent: {},
            idToShadow: {},
            modelTransactions: {}, // a map of transaction id to map of component id to records of components enlisted in a current model initialisation transaction
            treeTransactions: {}, // a map of transaction id to TreeTransaction - see fluid.beginTreeTransaction for initial values
            // any tree instantiation in progress. This is primarily read in order to enlist in bindDeferredComponent.
            currentTreeTransactionId: null,
            composePath: fluid.model.composePath, // For speed, we declare that no component's name may contain a period
            composeSegments: fluid.model.composeSegments,
            parseEL: fluid.model.parseEL,
            events: {
                onComponentAttach: fluid.makeEventFirer({name: "instantiator's onComponentAttach event"}),
                onComponentClear: fluid.makeEventFirer({name: "instantiator's onComponentClear event"})
            }
        });
        // Convenience method for external methods to accept path or segs
        that.parseToSegments = function (path) {
            return fluid.model.parseToSegments(path, that.parseEL, true);
        };
        // TODO: this API can shortly be removed
        that.idToPath = function (id) {
            var shadow = that.idToShadow[id];
            return shadow ? shadow.path : "";
        };
        // Note - the returned stack is assumed writeable and does not include the root
        that.getThatStack = function (component) {
            var shadow = that.idToShadow[component.id];
            if (shadow) {
                var path = shadow.path;
                var parsed = that.parseEL(path);
                var root = that.pathToComponent[""], togo = [];
                for (var i = 0; i < parsed.length; ++i) {
                    root = root[parsed[i]];
                    togo.push(root);
                }
                return togo;
            }
            else { return [];}
        };
        that.getFullStack = function (component) {
            var thatStack = component ? that.getThatStack(component) : [];
            thatStack.unshift(fluid.resolveRootComponent);
            return thatStack;
        };
        function recordComponent(parent, component, path, name, created) {
            var shadow;
            if (created) {
                shadow = that.idToShadow[component.id] = {};
                shadow.that = component;
                shadow.path = path;
                shadow.memberName = name;
                fluid.constructScopeObjects(that, parent, component, shadow);
            } else {
                shadow = that.idToShadow[component.id];
                shadow.injectedPaths = shadow.injectedPaths || {}; // a hash since we will modify whilst iterating
                shadow.injectedPaths[path] = true;
                var parentShadow = that.idToShadow[parent.id]; // structural parent shadow - e.g. resolveRootComponent
                var keys = fluid.keys(shadow.contextHash);
                fluid.remove_if(keys, function (key) {
                    return shadow.contextHash && shadow.contextHash[key] === "memberName";
                });
                keys.push(name); // add local name - FLUID-5696 and FLUID-5820
                fluid.each(keys, function (context) {
                    if (!parentShadow.childrenScope[context]) {
                        parentShadow.childrenScope[context] = component;
                    }
                });
            }
            if (that.pathToComponent[path]) {
                fluid.fail("Error during instantiation - path " + path + " which has just created component " + fluid.dumpThat(component) +
                    " has already been used for component " + fluid.dumpThat(that.pathToComponent[path]) + " - this is a circular instantiation or other oversight." +
                    " Please clear the component using instantiator.clearComponent() before reusing the path.");
            }
            that.pathToComponent[path] = component;
        }
        that.recordRoot = function (component) {
            recordComponent(null, component, "", "", true);
        };
        that.recordKnownComponent = function (parent, component, name, created) {
            parent[name] = component;
            if (fluid.isComponent(component) || component.type === "instantiator") {
                var parentShadow = that.idToShadow[parent.id];
                parentShadow.childComponents[name] = component;
                var path = that.composePath(parentShadow.path, name);
                recordComponent(parent, component, path, name, created);
                that.events.onComponentAttach.fire(component, path, that, created);
            } else {
                fluid.fail("Cannot record non-component with value ", component, " at path \"" + name + "\" of parent ", parent);
            }
        };

        that.clearConcreteComponent = function (destroyRec) {
            var shadow = destroyRec.childShadow;
            // Clear injected instance of this component from all other paths - historically we didn't bother
            // to do this since injecting into a shorter scope is an error - but now we have resolveRoot area
            fluid.each(shadow.injectedPaths, function (troo, injectedPath) {
                var parentPath = fluid.model.getToTailPath(injectedPath);
                var otherParent = that.pathToComponent[parentPath];
                that.clearComponent(otherParent, fluid.model.getTailPath(injectedPath), destroyRec.child);
            });
            fluid.clearDistributions(shadow);
            fluid.clearListeners(shadow);
            fluid.fireEvent(destroyRec.child, "afterDestroy", [destroyRec.child, destroyRec.name, destroyRec.component]);
            delete that.idToShadow[destroyRec.child.id];
        };

        that.clearComponent = function (component, name, child, options, nested, path) {
            // options are visitor options for recursive driving
            var shadow = that.idToShadow[component.id];
            // use flat recursion since we want to use our own recursion rather than rely on "visited" records
            options = options || {flat: true, instantiator: that, destroyRecs: []};
            child = child || component[name];
            path = path || shadow.path;
            if (path === undefined) {
                fluid.fail("Cannot clear component " + name + " from component ", component,
                    " which was not created by this instantiator");
            }

            var childPath = that.composePath(path, name);
            var childShadow = that.idToShadow[child.id];
            if (!childShadow) { // Explicit FLUID-5812 check - this can be eliminated once we move visitComponentChildren to instantiator's records
                return;
            }
            var created = childShadow.path === childPath;
            that.events.onComponentClear.fire(child, childPath, component, created);

            // only recurse on components which were created in place - if the id record disagrees with the
            // recurse path, it must have been injected
            if (created) {
                if (fluid.isDestroyed(child)) {
                    fluid.fail("Cannot destroy component which is already in status ", child.lifecycleStatus);
                }
                child.lifecycleStatus = "destroying";
                fluid.visitComponentChildren(child, function (gchild, gchildname, segs, i) {
                    var parentPath = that.composeSegments.apply(null, segs.slice(0, i));
                    that.clearComponent(child, gchildname, null, options, true, parentPath);
                }, options, that.parseEL(childPath));
                fluid.doDestroy(child, name, component); // call "onDestroy", null out events and invokers, setting lifecycleStatus to "destroyed"
                options.destroyRecs.push({child: child, childShadow: childShadow, name: name, component: component, shadow: shadow});
            } else {
                fluid.remove_if(childShadow.injectedPaths, function (troo, path) {
                    return path === childPath;
                });
            }
            fluid.clearChildrenScope(that, shadow, child, childShadow);
            // Note that "pathToComponent" will not be available during afterDestroy. This is so that we can synchronously recreate the component
            // in an afterDestroy listener (FLUID-5931). We don't clear up the shadow itself until after afterDestroy.
            delete that.pathToComponent[childPath];
            delete shadow.childComponents[name];
            if (!nested) {
                delete component[name]; // there may be no entry - if creation is not concluded
                // Do actual destruction for the whole tree here, including "afterDestroy" and deleting shadows
                fluid.each(options.destroyRecs, that.clearConcreteComponent);
            }
        };
        return that;
    };

    // The global instantiator, holding all components instantiated in this context (instance of Infusion)
    fluid.globalInstantiator = fluid.instantiator();

    // Look up the globally registered instantiator for a particular component - we now only really support a
    // single, global instantiator, but this method is left as a notation point in case this ever reverts
    // Returns null if argument is a noncomponent or has no shadow
    fluid.getInstantiator = function (component) {
        var instantiator = fluid.globalInstantiator;
        return component && instantiator.idToShadow[component.id] ? instantiator : null;
    };

    // The grade supplied to components which will be resolvable from all parts of the component tree
    fluid.defaults("fluid.resolveRoot");
    // In addition to being resolvable at the root, "resolveRootSingle" component will have just a single instance available. Fresh
    // instances will displace older ones.
    fluid.defaults("fluid.resolveRootSingle", {
        gradeNames: "fluid.resolveRoot"
    });

    fluid.constructRootComponents = function (instantiator) {
        // Instantiate the primordial components at the root of each context tree
        fluid.rootComponent = instantiator.rootComponent = fluid.typeTag("fluid.rootComponent");
        instantiator.recordRoot(fluid.rootComponent);

        // The component which for convenience holds injected instances of all components with fluid.resolveRoot grade
        fluid.resolveRootComponent = instantiator.resolveRootComponent = fluid.typeTag("fluid.resolveRootComponent");
        instantiator.recordKnownComponent(fluid.rootComponent, fluid.resolveRootComponent, "resolveRootComponent", true);

        // obliterate resolveRoot's scope objects and replace by the real root scope - which is unused by its own children
        var rootShadow = instantiator.idToShadow[fluid.rootComponent.id];
        rootShadow.contextHash = {}; // Fix for FLUID-6128
        var resolveRootShadow = instantiator.idToShadow[fluid.resolveRootComponent.id];
        resolveRootShadow.ownScope = rootShadow.ownScope;
        resolveRootShadow.childrenScope = rootShadow.childrenScope;

        instantiator.recordKnownComponent(fluid.resolveRootComponent, instantiator, "instantiator", true); // needs to have a shadow so it can be injected
        resolveRootShadow.childrenScope.instantiator = instantiator; // needs to be mounted since it never passes through cacheShadowGrades
    };

    fluid.constructRootComponents(fluid.globalInstantiator); // currently a singleton - in future, alternative instantiators might come back

    /** Expand a set of component options either immediately, or with deferred effect.
     *  The current policy is to expand immediately function arguments within fluid.assembleCreatorArguments which are not the main options of a
     *  component. The component's own options take <code>{defer: true}</code> as part of
     *  <code>outerExpandOptions</code> which produces an "expandOptions" structure holding the "strategy" and "initter" pattern
     *  common to ginger participants.
     *  This is pretty well-attested as a public API but only the first two arguments are stable. However, `fluid.expand` should be
     *  used by preference for standard immediate expansion.
     */

// TODO: Can we move outerExpandOptions to 2nd place? only user of 3 and 4 is fluid.makeExpandBlock
// TODO: Actually we want localRecord in 2nd place since outerExpandOptions is now almost disused
    fluid.expandOptions = function (args, that, mergePolicy, localRecord, outerExpandOptions) {
        if (!args) {
            return args;
        }
        fluid.pushActivity("expandOptions", "expanding options %args for component %that ", {that: that, args: args});
        var expandOptions = fluid.makeStackResolverOptions(that, localRecord);
        expandOptions.mergePolicy = mergePolicy;
        expandOptions.defer = outerExpandOptions && outerExpandOptions.defer;
        var expanded = expandOptions.defer ?
            fluid.makeExpandOptions(args, expandOptions) : fluid.expand(args, expandOptions);
        fluid.popActivity();
        return expanded;
    };

    fluid.computeMergeListPriority = function (toMerge) {
        toMerge.forEach(function (record) {
            var recordType = record.recordType;
            if (recordType !== "distribution") {
                record.priority = fluid.mergeRecordTypes[recordType] + (record.priorityDelta || 0);
                if (!fluid.isInteger(record.priority)) {
                    fluid.fail("Merge record with unrecognised type " + recordType + ": ", record);
                }
            }
        });
    };

    // TODO: overall efficiency could huge be improved by resorting to the hated PROTOTYPALISM as an optimisation
    // for this mergePolicy which occurs in every component. Although it is a deep structure, the root keys are all we need
    var addPolicyBuiltins = function (policy) {
        fluid.each(["gradeNames", "mergePolicy", "argumentMap", "components", "dynamicComponents", "events", "listeners", "modelListeners", "modelRelay", "distributeOptions", "transformOptions"], function (key) {
            fluid.set(policy, [key, "*", "noexpand"], true);
        });
        return policy;
    };

    // used from Fluid.js
    fluid.generateExpandBlock = function (record, that, mergePolicy, localRecord) {
        var expanded = fluid.expandOptions(record.options || {}, record.contextThat || that, mergePolicy, localRecord, {defer: true});
        expanded.priority = record.priority;
        expanded.namespace = record.namespace;
        expanded.recordType = record.recordType;
        return expanded;
    };

    fluid.fabricateDestroyMethod = function (that) {
        return function () {
            var shadow = fluid.shadowForComponent(that);
            fluid.destroy(shadow.path);
        };
    };

    // Maps a type name to the member name to be used for it at a particular path level where it is intended to be unique
    // Note that "." is still not supported within a member name
    // supported, PUBLIC API function
    fluid.typeNameToMemberName = function (typeName) {
        return typeName.replace(/\./g, "_");
    };

    /** Begin the process of expanding component options. Generates the core ``mergeBlocks'' array which drives the expansion process. Has
     * various other side-effects, such as hoisting the "container" option, adding framework builtins to the supplied mergePolicy, and computing
     * the priorities of the merge blocks, as a result of generally poor factoring in this area and work in progress.
     * @param mergePolicy {CompiledMergePolicy} A "compiled" mergePolicy object as output from `fluid.compileMergePolicy`
     * @param potentia {Potentia} The `create` potentia responsible for this component construction
     * @param lightMerge {LightMerge} The lightly merged options for the component
     * @param that {Component} The component in progress
     * @return {MergeBlock[]} An array of `MergeBlock` structures ready to mount in the `shadow.mergeOptions` structure.
     */
    // This is the initial entry point from the non-IoC side reporting the first presence of a new component - called from fluid.mergeComponentOptions
    fluid.expandComponentOptions = function (mergePolicy, potentia, lightMerge, that) {
        var toMerge = lightMerge.toMerge;
        var container = fluid.lightMergeValue(toMerge, "container");
        // hoist out "container" to be an option - eliminate this after FLUID-5750
        if (container) {
            toMerge.push({
                recordType: "distribution",
                priority: fluid.mergeRecordTypes.distribution,
                options: {
                    container: container
                },
                contextThat: potentia.parentThat
            });
        }

        that.destroy = fluid.fabricateDestroyMethod(that);

        addPolicyBuiltins(mergePolicy);
        var shadow = fluid.shadowForComponent(that);
        shadow.mergePolicy = mergePolicy;

        fluid.computeMergeListPriority(toMerge);

        var togo = fluid.transform(toMerge, function (value) {
            // There is the wacky possibility that generating these blocks might cause some immediate expansion in case the root is a bare reference
            // See "expansion order test" - we should probably prohibit this, or else try to do some "light merge" of gradeNames
            return fluid.generateExpandBlock(value, that, mergePolicy, potentia.localRecord);
        });

        fluid.popActivity();
        return togo;
    };


    fluid.computeDynamicComponentKey = function (recordKey, sourceKey) {
        return recordKey + (sourceKey === 0 ? "" : "-" + sourceKey); // TODO: configurable name strategies
    };

    fluid.concludeAnyTransaction = function () {
        var instantiator = fluid.globalInstantiator;
        var transactionId = instantiator.currentTreeTransactionId;
        if (transactionId) {
            var transRec = instantiator.treeTransactions[transactionId];
            var errorOut;
            transRec.promise.then(null, function (e) {
                errorOut = e;
            });
            fluid.commitPotentiae(transactionId);
            if (errorOut) {
                throw errorOut;
            }
        }
    };

    fluid.bindDeferredComponent = function (that, componentName, lightMerge, dynamicComponent) {
        var eventName = lightMerge.createOnEvent;
        var event = fluid.isIoCReference(eventName) ? fluid.expandOptions(eventName, that) : that.events[eventName];
        if (!event || !event.addListener) {
            fluid.fail("Error instantiating createOnEvent component with name " + componentName + " of parent ", that, " since event specification " +
                eventName + " could not be expanded to an event - got ", event);
        }
        var shadow = fluid.shadowForComponent(that);
        if (dynamicComponent) {
            fluid.set(shadow, ["dynamicComponentCount", componentName], 0);
        }
        var constructListener = function () {
            var key = dynamicComponent ?
                fluid.computeDynamicComponentKey(componentName, shadow.dynamicComponentCount[componentName]++) : componentName;
            var localRecord = {
                "arguments": fluid.makeArray(arguments)
            };
            fluid.pushActivity("initDeferred", "instantiating deferred component %componentName of parent %that due to event %eventName",
             {componentName: componentName, that: that, eventName: eventName});
            var freshLightMerge = fluid.copy(lightMerge);
            delete freshLightMerge.createOnEvent;
            fluid.registerConcreteSubPotentia(freshLightMerge, key, 0, that, localRecord);
            fluid.popActivity();
        };
        event.addListener(constructListener);
        fluid.recordListener(event, constructListener, shadow);
        event.addListener(fluid.concludeAnyTransaction, "fluid-componentConstruction", "last:transaction");
        fluid.recordListener(event, fluid.concludeAnyTransaction, shadow);
    };

    fluid.markSubtree = function (instantiator, that, path, state) {
        that.lifecycleStatus = state;
        fluid.visitComponentChildren(that, function (child, name) {
            var childPath = instantiator.composePath(path, name);
            var childShadow = instantiator.idToShadow[child.id];
            var created = childShadow && childShadow.path === childPath;
            if (created) {
                fluid.markSubtree(instantiator, child, childPath, state);
            }
        }, {flat: true});
    };

    fluid.assessTreeConstruction = function (that, shadow) {
        var instantiator = fluid.globalInstantiator;
        var thatStack = instantiator.getThatStack(that);
        var unstableUp = fluid.find_if(thatStack, function (that) {
            return that.lifecycleStatus === "constructing";
        });
        if (unstableUp) {
            that.lifecycleStatus = "constructed";
        } else {
            fluid.markSubtree(instantiator, that, shadow.path, "treeConstructed");
        }
    };

    /** Conclude the component's "observation" process by fully evaluating all options, members and invokers that have
     * not already been evaluated, and read the `components` and `dynamicComponents` area to schedule the construction
     * of any deferred subcomponents.
     * @param {Shadow} shadow - The shadow for the component for which observation should be concluded
     */
    fluid.concludeComponentObservation = function (shadow) {
        var that = shadow.that;
        var mergeOptions = shadow.mergeOptions;
        fluid.pushActivity("concludeComponentObservation", "constructing component of type %componentName at path %path",
            {componentName: that.typeName, path: shadow.path});

        for (var i = 0; i < mergeOptions.mergeBlocks.length; ++i) {
            mergeOptions.mergeBlocks[i].initter();
        }
        mergeOptions.initter();
        delete that.options.mergePolicy; // silly "optimisation" - make this immutable instead

        shadow.memberStrategy.initter();
        shadow.invokerStrategy.initter();

        fluid.each(shadow.lightMergeComponents, function (lightMerge, key) {
            if (lightMerge.createOnEvent) {
                fluid.bindDeferredComponent(that, key, lightMerge);
            }
        });

        fluid.each(shadow.lightMergeDynamicComponents, function (lightMerge, key) {
            if (lightMerge.createOnEvent) {
                fluid.bindDeferredComponent(that, key, lightMerge, true);
            }
        });
        fluid.popActivity();
    };

    fluid.concludeComponentInit = function (shadow) {
        var that = shadow.that;
        if (fluid.isDestroyed(that)) {
            return; // Further fix for FLUID-5869 - if we managed to destroy ourselves through some bizarre model self-reaction, bail out here
        }
        that.lifecycleStatus = "constructed";
        fluid.assessTreeConstruction(that, shadow);

        that.events.onCreate.fire(that);
        fluid.popActivity();

        return that;
    };

    /** Amalgamates any further creations with any existing potentia at a path
    * @param {PotentiaList} potentiaList - A `PotentiaList` structure as constructed by `fluid.blankPotentiaList` holding the potentiae in
    *     progress for a particular tree transaction
    * @param {String} path - Path at which the potentia will be registered
    * @param {Potentia} topush - A "create" potentia
    * @return {Potentia|Undefined} `topush` if this was the first potentia registered for this path
    */
    fluid.pushCreatePotentia = function (potentiaList, path, topush) {
        var existing = potentiaList.pathToPotentia[path];
        if (existing && !existing.applied) {
            fluid.lightMergeRecords.pushRecords(existing, topush.records || topush.lightMerge.toMerge);
        } else {
            potentiaList.pathToPotentia[path] = topush;
            if (topush.records) {
                topush.lightMerge = fluid.lightMergeRecords(topush.records);
                delete topush.records;
            }
            return topush;
        }
    };

    fluid.blankPotentiaList = function () {
        return {
            destroys: [],
            creates: [],
            activeCount: 0,
            pathToPotentia: {} // map of component paths to list of option records for create potentia
        };
    };

    fluid.isInjectedComponentRecord = function (record) {
        return typeof(record) === "string" || record.expander;
    };

    fluid.lightMergeValue = function (records, member) {
        var value;
        records.forEach(function (record) {
            var recValue = record[member];
            value = recValue === undefined ? value : recValue;
        });
        return value;
    };

    /** @typedef {Object} LightMerge
     *    @property {Boolean} isInjected - whether these designate an injected component
     *    @property {String} type - the component's type if it is concrete
     *    @property {String} createOnEvent - the component's "createOnEvent" if any record set it
     *    @property {OptionsRecords[]} toMerge - Array of component options to be merged
     */

    /** Perform a "light merge" of a set of options records in order to immediately discover the type name if they designate a
     * concrete component or whether they designate an injected component.
     * @param {OptionsRecords[]} records - Array of component options records as held in {Potentia}.records
     * @return {LightMerge} A structure holding the lightly merged options records
     */
    fluid.lightMergeRecords = function (records) {
        var togo = {
            toMerge: [],
            isInjected: false
        };
        fluid.lightMergeRecords.pushRecords(togo, records);
        return togo;
    };

    fluid.lightMergeRecords.pushRecord = function (lightMerge, record) {
        if (fluid.isInjectedComponentRecord(record)) {
            lightMerge.toMerge = [{injected: record}];
            lightMerge.isInjected = true;
        } else {
            lightMerge.type = record.type || lightMerge.type;
            lightMerge.createOnEvent = record.createOnEvent || lightMerge.createOnEvent;
            lightMerge.source = record.source || lightMerge.source;
            lightMerge.sources = record.sources || lightMerge.sources;
            if (lightMerge.isInjected) {
                lightMerge.toMerge = [record];
            } else {
                lightMerge.toMerge.push(record);
            }
            lightMerge.isInjected = false;
        }
    };

    fluid.lightMergeRecords.pushRecords = function (lightMerge, records) {
        records.forEach(function (record) {
            fluid.lightMergeRecords.pushRecord(lightMerge, record);
        });
    };

    fluid.instantiateEvents = function (shadow) {
        var that = shadow.that;
        shadow.eventStrategyBlock.initter();
        var listeners = fluid.getForComponent(that, ["options", "listeners"]);
        fluid.mergeListeners(that, that.events, listeners);

        var errors = fluid.validateListenersImplemented(that);
        if (errors.length > 0) {
            fluid.fail(fluid.transform(errors, function (error) {
                return ["Error constructing component ", that, " - the listener for event " + error.name + " with namespace " + error.namespace + (
                    (error.componentSource ? " which was defined in grade " + error.componentSource : "") + " needs to be overridden with a concrete implementation")];
            })).join("\n");
        }
    };

    /**
     * Creates the shell of a component, evaluating enough of its structure to determine its grade content but
     * without creating events or (hopefully) any side-effects
     *
     * @param {Potentia} potentia - Creation potentia for the component
     * @param {LightMerge} lightMerge - A set of lightly merged component options as returned from `fluid.lightMergeRecords`
     * @return {Component|Null} A component shell which has begun the process of construction, or `null` if the component
     * has been configured away by resolving to the type "fluid.emptySubcomponent"
     */
    fluid.initComponentShell = function (potentia, lightMerge) {
        // Recall that this code used to be in fluid.assembleCreatorArguments
        var instantiator = fluid.globalInstantiator,
            upDefaults = fluid.defaults(lightMerge.type),
            parentThat = potentia.parentThat,
            memberName = potentia.memberName,
            fakeThat = {};
        var distributions = fluid.receiveDistributions(parentThat, upDefaults && upDefaults.gradeNames, memberName, fakeThat);
        fluid.each(distributions, function (distribution) { // TODO: The duplicated route for this is in fluid.mergeComponentOptions
            fluid.computeDistributionPriority(parentThat, distribution);
            if (fluid.isPrimitive(distribution.priority)) { // TODO: These should be immutable and parsed just once on registration - but we can't because of crazy target-dependent distance system
                distribution.priority = fluid.parsePriority(distribution.priority, 0, false, "options distribution");
            }
        });
        fluid.sortByPriority(distributions);
        fluid.lightMergeRecords.pushRecords(lightMerge, distributions);
        // Update our type and initial guess at defaults based on distributions to type
        upDefaults = fluid.defaults(lightMerge.type);

        // TODO: Once we stabilise, experiment with not copying this already immutable record
        // TODO: This fails, for example, when driving "mergePolicy" in FLUID-4129 test. It seems that the default behaviour
        // of fluid.expand is to contemptibly alias to the source
        var defaultCopy = fluid.copy(upDefaults);
        lightMerge.toMerge.unshift({
            options: defaultCopy,
            recordType: "defaults"
        });

        var that = lightMerge.type === "fluid.emptySubcomponent" ? null : fluid.typeTag(lightMerge.type, potentia.componentId);
        if (that) {
            that.lifecycleStatus = "constructing";
            instantiator.recordKnownComponent(parentThat, that, memberName, true);
            // mergeComponentOptions computes distributeOptions which is essential for evaluating the meaning of shells everywhere
            var mergeOptions = fluid.mergeComponentOptions(that, potentia, lightMerge);
            mergeOptions.exceptions = {members: {model: true, modelRelay: true}}; // don't evaluate these in "early flooding" - they must be fetched explicitly
            that.events = {};
        }
        return that;
    };

    fluid.registerConcreteSubPotentia = function (lightMerge, key, componentDepth, parentShell, localRecord, transactionId) {
        // "componentDepth" is currently unused but will be incorporated in mergeBlocks sort for refined versions of FLUID-5614
        componentDepth = componentDepth || 0;
        var newSegs = fluid.pathForComponent(parentShell).concat([key]);
        var existing = parentShell[key];
        if (existing) {
            fluid.registerPotentia({
                segs: newSegs,
                type: "destroy"
            }, transactionId);
        }
        lightMerge.toMerge = fluid.transform(lightMerge.toMerge, function (toMerge) {
            var record = $.extend({
                componentDepth: componentDepth + 1,
                sourceComponentId: parentShell.id,
                recordType: "subcomponentRecord"
            }, toMerge);
            return record;
        });
        lightMerge.type = fluid.expandImmediate(lightMerge.type, parentShell, localRecord);
        var subPotentia = {
            type: "create",
            segs: newSegs,
            lightMerge: lightMerge,
            //records: [record],
            // This is awkward - what if we accumulate multiple records with different localRecords?
            // Can't do much about this without "local mergePolicies" and provenance
            localRecord: localRecord
        };
        fluid.registerPotentia(subPotentia, transactionId);
    };

    // These are stashed in the shadow in between the use of fluid.processComponentShell and fluid.concludeComponentObservation
    fluid.lightMergeComponentRecord = function (shadow, shadowKey, key, mergingArray) {
        var lightMerge = fluid.lightMergeRecords(mergingArray);
        fluid.set(shadow, [shadowKey, key], lightMerge);
        return lightMerge;
    };

    fluid.componentRecordExpected = fluid.arrayToHash(["type", "options", "container", "createOnEvent"]);
    fluid.dynamicComponentRecordExpected = $.extend({}, fluid.componentRecordExpected, fluid.arrayToHash(["source", "sources"]));

    fluid.checkComponentRecord = function (localRecord, expected) {
        if (!fluid.isInjectedComponentRecord(localRecord)) {
            fluid.each(localRecord, function (value, key) {
                if (!expected[key]) {
                    fluid.fail("Probable error in subcomponent record ", localRecord, " - key \"" + key +
                        "\" found, where the only legal options are " +
                        fluid.keys(expected).join(", "));
                }
            });
        }
    };

    fluid.checkSubcomponentRecords = function (subcomponentRecords, expected) {
        subcomponentRecords.forEach(function (oneRecord) {
            fluid.checkComponentRecord(oneRecord, expected);
        });
    };

    fluid.registerSourcedDynamicComponent = function (potentia, shell, source, sourceKey, lightMerge, key, localRecordContributor) {
        var localRecord = $.extend({}, potentia.localRecord, {"source": source, "sourcePath": sourceKey});
        (localRecordContributor || fluid.identity)(localRecord, source, sourceKey);
        var dynamicKey = fluid.computeDynamicComponentKey(key, sourceKey);
        var freshLightMerge = fluid.copy(lightMerge);
        fluid.registerConcreteSubPotentia(freshLightMerge, dynamicKey, potentia.componentDepth, shell, localRecord);
    };

    fluid.registerSourcedDynamicComponents = function (potentia, shell, sources, lightMerge, key, localRecordContributor) {
        fluid.each(sources, function (source, sourceKey) {
            fluid.registerSourcedDynamicComponent(potentia, shell, source, sourceKey, lightMerge, key, localRecordContributor);
        });
    };

    /** The model listener constributed into a component holding model-sourced dynamic components (lensed components) by
     * `fluid.lensedComponentDefToBlock`. It observes appearance and disappearance of model material and gears this into
     * construction or destruction of the corresponding components.
     * @param {Component} that - The component holding a lensed component definition
     * @param {String} key - The key of the dynamicComponents record holding the definition
     * @param {String[]} segs - The path of the incoming change as registered by the model listener
     * @param {Any} value - The new model value held at path `segs`
     * @param {Boolean} isBoolean - `true` if this was a definition of a boolean-sourced model component, in which case the relevant
     *     model path will be one segment shorter (a listener to <path> rather than <path.*>
     */
    fluid.lensedComponentModelListener = function (that, key, segs, value, isBoolean) {
        var isEmptyValue = function (value) {
            return isBoolean ? !value : value === undefined;
        };
        var shadow = fluid.shadowForComponent(that);
        var sourceKey = isBoolean ? 0 : fluid.peek(segs);
        var expectedMemberName = fluid.computeDynamicComponentKey(key, sourceKey);
        var currentComponent = that[expectedMemberName];
        if (!isEmptyValue(value) && !currentComponent) {
            var lightMerge = shadow.lightMergeDynamicComponents[key];
            var parentRecord = shadow.modelSourcedDynamicComponents[key];
            fluid.registerSourcedDynamicComponent(shadow.potentia, that, value, sourceKey, lightMerge, key,
                parentRecord.localRecordContributor);
        } else if (isEmptyValue(value) && currentComponent) {
            currentComponent.destroy();
        }
    };

    /** Convert the definition of a lensed component as found in `dynamicComponents` into the options block that
     * encodes the model listener managing the creation and destruction of the corresponding components.
     * @param {String} key - The key for the `dynamicComponents` record
     * @param {ParsedModelReference} sourcesParsed - The parsed representation of the `source` or `sources` entry in the dynamicComponents record
     * @param {Boolean} isBoolean - `true` if the source entry was `source` rather than `sources` and this is the encoding of a
     * boolean-sourced dynamic component
     * @return {ComponentOptions} A block of component options encoding the required model listener
     */
    fluid.lensedComponentDefToBlock = function (key, sourcesParsed, isBoolean) {
        var fromModelPath = sourcesParsed.segs.slice(1);
        var modelListener = {
            path: {
                context: sourcesParsed.context,
                segs: fromModelPath.concat(isBoolean ? [] : ["*"])
            },
            excludeSource: "init",
            funcName: "fluid.lensedComponentModelListener",
            args: ["{that}", key, "{change}.path", "{change}.value", isBoolean]
        };
        var modelListeners = {};
        modelListeners["lensedComponents-" + key] = modelListener;
        return {
            modelListeners: modelListeners
        };
    };

    /** Add the supplied options blocks to the currently instantiating component's merge blocks with the special record
     * type "lensedComponents", and resort them ready to evaluate during the upcoming modelComponent workflow
     * @param {ComponentOptions[]} lensedComponentBlocks - Array of component options as returned from `fluid.lensedComponentsToBlock` - these will be
     * merged together into a single "expand block" and inserted into the constructing component's blocks
     * @param {Potentia} potentia - The "create" potentia responsible for the construction of this component
     * @param {Shadow} shadow - The shadow record for the constructing component
     */
    fluid.addLensedComponentBlocks = function (lensedComponentBlocks, potentia, shadow) {
        var merged = fluid.extend.apply(null, [true, {}].concat(lensedComponentBlocks));
        // cf. defaultValueMerge in fluid.mergeComponentOptions
        shadow.mergeOptions.mergeBlocks.push(fluid.generateExpandBlock({
            options: merged,
            recordType: "lensedComponents",
            priority: fluid.mergeRecordTypes.lensedComponents
        }, shadow.that, shadow.mergePolicy, potentia.localRecord));
        shadow.mergeOptions.updateBlocks();
    };

    /** Schematic checking utility which verifies that a supplied record contains exactly one field set (with value other than
     * `undefined` from a list of options. If zero or more than 1 of the members are found, `fluid.fail` will be invoked with
     * a diagnostic message.
     * @param {Object[]} failStart - Array of prefix arguments to be sent to `fluid.fail` in the event of a failure.
     * @param {Object} target - The object to be checked for populated members
     * @param {String[]} members - The list of members to check `target` for
     */
    fluid.expectExactlyOne = function (failStart, target, members) {
        var found = 0;
        members.forEach(function (member) {
            if (target[member] !== undefined) {
                ++found;
            }
        });
        if (found !== 1) {
            fluid.fail.apply(null, failStart.concat([" must contain exactly one member out of " + members.join(", ")]));
        }
    };

    /** Front entry point for registering one or more dynamic component records based on the discovery of source material.
     * Depending on whether this is a boolean sourced component (one with `source` set in its record rather than `sources`, and
     * signalled by `isBoolean` set to true), it will forward to `fluid.registerSourcedDynamicComponent` to register a single
     * component with key 0 or `fluid.registerSourcedDynamicComponents" to register one for each path in `sourceOrSources`
     * @param {Potentia} potentia - The create potentia responsible for constructing the component holding the dynamic subcomponents
     * @param {Component} shell - The constructing component, still at `shell` stage with minimal options populated.
     * @param {Booleanish|Object|Array} sourceOrSources - The source material for the dynamic components. If `isBoolean` is true, this will be
     *     a Booleanish value, otherwise a structure encoding for multiple components.
     * @param {LightMerge} lightMerge - The lightly merged options for the upcoming dynamic subcomponent(s)
     * @param {String} key - The key of the dynamic component record
     * @param {Boolean} isBoolean - `true` if this is a boolean sourced dynamic component
     * @param {Function} localRecordContributor - A function accepting the `localRecord` structure to be registered for the dynamic components, which will
     *     contribute the `sourceModelReference` member holding the parsed reference to the source model value (if any). This
     *     function is currently implemented in `fluid.constructLensedComponents` in DataBinding.js
     */
    fluid.registerSourcedDynamicComponentsTriage = function (potentia, shell, sourceOrSources, lightMerge, key, isBoolean, localRecordContributor) {
        if (isBoolean) {
            fluid.registerSourcedDynamicComponent(potentia, shell, sourceOrSources, 0, lightMerge, key, localRecordContributor);
        } else {
            fluid.registerSourcedDynamicComponents(potentia, shell, sourceOrSources, lightMerge, key, localRecordContributor);
        }
    };

    // The midpoint of fluid.operateCreatePotentia. We have just created the shell, and will now investigate any subcomponents
    // and push any immediate ones discovered into potentia records at deeper paths.
    fluid.processComponentShell = function (potentia, shell, transRec) {
        var instantiator = fluid.globalInstantiator;
        var shadow = instantiator.idToShadow[shell.id];
        shadow.potentia = potentia;

        var mergeOptions = shadow.mergeOptions;

        var components = fluid.driveStrategy(shell.options, "components", mergeOptions.strategy);

        fluid.each(components, function (subcomponentRecords, key) {
            fluid.checkSubcomponentRecords(subcomponentRecords, fluid.componentRecordExpected);
            var lightMerge = fluid.lightMergeComponentRecord(shadow, "lightMergeComponents", key, subcomponentRecords);
            if (!lightMerge.createOnEvent) {
                fluid.registerConcreteSubPotentia(lightMerge, key, potentia.componentDepth, shell, potentia.localRecord);
            }
        });
        var dynamicComponents = fluid.driveStrategy(shell.options, "dynamicComponents", mergeOptions.strategy);
        var lensedComponentBlocks = [];
        fluid.each(dynamicComponents, function (subcomponentRecords, key) {
            fluid.checkSubcomponentRecords(subcomponentRecords, fluid.dynamicComponentRecordExpected);
            var lightMerge = fluid.lightMergeComponentRecord(shadow, "lightMergeDynamicComponents", key, subcomponentRecords);
            fluid.expectExactlyOne(["dynamicComponents records ", subcomponentRecords], lightMerge,
                ["source", "sources", "createOnEvent"]);
            if (lightMerge.sources !== undefined || lightMerge.source !== undefined) {
                var recordSources = lightMerge.sources, isBoolean = false;
                if (lightMerge.source !== undefined) {
                    recordSources = lightMerge.source;
                    isBoolean = true;
                }
                var sources;
                if (fluid.isIoCReference(recordSources)) {
                    var sourcesParsed = fluid.parseValidModelReference(shell, "dynamicComponents source", recordSources, true);
                    if (sourcesParsed.nonModel) {
                        sources = fluid.getForComponent(sourcesParsed.that, sourcesParsed.segs);
                        fluid.registerSourcedDynamicComponentsTriage(potentia, shell, sources, lightMerge, key, null, isBoolean);
                    } else {
                        fluid.set(shadow, ["modelSourcedDynamicComponents", key], {
                            sourcesParsed: sourcesParsed,
                            isBoolean: isBoolean
                        });
                        lensedComponentBlocks.push(fluid.lensedComponentDefToBlock(key, sourcesParsed, isBoolean));
                        // Construction will now be handled after fluid.initModelTransaction in DataBinding.js
                    }
                } else {
                    sources = fluid.expandImmediate(recordSources, shell, potentia.localRecord); // it still might be an expander
                    fluid.registerSourcedDynamicComponentsTriage(potentia, shell, sources, lightMerge, key, null, isBoolean);
                }
            }
        });
        if (lensedComponentBlocks.length) {
            fluid.addLensedComponentBlocks(lensedComponentBlocks, potentia, shadow);
        }
        if (transRec.deferredDistributions.length) { // Resolve FLUID-6193 in potentia world by enqueueing deferred distributions
            transRec.pendingPotentiae.creates.push({
                type: "distributeOptions",
                distributions: transRec.deferredDistributions
            });
            ++transRec.pendingPotentiae.activeCount;
            transRec.deferredDistributions = [];
        }
    };

    /** Cache some frequently used quantities in a potentia with a path (as opposed to a pure distribution potentia)
     * - segs, memberName and parentThat.
     */

    fluid.preparePathedPotentia = function (potentia, instantiator) {
        var segs = potentia.segs || instantiator.parseToSegments(potentia.path);
        potentia.segs = segs;
        potentia.memberName = fluid.peek(segs);
        potentia.parentThat = fluid.getImmediate(fluid.rootComponent, segs.slice(0, -1));
    };

    // Fetch the component referred to if a createPotentia is determined to hold an injected component reference.
    // This is more complex than it needs to be because of the potential for references to concrete components which
    // are further along in the potentia list. This used to be handled by the old-fashioned one-step
    // "ginger component reference" system and needs to be harmonised some day, perhaps via "light promises".
    fluid.fetchInjectedComponentReference = function (transRec, potentiaList, injected, parentThat) {
        var instantiator = fluid.globalInstantiator;
        if (injected.expander) {
            return fluid.expandImmediate(injected, parentThat);
        } else {
            var parsed = fluid.parseContextReference(injected);
            var head = fluid.resolveContext(parsed.context, parentThat);
            if (!head) {
                if (parsed.path !== "") {
                    fluid.fail("Error in injected component reference ", injected, " - could not resolve context {" + parsed.context + "} to a head component");
                } else {
                    return head;
                }
            } else {
                var parentPath = instantiator.idToShadow[head.id].path;
                var fullPath = fluid.composePath(parentPath, parsed.path);
                var current = instantiator.pathToComponent[fullPath];
                if (current) {
                    return current;
                } else { // possible forward reference
                    var upcoming = potentiaList.pathToPotentia[fullPath];
                    if (upcoming) {
                        if (upcoming.applied) {
                            fluid.fail("Circular reference found when resolving injected component reference ", injected, " - the target of the reference is still in construction");
                        } else {
                            return fluid.operateOneCreatePotentia(transRec, upcoming);
                        }
                    }
                }
            }
        }
    };

    // Begin the action of creating a component - register its shell and mergeOptions at the correct site, and evaluate
    // and scan options for its child components, recursively registering them
    // Returns shadow of created shell, if any
    fluid.operateCreatePotentia = function (transRec, potentiaList, potentia) {
        var instantiator = fluid.globalInstantiator;
        fluid.preparePathedPotentia(potentia, instantiator);
        // TODO: currently this overall workflow is synchronous and so we have no risk. In future, asynchronous
        // transactions imply that the same path may receive a component from two different transactions - therefore
        // we will need to pass the transaction along to these methods and allocate the components themselves within
        // the transRec and only commit them if they are conflict-free (a la Kulkarni)
        var memberName = potentia.memberName,
            parentThat = potentia.parentThat,
            shell;

        fluid.pushActivity("operateCreatePotentia", "operating create potentia for path \"%path\" with records %records",
            {path: potentia.path, records: potentia.records});

        var lightMerge = potentia.lightMerge;
        if (lightMerge.isInjected) {
            parentThat[memberName] = fluid.inEvaluationMarker; // support FLUID-5694
            var instance = fluid.fetchInjectedComponentReference(transRec, potentiaList, lightMerge.toMerge[0].injected, parentThat);
            if (instance) {
                instantiator.recordKnownComponent(parentThat, instance, memberName, false);
            } else {
                delete parentThat[memberName];
            }
        } else if (lightMerge.type) {
            shell = fluid.initComponentShell(potentia, lightMerge);
            if (shell) {
                fluid.processComponentShell(potentia, shell, transRec);
            }
        } else {
            fluid.fail("Unrecognised material in place of subcomponent " + memberName + " - could not recognise the records ",
                potentia.records, " as designating either an injected or concrete component");
        }

        fluid.pushPotentia(transRec.restoreRecords, instantiator, {
            type: "destroy",
            segs: potentia.segs
        });
        fluid.popActivity();
        if (shell) {
            return instantiator.idToShadow[shell.id];
        }
    };

    fluid.operateDestroyPotentia = function (transRec, potentia, instantiator) {
        instantiator = instantiator || fluid.globalInstantiator;
        fluid.preparePathedPotentia(potentia, instantiator);
        var that = fluid.getImmediate(fluid.rootComponent, potentia.segs);
        if (that) {
            // var shadow = fluid.shadowForComponent(that);
            instantiator.clearComponent(potentia.parentThat, potentia.memberName, that);
            // We would like to store the record that if this transaction is cancelled, the potentia which constructed
            // this component should be used to recreate it.
            // However, this is pretty esoteric currently since we don't have WHITEHEADIAN OBSERVATION, and we are not
            // exception-safe in the case that this re-creation itself throws, so this is commented out for now
            // fluid.pushPotentia(transRec.restoreRecords, instantiator, shadow.potentia);
        }
    };

    fluid.lookupWorkflowStage = function (workflowName) {
        if (!workflowName) {
            return fluid.workflowCacheSorted.length;
        } else if (workflowName === "shells") {
            return 0;
        } else {
            var found = fluid.find_if(fluid.workflowCacheSorted, function (workflowEntry) {
                return workflowEntry.workflowName === workflowName;
            });
            if (found) {
                return found.index + 1;
            } else {
                fluid.fail("Unknown workflow name " + workflowName + " supplied as \"breakAt\" for tree transaction: "
                    + ": valid names are " + fluid.getMembers(fluid.workflowCacheSorted, "workflowName").join(", "));
            }
        }
    };

    fluid.evaluateWorkflows = function (shadows, workflowType) {
        var togo = [];
        fluid.workflowCacheSorted[workflowType].forEach(function (workflowRecord) {
            var workflowShadows = shadows.filter(function (oneShadow) {
                return fluid.componentHasGrade(oneShadow.that, workflowRecord.gradeName);
            });
            if (workflowShadows.length > 0) {
                togo.push({
                    shadows: shadows,
                    workflowIndex: workflowRecord.index,
                    workflowOptions: workflowRecord.workflowOptions
                });
            }
        });
        return togo;
    };

    fluid.findWorkflowShadows = function (shadows, blockStart, blockEnd, workflowRecord) {
        var workflowShadows = [];
        for (var i = blockStart; i < blockEnd; ++i) {
            if (fluid.componentHasGrade(shadows[i].that, workflowRecord.gradeName)) {
                if (workflowRecord.workflowType === "global") {
                    workflowShadows.push(shadows[i]);
                } else {
                    workflowShadows.unshift(shadows[i]);
                }
            }
        }
        return workflowShadows;
    };

    fluid.waitPendingIOTask = function (transRec) {
        var instantiator = fluid.globalInstantiator;
        var resumeCurrentTransaction = function () {
            instantiator.currentTreeTransactionId = transRec.transactionId;
        };
        var bracketIO = function (sequence) {
            return sequence.concat([resumeCurrentTransaction]);
        };
        var sequence;
        var waitIOTask = function () {
            return transRec.pendingIO.length ? (sequence = fluid.promise.sequence(bracketIO(transRec.pendingIO))) : null;
        };
        waitIOTask.taskName = "waitIO";
        waitIOTask.sequence = sequence;
        return waitIOTask;
    };

    fluid.enqueueWorkflowBlock = function (transRec, shadows, workflowStart, workflowEnd, blockStart, blockEnd, sequencer) {
        var workQueued = false;
        transRec.lastWorkflowShadow = Math.max(transRec.lastWorkflowShadow, blockEnd);
        fluid.forEachInRange(fluid.workflowCacheSorted, workflowStart, workflowEnd, function (workflowRecord, workflowIndex) {
            if (workflowIndex === 0) {
                for (var i = blockStart; i < blockEnd; ++i) {
                    fluid.instantiateEvents(shadows[i]);
                }
            }
            var workflowShadows = fluid.findWorkflowShadows(shadows, blockStart, blockEnd, workflowRecord);
            transRec.maximumWorkflowStage = Math.max(transRec.maximumWorkflowStage, workflowIndex + 1);
            if (workflowShadows.length > 0) {
                var workflow = workflowRecord.workflowOptions;
                var workflowFunc = fluid.getGlobalValue(workflow.funcName);
                var sequence = sequencer.sources;
                if (workflow.waitIO) {
                    sequence.push(fluid.waitPendingIOTask(transRec));
                }
                if (workflowRecord.workflowType === "global") {
                    var globalWorkflowTask = function () {
                        workflowFunc(workflowShadows, transRec);
                    };
                    globalWorkflowTask.taskName = workflowRecord.namespace;
                    sequence.push(globalWorkflowTask);
                } else {
                    var localWorkflowTask = function () {
                        if (workflowRecord.namespace === "concludeComponentInit") {
                            sequencer.hasStartedConcludeInit = true;
                        }
                        workflowShadows.forEach(function (shadow) {
                            workflowFunc(shadow, transRec);
                        });
                    };
                    localWorkflowTask.taskName = workflowRecord.namespace;
                    sequence.push(localWorkflowTask);
                }
                workQueued = true;
            }
        });
        return workQueued;
    };

    /** Enqueue one phase of workflow actions on an array of freshly constructed component shells. This embodies `ModelComponentQix` -
     * By preference, we enqueue the action on any freshly constructed shells of bringing them to the same state of readiness of the
     * most advanced component. If there are no such, we continue bringing the array of all shadows up to the maximum required
     * level. Only one of these actions will be enqueued per call to this function - the driver in fluid.commitPotentiae will redispatch
     * here repeatedly until no further work is enqueued.
     * @param {TreeTransaction} transRec - The tree transaction in progress
     * @param {fluid.promise.sequencer} sequencer - The sequencer to accumulate workflow actions generated during this phase
     * @return {Boolean} `true` if any actions were enqueued
     */
    fluid.applyWorkflowPhase = function (transRec, sequencer) {
        var shadows = transRec.outputShadows;
        // Bring any freshly created shadows to the same level as the most currently advanced
        if (shadows.length > transRec.lastWorkflowShadow && transRec.maximumWorkflowStage > 0) {
            fluid.enqueueWorkflowBlock(transRec, shadows, 0, transRec.maximumWorkflowStage,
                transRec.lastWorkflowShadow, shadows.length, sequencer);
            return true;
        } else if (transRec.maximumWorkflowStage < transRec.workflowStageBreak) {
            // They must all be level - bring the level of all shadows to final level
            for (var workflowStage = transRec.maximumWorkflowStage; workflowStage < transRec.workflowStageBreak; ++workflowStage) {
                var workQueued = fluid.enqueueWorkflowBlock(transRec, shadows, workflowStage, workflowStage + 1,
                    0, shadows.length, sequencer);
                if (workQueued) {
                    return workQueued;
                }
            }
        }
    };

    // Tightly bound to commitPotentiaePhase - broken out as a function so that we can call it from
    // fluid.fetchInjectedComponentReference for out-of-order construction.
    fluid.operateOneCreatePotentia = function (transRec, potentia) {
        potentia.applied = true;
        --transRec.pendingPotentiae.activeCount;
        var shadow = fluid.operateCreatePotentia(transRec, transRec.pendingPotentiae, potentia);
        if (shadow) {
            transRec.outputShadows.push(shadow);
        }
        return shadow && shadow.that;
    };

    /** Operate one phase of a tree transaction, consisting of a list of component destructions and a list of
     * component creations.
     * @param {TreeTransaction} transRec - The tree transaction in progress
     * @param {fluid.promise.sequencer} sequencer - The sequencer to accumulate workflow actions generated during this phase
     */
    fluid.commitPotentiaePhase = function (transRec) {
        var pendingPotentiae = transRec.pendingPotentiae;
        pendingPotentiae.destroys.forEach(function (potentia) {
            if (!potentia.applied) {
                // flag this first in case destroy synchronously schedules a further destroy and hence re-entry into
                // fluid.commitPotentiae and hence this function
                potentia.applied = true;
                --pendingPotentiae.activeCount;
                fluid.operateDestroyPotentia(transRec, potentia);
            }
        });
        for (var i = 0; i < pendingPotentiae.creates.length; ++i) {
            var potentia = pendingPotentiae.creates[i]; // not "forEach" since further elements will accumulate during construction
            if (!potentia.applied) {
                if (potentia.type === "create") {
                    fluid.operateOneCreatePotentia(transRec, potentia);
                } else if (potentia.type === "distributeOptions") {
                    potentia.distributions.forEach(function (distro) {
                        fluid.distributeOptionsOne(distro.that, distro.record, distro.targetRef, distro.selector, distro.context);
                    });
                    potentia.applied = true;
                    --pendingPotentiae.activeCount;
                } else {
                    fluid.fail("Unrecognised potentia type " + potentia.type);
                }
            }
        }
    };

    fluid.isPopulatedPotentiaList = function (potentiaList) {
        return potentiaList.activeCount > 0;
    };

    /** Commit all potentiae that have been enqueued through calls to fluid.registerPotentia for the supplied transaction,
     * as well as any further potentiae which become enqueued through construction of these, potentially in multiple phases
     * @param {String} transactionId - The id of the tree transaction to be committed - this must already have been started
     * with `fluid.beginTreeTransaction`.
     * @return {Shadow|Undefined} The shadow record for the first component to be constructed during the transaction phase, if any.
     */
    fluid.commitPotentiae = function (transactionId) {
        var instantiator = fluid.globalInstantiator;
        var transRec = instantiator.treeTransactions[transactionId];
        ++transRec.commitDepth;
        var lastWorkflowShadow = transRec.lastWorkflowShadow;
        var rootSequencer = transRec.rootSequencer;
        var sequencer;
        var topSequencer = fluid.getImmediate(fluid.peek(rootSequencer.sources), ["sequencer"]);
        if (!topSequencer || topSequencer.hasStartedConcludeInit || topSequencer.promise.disposition) {
            sequencer = fluid.promise.makeSequencer([], {}, fluid.promise.makeSequenceStrategy());
            sequencer.promise.sequencer = sequencer; // So we can reference it from the stack of sources
            rootSequencer.sources.push(sequencer.promise);
        } else {
            sequencer = topSequencer;
        }
        fluid.tryCatch(function commitPotentiae() {
            if (fluid.isPopulatedPotentiaList(transRec.pendingPotentiae)) {
                fluid.commitPotentiaePhase(transRec);
            }
            var workflowEnqueued = fluid.applyWorkflowPhase(transRec, sequencer);
            if (workflowEnqueued) { // Redispatch to ourselves if any workflow work was enqueued
                sequencer.sources.push(function () {
                    fluid.commitPotentiae(transactionId);
                });
            }
            if (!sequencer.sequenceStarted) {
                fluid.promise.resumeSequence(sequencer);
            }
            if (!rootSequencer.sequenceStarted) {
                fluid.promise.resumeSequence(rootSequencer);
            }
        }, function (e) {
            if (!transRec.promise.disposition) {
                transRec.promise.reject(e);
            }
        });
        --transRec.commitDepth;
        if (transRec.commitDepth === 0) {
            instantiator.currentTreeTransactionId = null;
        }
        return transRec.outputShadows[lastWorkflowShadow];
    };

    /** Push the supplied potentia onto a potentia list structure (as dispensed from `fluid.blankPotentiaList()`).
     * @param {PotentiaList} potentiaList - The transaction record for the current tree transaction
     * @param {Instantiator} instantiator - The instantiator operating the transaction
     * @param {Potentia} potentia - A potentia to be registered
     */
    fluid.pushPotentia = function (potentiaList, instantiator, potentia) {
        var segs = potentia.segs = potentia.segs || instantiator.parseToSegments(potentia.path);
        var path = potentia.path = instantiator.composeSegments.apply(null, segs);

        if (potentia.type === "destroy") {
            potentiaList.destroys.push(potentia);
            potentiaList.activeCount++;
        } else {
            var newPotentia = potentia;
            if (potentia.type === "create") {
                newPotentia = fluid.pushCreatePotentia(potentiaList, path, potentia);
            }
            if (newPotentia) {
                potentiaList.creates.push(potentia);
                potentiaList.activeCount++;
            };
        }
    };

    /** BEGIN NEXUS/POTENTIA METHODS - THESE ARE PUBLIC API **/

    /**
     * Given a component reference, returns the path of that component within its component tree.
     *
     * @param {Component} component - A reference to a component.
     * @param {Instantiator} [instantiator] - (optional) An instantiator to use for the lookup.
     * @return {String[]} An array of {String} path segments of the component within its tree, or `null` if the reference does not hold a live component.
     */

    fluid.pathForComponent = function (component, instantiator) {
        instantiator = instantiator || fluid.getInstantiator(component) || fluid.globalInstantiator;
        var shadow = instantiator.idToShadow[component.id];
        if (!shadow) {
            return null;
        }
        return instantiator.parseEL(shadow.path);
    };

    /** @typedef {Object} TreeTransaction
     *    @property {String} transactionId - The id of this transaction (in the form allocated by `fluid.allocateGuid`)
     *    @property {Number} workflowStageBreak - The index of any workflow stage that component elaboration is to break at
     *    @property {Number} maximumWorkflowStage - The maximum workflow index that any component has so far reached
     * ...
     */

    /**
     * Returns the current tree transaction which a constructing component is enlisted in. This may be undefined
     * if the transaction has concluded.
     * @return {TreeTransaction|Undefined} The tree transaction.
     */
    fluid.currentTreeTransaction = function () {
        var instantiator = fluid.globalInstantiator;
        return instantiator.treeTransactions[instantiator.currentTreeTransactionId];
    };

    /** Clear the mutable fields in the supplied tree transaction, either on startup or during cancellation
     * @param {TreeTransaction} transRec - The tree transaction to be cleared
     */
    fluid.clearTreeTransaction = function (transRec) {
        transRec.rootSequencer = fluid.promise.makeSequencer([], {}, fluid.promise.makeSequenceStrategy());
        transRec.restoreRecords = fluid.blankPotentiaList(); // accumulate a list of records to be executed in case the transaction is backed out
        transRec.initModelTransaction = {};
        transRec.outputShadows = [];         // All shadows output during this transaction
        transRec.lastWorkflowShadow = 0;     // The last index of a shadow which has entered workflow
        transRec.maximumWorkflowStage = 0;   // The maximum workflow stage so far attained by any component
        transRec.deferredDistributions = []; // distributeOptions may decide to defer application of a distribution for FLUID-6193
    };

    /** Begin a fresh transaction against the global component tree. Any further calls to `fluid.registerPotentia`,
     * `fluid.construct` or `fluid.destroy` may be contextualised by this transaction, and then committed as a single
     * unit via `fluid.commitPotentiae` or cancelled via `fluid.cancelTreeTransaction`.
     * @param {Object} [transactionOptions] - [optional] A set of options configuring this tree transaction. This may include fields
     *     {String} breakAt - one of the values:
     *         `shells`: signifying that this transaction should pause as soon as all component shells are constructed (see FLUID-4925)
     *         `concludeComponentObservation`: signifying that this transaction should pause once the observation process of all components is concluded - that is,
     *               that all component options, members and invokers are evaluated.
     *         ... or the name of any other local or global workflow attached to a grade registered into the system
     * @return {TreeTransaction} The freshly allocated tree transaction.
     */
    fluid.beginTreeTransaction = function (transactionOptions) {
        var instantiator = fluid.globalInstantiator;
        if (instantiator.currentTreeTransactionId) {
            fluid.fail("Attempt to start new tree transaction when transaction " + instantiator.currentTreeTransactionId + " is already active");
        }
        var transactionId = instantiator.currentTreeTransactionId = fluid.allocateGuid();
        var transRec = $.extend({
            transactionId: transactionId,
            workflowStageBreak: undefined, // Any stage which was requested component processing should break at
            pendingPotentiae: fluid.blankPotentiaList(), // array of potentia which remain to be handled
            commitDepth: 0, // The number of nested calls to fluid.commitPotentiae
            cancelled: false,
            cancellationError: null,
            pendingIO: [] // list of outstanding promises from workflow in progress
        }, transactionOptions);
        fluid.clearTreeTransaction(transRec);
        transRec.promise = transRec.rootSequencer.promise;

        var onConclude = function () {
            if (transRec.rootSequencer.promise.disposition) {
                instantiator.currentTreeTransactionId = null;
                delete instantiator.treeTransactions[transactionId];
            }
        };

        var onException = function (err) {
            if (!transRec.cancelled) {
                delete transRec.rootSequencer;
                fluid.cancelTreeTransaction(transactionId, instantiator, err);
                onConclude();
            }
        };
        transRec.promise.then(onConclude, onException);
        instantiator.treeTransactions[transactionId] = transRec;

        try {
            transRec.workflowStageBreak = fluid.lookupWorkflowStage(transRec.breakAt);
        } catch (e) {
            transRec.promise.reject(e);
        }

        return transRec;
    };

    /** Signature as for `fluid.construct`. Registers the intention of constructing or destroying a component at a particular path. The action will
     * occur once the transaction is committed.
     * @param {Potentia} potentia - A record designating the kind of change to occur. Fields:
     *    type: {String} Either "create" or "destroy".
     *    path: {String|Array of String} Path where the component is to be constructed or destroyed, represented as a string or array of segments
     *    componentDepth: {Number} The depth of nesting of this record from the originally created component - defaults to 0
     *    records: {Array of Object} A component's construction record, as they would currently appear in a component's "options.components.x" record
     * @param {String} [transactionId] [optional] A transaction id in which to enlist this registration. If this is omitted, the current transaction
     *     will be used, if there is one - otherwise, a fresh transaction will be allocated using `fluid.beginTreeTransaction`.
     * @return {TreeTransaction} - The transaction that the supplied potentia record was enrolled into
     */
    fluid.registerPotentia = function (potentia, transactionId) {
        var instantiator = fluid.globalInstantiator;
        transactionId = transactionId || instantiator.currentTreeTransactionId;
        if (!transactionId) {
            transactionId = fluid.beginTreeTransaction().transactionId;
        }
        var transRec = instantiator.treeTransactions[transactionId];
        fluid.pushPotentia(transRec.pendingPotentiae, instantiator, potentia);

        return transRec;
    };


    /** Cancel the transaction with the supplied transaction id. This cancellation will undo any actions journalled in
     * the transaction's `restoreRecords` by a further call to `fluid.commitPotentiae`.
     * @param {String} transactionId - The id of the transaction to be cancelled
     * @param {Instantiator} instantiator - The current instantiator
     */
    fluid.cancelTreeTransaction = function (transactionId, instantiator) {
        var transRec = instantiator.treeTransactions[transactionId];
        if (transRec) {
            try {
                transRec.pendingPotentiae = transRec.restoreRecords;
                transRec.cancelled = true;
                fluid.clearTreeTransaction(transRec);
                fluid.commitPotentiae(transactionId, true);
            } catch (e) {
                fluid.log(fluid.logLevel.FAIL, "Fatal error cancelling transaction " + transactionId + ": destroying all affected paths");
                transRec.restoreRecords.creates.forEach(function (potentia) {
                    instantiator.clearComponent(potentia.parentThat, potentia.memberName, potentia.parentThat[potentia.memberName]);
                });
                throw e;
            }
        }
    };

    /** Constructs a subcomponent as a child of an existing component, via a call to `fluid.construct`. Note that if
     * a component already exists with the member name `memberName`, it will first be destroyed.
     * @param {Component} parent - Component for which a child subcomponent is to be constructed
     * @param {String} memberName - The member name of the resulting component in its parent
     * @param {Object} options - The top-level options supplied to the component, as for `fluid.construct`
     * @return {Component} The constructed component
     */
    fluid.constructChild = function (parent, memberName, options) {
        var parentPath = fluid.pathForComponent(parent);
        var path = parentPath.concat([memberName]);
        return fluid.construct(path, options);
    };

    /** Construct a component with the supplied options at the specified path in the component tree. The parent path of the location must already be a component. If
     * a component is already present at the specified path, it will first be destroyed.
     * @param {String|String[]} path - Path where the new component is to be constructed, represented as a string or array of string segments
     * @param {Object} componentOptions - Top-level options supplied to the component - must at the very least include a field <code>type</code> holding the component's type
     * @param {Object} [constructOptions] - [optional] A record of options guiding the construction of this component
     *     transactionId {String} [optional] A transaction which this construction action should be enlisted in. If this is supplied, the transaction will not
     *         be committed after the component's construction - instead, this must be done explicitly by the user by a later call to `fluid.commitPotentiae`.
     *     localRecord {Object} A hash of context keys to context values which should be in scope for resolution of IoC references within this construction
     *         be committed, and the user must do so themselves via `fluid.commitPotentiae`
     *     returnTransaction {Boolean} [optional] If `true`, the return value will be the transaction record rather than any constructing component. This is most
     *         useful to detect the point of failure of an asynchronously constructed component by attaching to `transRec.promise`.
     * @return {Component|TreeTransaction|Undefined} The constructed component, if its construction has begun, or the transaction record, if `returnTransaction` was requested.
     */
    fluid.construct = function (path, componentOptions, constructOptions) {
        constructOptions = constructOptions || {};
        var transRec = fluid.registerPotentia({
            path: path,
            type: "destroy"
        }, constructOptions.transactionId);
        var record = {
            recordType: "user"
        };
        // Courtesy to restructure record before one day we have FLUID-5750 options flattening
        fluid.each(fluid.componentRecordExpected, function (troo, key) {
            if (componentOptions[key] !== undefined) {
                record[key] = componentOptions[key];
            }
        });
        record.options = componentOptions;
        var potentia = {
            path: path,
            type: "create",
            localRecord: constructOptions.localRecord,
            records: [record]
        };
        fluid.registerPotentia(potentia, transRec.transactionId);
        if (!constructOptions.transactionId) {
            fluid.commitPotentiae(transRec.transactionId);
        }
        return constructOptions.returnTransaction ? transRec : fluid.getImmediate(fluid.rootComponent, potentia.segs);
    };

    /** Destroys a component held at the specified path. The parent path must represent a component, although the component itself may be nonexistent
     * @param {String|String[]} path - Path where the new component is to be destroyed, represented as a string or array of string segments
     * @param {Instantiator} [instantiator] - [optional] The instantiator holding the component to be destroyed - if blank, the global instantiator will be used.
     * @return {TreeTransaction} The transaction that the destruction occurred in.
     */
    fluid.destroy = function (path, instantiator) {
        instantiator = instantiator || fluid.globalInstantiator;
        var segs = instantiator.parseToSegments(path);
        if (segs.length === 0) {
            fluid.fail("Cannot destroy the root component");
        }
        var transRec = fluid.registerPotentia({
            path: path,
            type: "destroy"
        });
        fluid.commitPotentiae(transRec.transactionId);
        return transRec;
    };

   /** Construct an instance of a component as a child of the specified parent, with a well-known, unique name derived from its typeName
    * @param {String|String[]} parentPath - Parent of path where the new component is to be constructed, represented as a {String} or array of {String} segments
    * @param {String|Object} options - Options encoding the component to be constructed. If this is of type String, it is assumed to represent the component's typeName with no options
    * @param {Instantiator} [instantiator] - [optional] The instantiator holding the component to be created - if blank, the global instantiator will be used
    * @return {Component} The constructed component
    */
    fluid.constructSingle = function (parentPath, options, instantiator) {
        instantiator = instantiator || fluid.globalInstantiator;
        parentPath = parentPath || "";
        var segs = fluid.model.parseToSegments(parentPath, instantiator.parseEL, true);
        if (typeof(options) === "string") {
            options = {type: options};
        }
        var type = options.type;
        if (!type) {
            fluid.fail("Cannot construct singleton object without a type entry");
        }
        options = $.extend({}, options);
        var gradeNames = options.gradeNames = fluid.makeArray(options.gradeNames);
        gradeNames.unshift(type); // principal type may be noninstantiable
        options.type = "fluid.component";
        var root = segs.length === 0;
        if (root) {
            gradeNames.push("fluid.resolveRoot");
        }
        var memberName = fluid.typeNameToMemberName(options.singleRootType || type);
        segs.push(memberName);
        return fluid.construct(segs, options);
    };

    /** Destroy an instance created by `fluid.constructSingle`
     * @param {String|String[]} parentPath - Parent of path where the new component is to be constructed, represented as a {String} or array of {String} segments
     * @param {String} typeName - The type name used to construct the component (either `type` or `singleRootType` of the `options` argument to `fluid.constructSingle`
     * @param {Instantiator} [instantiator] - [optional] The instantiator holding the component to be created - if blank, the global instantiator will be used
    */
    fluid.destroySingle = function (parentPath, typeName, instantiator) {
        instantiator = instantiator || fluid.globalInstantiator;
        var segs = fluid.model.parseToSegments(parentPath, instantiator.parseEL, true);
        var memberName = fluid.typeNameToMemberName(typeName);
        segs.push(memberName);
        fluid.destroy(segs, instantiator);
    };

    /** Registers and constructs a "linkage distribution" which will ensure that wherever a set of "input grades" co-occur, they will
     * always result in a supplied "output grades" in the component where they co-occur.
     * @param {String} linkageName - The name of the grade which will broadcast the resulting linkage. If required, this linkage can be destroyed by supplying this name to `fluid.destroySingle`.
     * @param {String[]} inputNames - An array of grade names which will be tested globally for co-occurrence
     * @param {String|String[]} outputNames - A single grade name or array of grade names which will be output into the co-occuring component
     */
    fluid.makeGradeLinkage = function (linkageName, inputNames, outputNames) {
        fluid.defaults(linkageName, {
            gradeNames: "fluid.component",
            distributeOptions: {
                record: outputNames,
                target: "{/ " + inputNames.join("&") + "}.options.gradeNames"
            }
        });
        fluid.constructSingle([], linkageName);
    };

    /** Retrieves a component by global path.
    * @param {String|String[]} path - The global path of the component to look up, expressed as a string or as an array of segments.
    * @return {Object} - The component at the specified path, or undefined if none is found.
    */
    fluid.componentForPath = function (path) {
        return fluid.globalInstantiator.pathToComponent[fluid.isArrayable(path) ? path.join(".") : path];
    };

    /** END NEXUS/POTENTIA METHODS - END OF PUBLIC API **/

    fluid.thisistToApplicable = function (record, recthis, that) {
        return {
            apply: function (noThis, args) {
                // Resolve this material late, to deal with cases where the target has only just been brought into existence
                // (e.g. a jQuery target for rendered material) - TODO: Possibly implement cached versions of these as we might do for invokers
                var resolvedThis = fluid.expandOptions(recthis, that);
                if (typeof(resolvedThis) === "string") {
                    resolvedThis = fluid.getGlobalValue(resolvedThis);
                }
                if (!resolvedThis) {
                    fluid.fail("Could not resolve reference " + recthis + " to a value");
                }
                var resolvedFunc = resolvedThis[record.method];
                if (typeof(resolvedFunc) !== "function") {
                    fluid.fail("Object ", resolvedThis, " at reference " + recthis + " has no member named " + record.method + " which is a function ");
                }
                if (fluid.passLogLevel(fluid.logLevel.TRACE)) {
                    fluid.log(fluid.logLevel.TRACE, "Applying arguments ", args, " to method " + record.method + " of instance ", resolvedThis);
                }
                return resolvedFunc.apply(resolvedThis, args);
            }
        };
    };

    fluid.changeToApplicable = function (record, that) {
        return {
            apply: function (noThis, args, localRecord, mergeRecord) {
                var parsed = fluid.parseValidModelReference(that, "changePath listener record", record.changePath);
                var value = fluid.expandOptions(record.value, that, {}, fluid.extend(localRecord, {"arguments": args}));
                var sources = mergeRecord && mergeRecord.source && mergeRecord.source.length ? fluid.makeArray(record.source).concat(mergeRecord.source) : record.source;
                parsed.applier.change(parsed.modelSegs, value, record.type, sources); // FLUID-5586 now resolved
            }
        };
    };

    // Convert "exotic records" into an applicable form ("this/method" for FLUID-4878 or "changePath" for FLUID-3674)
    fluid.recordToApplicable = function (record, that, standard) {
        if (record.changePath !== undefined) { // Allow falsy paths for FLUID-5586
            return fluid.changeToApplicable(record, that, standard);
        }
        var recthis = record["this"];
        if (record.method ^ recthis) {
            fluid.fail("Record ", that, " must contain both entries \"method\" and \"this\" if it contains either");
        }
        return record.method ? fluid.thisistToApplicable(record, recthis, that) : null;
    };

    fluid.getGlobalValueNonComponent = function (funcName, context) { // TODO: Guard this in listeners as well
        var defaults = fluid.defaults(funcName);
        if (defaults && fluid.hasGrade(defaults, "fluid.component")) {
            fluid.fail("Error in function specification - cannot invoke function " + funcName + " in the context of " + context + ": component creator functions can only be used as subcomponents");
        }
        return fluid.getGlobalValue(funcName);
    };

    fluid.makeInvoker = function (that, invokerec, name) {
        invokerec = fluid.upgradePrimitiveFunc(invokerec); // shorthand case for direct function invokers (FLUID-4926)
        if (invokerec.args !== undefined && invokerec.args !== fluid.NO_VALUE && !fluid.isArrayable(invokerec.args)) {
            invokerec.args = fluid.makeArray(invokerec.args);
        }
        var func = fluid.recordToApplicable(invokerec, that);
        var invokePre = fluid.preExpand(invokerec.args);
        var localRecord = {};
        var expandOptions = fluid.makeStackResolverOptions(that, localRecord, true);
        func = func || (invokerec.funcName ? fluid.getGlobalValueNonComponent(invokerec.funcName, "an invoker") : fluid.expandImmediate(invokerec.func, that));
        if (!func || !func.apply) {
            fluid.fail("Error in invoker record: could not resolve members func, funcName or method to a function implementation - got " + func + " from ", invokerec);
        } else if (func === fluid.notImplemented) {
            fluid.fail("Error constructing component ", that, " - the invoker named " + name + " which was defined in grade " + invokerec.componentSource + " needs to be overridden with a concrete implementation");
        }
        return function invokeInvoker() {
            if (fluid.defeatLogging === false) {
                fluid.pushActivity("invokeInvoker", "invoking invoker with name %name and record %record holding component %that",
                    {name: name, record: invokerec, that: that});
            }
            var togo, finalArgs;
            if (that.lifecycleStatus === "destroyed") {
                fluid.log(fluid.logLevel.WARN, "Ignoring call to invoker " + name + " of component ", that, " which has been destroyed");
            } else {
                localRecord.arguments = arguments;
                if (invokerec.args === undefined || invokerec.args === fluid.NO_VALUE) {
                    finalArgs = arguments;
                } else {
                    fluid.expandImmediateImpl(invokePre, expandOptions);
                    finalArgs = invokePre.source;
                }
                togo = func.apply(null, finalArgs);
            }
            if (fluid.defeatLogging === false) {
                fluid.popActivity();
            }
            return togo;
        };
    };

    // weird higher-order function so that we can staightforwardly dispatch original args back onto listener
    fluid.event.makeTrackedListenerAdder = function (source) {
        var shadow = fluid.shadowForComponent(source);
        return function (event) {
            return {addListener: function (listener, namespace, priority, softNamespace, listenerId) {
                fluid.recordListener(event, listener, shadow, listenerId);
                event.addListener.apply(null, arguments);
            }};
        };
    };

    fluid.event.listenerEngine = function (eventSpec, callback, adder) {
        var argstruc = {};
        function checkFire() {
            var notall = fluid.find(eventSpec, function (value, key) {
                if (argstruc[key] === undefined) {
                    return true;
                }
            });
            if (!notall) {
                var oldstruc = argstruc;
                argstruc = {}; // guard against the case the callback perversely fires one of its prerequisites (FLUID-5112)
                callback(oldstruc);
            }
        }
        fluid.each(eventSpec, function (event, eventName) {
            adder(event).addListener(function () {
                argstruc[eventName] = fluid.makeArray(arguments);
                checkFire();
            });
        });
    };

    fluid.event.dispatchListener = function (that, listener, eventName, eventSpec, wrappedArgs) {
        if (eventSpec.args !== undefined && eventSpec.args !== fluid.NO_VALUE && !fluid.isArrayable(eventSpec.args)) {
            eventSpec.args = fluid.makeArray(eventSpec.args);
        }
        listener = fluid.event.resolveListener(listener); // In theory this optimisation is too aggressive if global name is not defined yet
        var dispatchPre = fluid.preExpand(eventSpec.args);
        var localRecord = {};
        var expandOptions = fluid.makeStackResolverOptions(that, localRecord, true);
        var togo = function () {
            if (fluid.defeatLogging === false) {
                fluid.pushActivity("dispatchListener", "firing to listener to event named %eventName of component %that",
                    {eventName: eventName, that: that});
            }

            var args = wrappedArgs ? arguments[0] : arguments, finalArgs;
            localRecord.arguments = args;
            if (eventSpec.args !== undefined && eventSpec.args !== fluid.NO_VALUE) {
                // In theory something more exotic happens here, and in makeInvoker - where "source" is an array we want to
                // keep its base reference stable since Function.apply will fork it sufficiently, but we really need to
                // clone each structured argument. Implies that expandImmediateImpl needs to be split in two, and operate
                // reference by "segs" rather than by "holder"
                fluid.expandImmediateImpl(dispatchPre, expandOptions);
                finalArgs = dispatchPre.source;
            } else {
                finalArgs = args;
            }
            var togo = listener.apply(null, finalArgs);
            if (fluid.defeatLogging === false) {
                fluid.popActivity();
            }
            return togo;
        };
        fluid.event.impersonateListener(listener, togo); // still necessary for FLUID-5254 even though framework's listeners now get explicit guids
        return togo;
    };

    fluid.event.resolveSoftNamespace = function (key) {
        if (typeof(key) !== "string") {
            return null;
        } else {
            var lastpos = Math.max(key.lastIndexOf("."), key.lastIndexOf("}"));
            return key.substring(lastpos + 1);
        }
    };

    fluid.event.resolveListenerRecord = function (lisrec, that, eventName, namespace, standard) {
        var badRec = function (record, extra) {
            fluid.fail("Error in listener record - could not resolve reference ", record, " to a listener or firer. " +
                "Did you miss out \"events.\" when referring to an event firer?" + extra);
        };
        fluid.pushActivity("resolveListenerRecord", "resolving listener record for event named %eventName for component %that",
            {eventName: eventName, that: that});
        var records = fluid.makeArray(lisrec);
        var transRecs = fluid.transform(records, function (record) {
            // TODO: FLUID-5242 fix - we copy here since distributeOptions does not copy options blocks that it distributes and we can hence corrupt them.
            // need to clarify policy on options sharing - for slightly better efficiency, copy should happen during distribution and not here
            // Note that fluid.mergeModelListeners expects to write to these too
            var expanded = fluid.isPrimitive(record) || record.expander ? {listener: record} : fluid.copy(record);
            var methodist = fluid.recordToApplicable(record, that, standard);
            if (methodist) {
                expanded.listener = methodist;
            }
            else {
                expanded.listener = expanded.listener || expanded.func || expanded.funcName;
            }
            if (!expanded.listener) {
                badRec(record, " Listener record must contain a member named \"listener\", \"func\", \"funcName\" or \"method\"");
            }
            var softNamespace = record.method ?
                fluid.event.resolveSoftNamespace(record["this"]) + "." + record.method :
                fluid.event.resolveSoftNamespace(expanded.listener);
            if (!expanded.namespace && !namespace && softNamespace) {
                expanded.softNamespace = true;
                expanded.namespace = (record.componentSource ? record.componentSource : that.typeName) + "." + softNamespace;
            }
            var listener = expanded.listener = fluid.expandOptions(expanded.listener, that);
            if (!listener) {
                badRec(record, "");
            }
            var firer = false;
            if (listener.typeName === "fluid.event.firer") {
                listener = listener.fire;
                firer = true;
            }
            expanded.listener = (standard && (expanded.args && listener !== "fluid.notImplemented" || firer)) ? fluid.event.dispatchListener(that, listener, eventName, expanded) : listener;
            expanded.listenerId = fluid.allocateGuid();
            return expanded;
        });
        var togo = {
            records: transRecs,
            adderWrapper: standard ? fluid.event.makeTrackedListenerAdder(that) : null
        };
        fluid.popActivity();
        return togo;
    };

    fluid.event.expandOneEvent = function (that, event) {
        var origin;
        if (typeof(event) === "string" && event.charAt(0) !== "{") {
            // Shorthand for resolving onto our own events, but with GINGER WORLD!
            origin = fluid.getForComponent(that, ["events", event]);
        }
        else {
            origin = fluid.expandOptions(event, that);
        }
        if (!origin || origin.typeName !== "fluid.event.firer") {
            fluid.fail("Error in event specification - could not resolve base event reference ", event, " to an event firer: got ", origin);
        }
        return origin;
    };

    fluid.event.expandEvents = function (that, event) {
        return typeof(event) === "string" ?
            fluid.event.expandOneEvent(that, event) :
            fluid.transform(event, function (oneEvent) {
                return fluid.event.expandOneEvent(that, oneEvent);
            });
    };

    fluid.event.resolveEvent = function (that, eventName, eventSpec) {
        fluid.pushActivity("resolveEvent", "resolving event with name %eventName attached to component %that",
            {eventName: eventName, that: that});
        var adder = fluid.event.makeTrackedListenerAdder(that);
        if (typeof(eventSpec) === "string") {
            eventSpec = {event: eventSpec};
        }
        var event = eventSpec.typeName === "fluid.event.firer" ? eventSpec : eventSpec.event || eventSpec.events;
        if (!event) {
            fluid.fail("Event specification for event with name " + eventName + " does not include a base event specification: ", eventSpec);
        }

        var origin = event.typeName === "fluid.event.firer" ? event : fluid.event.expandEvents(that, event);

        var isMultiple = origin.typeName !== "fluid.event.firer";
        var isComposite = eventSpec.args || isMultiple;
        // If "event" is not composite, we want to share the listener list and FIRE method with the original
        // If "event" is composite, we need to create a new firer. "composite" includes case where any boiling
        // occurred - this was implemented wrongly in 1.4.
        var firer;
        if (isComposite) {
            firer = fluid.makeEventFirer({name: " [composite] " + fluid.event.nameEvent(that, eventName)});
            var dispatcher = fluid.event.dispatchListener(that, firer.fire, eventName, eventSpec, isMultiple);
            if (isMultiple) {
                fluid.event.listenerEngine(origin, dispatcher, adder);
            }
            else {
                adder(origin).addListener(dispatcher);
            }
        }
        else {
            firer = {typeName: "fluid.event.firer"};
            firer.fire = function () {
                var outerArgs = fluid.makeArray(arguments);
                fluid.pushActivity("fireSynthetic", "firing synthetic event %eventName ", {eventName: eventName});
                var togo = origin.fire.apply(null, outerArgs);
                fluid.popActivity();
                return togo;
            };
            firer.addListener = function (listener, namespace, priority, softNamespace, listenerId) {
                var dispatcher = fluid.event.dispatchListener(that, listener, eventName, eventSpec);
                adder(origin).addListener(dispatcher, namespace, priority, softNamespace, listenerId);
            };
            firer.removeListener = function (listener) {
                origin.removeListener(listener);
            };
            // To allow introspection on listeners in cases such as fluid.test.findListenerId
            firer.originEvent = origin;
        }
        fluid.popActivity();
        return firer;
    };

    /* Compact expansion machinery - for short form invoker and expander references such as @expand:func(arg) and func(arg) */

    fluid.coerceToPrimitive = function (string) {
        return string === "false" ? false : (string === "true" ? true :
            (isFinite(string) ? Number(string) : string));
    };

    fluid.compactStringToRec = function (string, type) {
        var openPos = string.indexOf("(");
        var closePos = string.indexOf(")");
        if (openPos === -1 ^ closePos === -1 || openPos > closePos) {
            fluid.fail("Badly-formed compact " + type + " record without matching parentheses: " + string);
        }
        if (openPos !== -1 && closePos !== -1) {
            var trail = string.substring(closePos + 1);
            if ($.trim(trail) !== "") {
                fluid.fail("Badly-formed compact " + type + " record " + string + " - unexpected material following close parenthesis: " + trail);
            }
            var prefix = string.substring(0, openPos);
            var body = $.trim(string.substring(openPos + 1, closePos));
            var args = body === "" ? [] : fluid.transform(body.split(","), $.trim, fluid.coerceToPrimitive);
            var togo = fluid.upgradePrimitiveFunc(prefix, null);
            togo.args = args;
            return togo;
        }
        else if (type === "expander") {
            fluid.fail("Badly-formed compact expander record without parentheses: " + string);
        }
        return string;
    };

    fluid.expandPrefix = "@expand:";

    fluid.expandCompactString = function (string, active) {
        var rec = string;
        if (string.indexOf(fluid.expandPrefix) === 0) {
            var rem = string.substring(fluid.expandPrefix.length);
            rec = {
                expander: fluid.compactStringToRec(rem, "expander")
            };
        }
        else if (active) {
            rec = fluid.compactStringToRec(string, active);
        }
        return rec;
    };

    var singularPenRecord = {
        listeners: "listener",
        modelListeners: "modelListener"
    };

    var singularRecord = $.extend({
        invokers: "invoker"
    }, singularPenRecord);

    fluid.expandCompactRec = function (segs, target, source) {
        fluid.guardCircularExpansion(segs, segs.length);
        var pen = fluid.peek(segs);
        var active = singularRecord[pen];
        if (!active && segs.length > 1) {
            active = singularPenRecord[segs[segs.length - 2]]; // support array of listeners and modelListeners
        }
        fluid.each(source, function (value, key) {
            if (fluid.isPlainObject(value)) {
                target[key] = fluid.freshContainer(value);
                segs.push(key);
                fluid.expandCompactRec(segs, target[key], value);
                segs.pop();
                return;
            }
            else if (typeof(value) === "string") {
                value = fluid.expandCompactString(value, active);
            }
            target[key] = value;
        });
    };

    fluid.expandCompact = function (options) {
        var togo = {};
        fluid.expandCompactRec([], togo, options);
        return togo;
    };

    /** End compact record expansion machinery **/

    fluid.extractEL = function (string, options) {
        if (options.ELstyle === "ALL") {
            return string;
        }
        else if (options.ELstyle.length === 1) {
            if (string.charAt(0) === options.ELstyle) {
                return string.substring(1);
            }
        }
        else if (options.ELstyle === "${}") {
            var i1 = string.indexOf("${");
            var i2 = string.lastIndexOf("}");
            if (i1 === 0 && i2 !== -1) {
                return string.substring(2, i2);
            }
        }
    };

    fluid.extractELWithContext = function (string, options) {
        var EL = fluid.extractEL(string, options);
        if (fluid.isIoCReference(EL)) {
            return fluid.parseContextReference(EL);
        }
        return EL ? {path: EL} : EL;
    };

    /** Parse the string form of a contextualised IoC reference into an object.
     * @param {String} reference - The reference to be parsed. The character at position `index` is assumed to be `{`
     * @param {String} [index] - [optional] The index into the string to start parsing at, if omitted, defaults to 0
     * @param {Character} [delimiter] - [optional] A character which will delimit the end of the context expression. If omitted, the expression continues to the end of the string.
     * @return {ParsedContext} A structure holding the parsed structure, with members
     *    context {String|ParsedContext} The context portion of the reference. This will be a `string` for a flat reference, or a further `ParsedContext` for a recursive reference
     *    path {String} The string portion of the reference
     *    endpos {Integer} The position in the string where parsing stopped [this member is not supported and will be removed in a future release]
     */
    fluid.parseContextReference = function (reference, index, delimiter) {
        index = index || 0;
        var isNested = reference.charAt(index + 1) === "{", endcpos, context, nested;
        if (isNested) {
            nested = fluid.parseContextReference(reference, index + 1, "}");
            endcpos = nested.endpos;
        } else {
            endcpos = reference.indexOf("}", index + 1);
        }
        if (endcpos === -1) {
            fluid.fail("Cannot parse context reference \"" + reference + "\": Malformed context reference without }");
        }
        if (isNested) {
            context = nested;
        } else {
            context = reference.substring(index + 1, endcpos);
        }
        var endpos = delimiter ? reference.indexOf(delimiter, endcpos + 1) : reference.length;
        var path = reference.substring(endcpos + 1, endpos);
        if (path.charAt(0) === ".") {
            path = path.substring(1);
        }
        return {context: context, path: path, endpos: endpos};
    };

    fluid.renderContextReference = function (parsed) {
        var context = parsed.context;
        return "{" + (typeof(context) === "string" ? context : fluid.renderContextReference(context)) + "}" + (parsed.path ? "." + parsed.path : "");
    };

    // TODO: Once we eliminate expandSource (in favour of fluid.expander.fetch), all of this tree of functions can be hived off to RendererUtilities
    fluid.resolveContextValue = function (string, options) {
        function fetch(parsed) {
            fluid.pushActivity("resolveContextValue", "resolving context value %parsed", {parsed: parsed});
            var togo = options.fetcher(parsed);
            fluid.pushActivity("resolvedContextValue", "resolved value %parsed to value %value", {parsed: parsed, value: togo});
            fluid.popActivity(2);
            return togo;
        }
        var parsed;
        if (options.bareContextRefs && fluid.isIoCReference(string)) {
            parsed = fluid.parseContextReference(string);
            return fetch(parsed);
        }
        else if (options.ELstyle && options.ELstyle !== "${}") {
            parsed = fluid.extractELWithContext(string, options);
            if (parsed) {
                return fetch(parsed);
            }
        }
        while (typeof(string) === "string") {
            var i1 = string.indexOf("${");
            var i2 = string.indexOf("}", i1 + 2);
            if (i1 !== -1 && i2 !== -1) {
                if (string.charAt(i1 + 2) === "{") {
                    parsed = fluid.parseContextReference(string, i1 + 2, "}");
                    i2 = parsed.endpos;
                }
                else {
                    parsed = {path: string.substring(i1 + 2, i2)};
                }
                var subs = fetch(parsed);
                var all = (i1 === 0 && i2 === string.length - 1);
                // TODO: test case for all undefined substitution
                if (subs === undefined || subs === null) {
                    return subs;
                }
                string = all ? subs : string.substring(0, i1) + subs + string.substring(i2 + 1);
            }
            else {
                break;
            }
        }
        return string;
    };

    // This function appears somewhat reusable, but not entirely - it probably needs to be packaged
    // along with the particular "strategy". Very similar to the old "filter"... the "outer driver" needs
    // to execute it to get the first recursion going at top level. This was one of the most odd results
    // of the reorganisation, since the "old work" seemed much more naturally expressed in terms of values
    // and what happened to them. The "new work" is expressed in terms of paths and how to move amongst them.
    fluid.fetchExpandChildren = function (target, i, segs, source, mergePolicy, options) {
        if (source.expander) { // possible expander at top level
            var expanded = fluid.expandExpander(target, source, options);
            if (fluid.isPrimitive(expanded) || !fluid.isPlainObject(expanded) || (fluid.isArrayable(expanded) ^ fluid.isArrayable(target))) {
                return expanded;
            }
            else { // make an attempt to preserve the root reference if possible
                $.extend(true, target, expanded);
            }
        }
        // NOTE! This expects that RHS is concrete! For material input to "expansion" this happens to be the case, but is not
        // true for other algorithms. Inconsistently, this algorithm uses "sourceStrategy" below. In fact, this "fetchChildren"
        // operation looks like it is a fundamental primitive of the system. We do call "deliverer" early which enables correct
        // reference to parent nodes up the tree - however, anyone processing a tree IN THE CHAIN requires that it is produced
        // concretely at the point STRATEGY returns. Which in fact it is...............
        fluid.each(source, function (newSource, key) {
            if (newSource === undefined) {
                target[key] = undefined; // avoid ever dispatching to ourselves with undefined source
            }
            else if (key !== "expander") {
                segs[i] = key;
                if (fluid.getImmediate(options.exceptions, segs, i) !== true) {
                    options.strategy(target, key, i + 1, segs, source, mergePolicy);
                }
            }
        });
        return target;
    };

    // TODO: This method is unnecessary and will quadratic inefficiency if RHS block is not concrete.
    // The driver should detect "homogeneous uni-strategy trundling" and agree to preserve the extra
    // "cursor arguments" which should be advertised somehow (at least their number)
    function regenerateCursor(source, segs, limit, sourceStrategy) {
        for (var i = 0; i < limit; ++i) {
            // copy segs to avoid aliasing with FLUID-5243
            source = sourceStrategy(source, segs[i], i, fluid.makeArray(segs));
        }
        return source;
    }

    fluid.isUnexpandable = function (source) { // slightly more efficient compound of fluid.isCopyable and fluid.isComponent - review performance
        return fluid.isPrimitive(source) || !fluid.isPlainObject(source);
    };

    fluid.expandSource = function (options, target, i, segs, deliverer, source, policy, recurse) {
        var expanded, isTrunk;
        var thisPolicy = fluid.derefMergePolicy(policy);
        if (typeof (source) === "string" && !thisPolicy.noexpand) {
            if (!options.defaultEL || source.charAt(0) === "{") { // hard-code this for performance
                fluid.pushActivity("expandContextValue", "expanding context value %source held at path %path", {source: source, path: fluid.path.apply(null, segs.slice(0, i))});
                expanded = fluid.resolveContextValue(source, options);
                fluid.popActivity(1);
            } else {
                expanded = source;
            }
        }
        else if (thisPolicy.noexpand || fluid.isUnexpandable(source)) {
            expanded = source;
        }
        else if (source.expander) {
            expanded = fluid.expandExpander(deliverer, source, options);
        }
        else {
            expanded = fluid.freshContainer(source);
            isTrunk = true;
        }
        if (expanded !== fluid.NO_VALUE) {
            deliverer(expanded);
        }
        if (isTrunk) {
            recurse(expanded, source, i, segs, policy);
        }
        return expanded;
    };

    fluid.guardCircularExpansion = function (segs, i) {
        if (i > fluid.strategyRecursionBailout) {
            fluid.fail("Overflow/circularity in options expansion, current path is ", segs, " at depth " , i, " - please ensure options are not circularly connected, or protect from expansion using the \"noexpand\" policy or expander");
        }
    };

    fluid.makeExpandStrategy = function (options) {
        var recurse = function (target, source, i, segs, policy) {
            return fluid.fetchExpandChildren(target, i || 0, segs || [], source, policy, options);
        };
        var strategy = function (target, name, i, segs, source, policy) {
            fluid.guardCircularExpansion(segs, i);
            if (!target) {
                return;
            }
            if (target.hasOwnProperty(name)) { // bail out if our work has already been done
                return target[name];
            }
            if (source === undefined) { // recover our state in case this is an external entry point
                source = regenerateCursor(options.source, segs, i - 1, options.sourceStrategy);
                policy = regenerateCursor(options.mergePolicy, segs, i - 1, fluid.concreteTrundler);
            }
            var thisSource = options.sourceStrategy(source, name, i, segs);
            var thisPolicy = fluid.concreteTrundler(policy, name);
            function deliverer(value) {
                target[name] = value;
            }
            return fluid.expandSource(options, target, i, segs, deliverer, thisSource, thisPolicy, recurse);
        };
        options.recurse = recurse;
        options.strategy = strategy;
        return strategy;
    };

    fluid.defaults("fluid.makeExpandOptions", {
        ELstyle:          "${}",
        bareContextRefs:  true,
        target:           fluid.inCreationMarker
    });

    fluid.makeExpandOptions = function (source, options) {
        options = $.extend({}, fluid.rawDefaults("fluid.makeExpandOptions"), options);
        options.defaultEL = options.ELStyle === "${}" && options.bareContextRefs; // optimisation to help expander
        options.expandSource = function (source) {
            return fluid.expandSource(options, null, 0, [], fluid.identity, source, options.mergePolicy, false);
        };
        if (!fluid.isUnexpandable(source)) {
            options.source = source;
            options.target = fluid.freshContainer(source);
            options.sourceStrategy = options.sourceStrategy || fluid.concreteTrundler;
            fluid.makeExpandStrategy(options);
            options.initter = function () {
                options.target = fluid.fetchExpandChildren(options.target, 0, [], options.source, options.mergePolicy, options);
            };
        }
        else { // these init immediately since we must deliver a valid root target
            options.strategy = fluid.concreteTrundler;
            options.initter = fluid.identity;
            if (typeof(source) === "string") {
                // Copy is necessary to resolve FLUID-6213 since targets are regularly scrawled over with "undefined" by dim expansion pathway
                // However, we can't screw up object identity for uncloneable things like events resolved via local expansion
                options.target = (options.defer ? fluid.copy : fluid.identity)(options.expandSource(source));
            }
            else {
                options.target = source;
            }
            options.immutableTarget = true;
        }
        return options;
    };

    // supported, PUBLIC API function
    fluid.expand = function (source, options) {
        var expandOptions = fluid.makeExpandOptions(source, options);
        expandOptions.initter();
        return expandOptions.target;
    };

    fluid.preExpandRecurse = function (root, source, holder, member, rootSegs) { // on entry, holder[member] = source
        fluid.guardCircularExpansion(rootSegs, rootSegs.length);
        function pushExpander(expander) {
            root.expanders.push({expander: expander, holder: holder, member: member});
            delete holder[member];
        }
        if (fluid.isIoCReference(source)) {
            var parsed = fluid.parseContextReference(source);
            var segs = fluid.model.parseEL(parsed.path);
            pushExpander({
                typeFunc: fluid.expander.fetch,
                context: parsed.context,
                segs: segs
            });
        } else if (fluid.isPlainObject(source)) {
            if (source.expander) {
                source.expander.typeFunc = fluid.getGlobalValue(source.expander.type || "fluid.invokeFunc");
                pushExpander(source.expander);
            } else {
                fluid.each(source, function (value, key) {
                    rootSegs.push(key);
                    fluid.preExpandRecurse(root, value, source, key, rootSegs);
                    rootSegs.pop();
                });
            }
        }
    };

    fluid.preExpand = function (source) {
        var root = {
            expanders: [],
            source: fluid.isUnexpandable(source) ? source : fluid.copy(source)
        };
        fluid.preExpandRecurse(root, root.source, root, "source", []);
        return root;
    };

    // Main pathway for freestanding material that is not part of a component's options
    fluid.expandImmediate = function (source, that, localRecord) {
        var options = fluid.makeStackResolverOptions(that, localRecord, true); // TODO: ELstyle and target are now ignored
        var root = fluid.preExpand(source);
        fluid.expandImmediateImpl(root, options);
        return root.source;
    };

    // High performance expander for situations such as invokers, listeners, where raw materials can be cached - consumes "root" structure produced by preExpand
    fluid.expandImmediateImpl = function (root, options) {
        var expanders = root.expanders;
        for (var i = 0; i < expanders.length; ++i) {
            var expander = expanders[i];
            expander.holder[expander.member] = expander.expander.typeFunc(null, expander, options);
        }
    };

    fluid.expandExpander = function (deliverer, source, options) {
        var expander = fluid.getGlobalValue(source.expander.type || "fluid.invokeFunc");
        if (!expander) {
            fluid.fail("Unknown expander with type " + source.expander.type);
        }
        return expander(deliverer, source, options);
    };

    fluid.registerNamespace("fluid.expander");

    // "deliverer" is null in the new (fast) pathway, this is a relic of the old "source expander" signature. It appears we can already globally remove this
    fluid.expander.fetch = function (deliverer, source, options) {
        var localRecord = options.localRecord, context = source.expander.context, segs = source.expander.segs;
        // TODO: Either type-check on context as string or else create fetchSlow
        var inLocal = localRecord[context] !== undefined;
        var contextStatus = options.contextThat.lifecycleStatus;
        // somewhat hack to anticipate "fits" for FLUID-4925 - we assume that if THIS component is in construction, its reference target might be too
        // if context is destroyed, we are most likely in an afterDestroy listener and so path records have been destroyed
        var fast = contextStatus === "treeConstructed" || contextStatus === "destroyed";
        var component = inLocal ? localRecord[context] : fluid.resolveContext(context, options.contextThat, fast);
        if (component) {
            var root = component;
            if (inLocal || component.lifecycleStatus !== "constructing") {
                for (var i = 0; i < segs.length; ++i) { // fast resolution of paths when no ginger process active
                    root = root ? root[segs[i]] : undefined;
                }
            } else {
                root = fluid.getForComponent(component, segs);
            }
            if (root === undefined && !inLocal) { // last-ditch attempt to get exotic EL value from component
                root = fluid.getForComponent(component, segs);
            }
            return root;
        } else if (segs.length > 0) {
            fluid.triggerMismatchedPathError(source.expander, options.contextThat);
        }
    };

    /* "light" expanders, starting with the default expander invokeFunc,
         which makes an arbitrary function call (after expanding arguments) and are then replaced in
         the configuration with the call results. These will probably be abolished and replaced with
         equivalent model transformation machinery */

    // This one is now positioned as the "universal expander" - default if no type supplied
    fluid.invokeFunc = function (deliverer, source, options) {
        var expander = source.expander;
        var args = fluid.makeArray(expander.args);
        var whichFuncEntry = expander.func ? "func" : (expander.funcName ? "funcName" : null);
        expander.args = args; // head off case where args is an EL reference which resolves to an array
        if (options.recurse) { // only available in the path from fluid.expandOptions - this will be abolished in the end
            args = options.recurse([], args);
        } else {
            expander = fluid.expandImmediate(expander, options.contextThat, options.localRecord);
            args = expander.args;
        }
        var funcEntry = expander[whichFuncEntry];
        var func = (options.expandSource ? options.expandSource(funcEntry) : funcEntry) || fluid.recordToApplicable(expander, options.contextThat);
        if (typeof(func) === "string") {
            func = fluid.getGlobalValue(func);
        }
        if (!func) {
            fluid.fail("Error in expander record ", source.expander, ": " + source.expander[whichFuncEntry] + " could not be resolved to a function for component ", options.contextThat);
        }
        return func.apply(null, args);
    };

    // The "noexpand" expander which simply unwraps one level of expansion and ceases.
    fluid.noexpand = function (deliverer, source) {
        return source.expander.value ? source.expander.value : source.expander.tree;
    };

})(jQuery, fluid_3_0_0);
;/*
Copyright The Infusion copyright holders
See the AUTHORS.md file at the top-level directory of this distribution and at
https://github.com/fluid-project/infusion/raw/master/AUTHORS.md.

Licensed under the Educational Community License (ECL), Version 2.0 or the New
BSD license. You may not use this file except in compliance with one these
Licenses.

You may obtain a copy of the ECL 2.0 License and BSD License at
https://github.com/fluid-project/infusion/raw/master/Infusion-LICENSE.txt
*/

var fluid_3_0_0 = fluid_3_0_0 || {};

(function ($, fluid) {
    "use strict";

    /** NOTE: The contents of this file are by default NOT PART OF THE PUBLIC FLUID API unless explicitly annotated before the function **/

    /** MODEL ACCESSOR ENGINE **/

    /** Standard strategies for resolving path segments **/

    fluid.model.makeEnvironmentStrategy = function (environment) {
        return function (root, segment, index) {
            return index === 0 && environment[segment] ?
                environment[segment] : undefined;
        };
    };

    fluid.model.defaultCreatorStrategy = function (root, segment) {
        if (root[segment] === undefined) {
            root[segment] = {};
            return root[segment];
        }
    };

    fluid.model.defaultFetchStrategy = function (root, segment) {
        return root[segment];
    };

    fluid.model.funcResolverStrategy = function (root, segment) {
        if (root.resolvePathSegment) {
            return root.resolvePathSegment(segment);
        }
    };

    fluid.model.traverseWithStrategy = function (root, segs, initPos, config, uncess) {
        var strategies = config.strategies;
        var limit = segs.length - uncess;
        for (var i = initPos; i < limit; ++i) {
            if (!root) {
                return root;
            }
            var accepted;
            for (var j = 0; j < strategies.length; ++j) {
                accepted = strategies[j](root, segs[i], i + 1, segs);
                if (accepted !== undefined) {
                    break; // May now short-circuit with stateless strategies
                }
            }
            if (accepted === fluid.NO_VALUE) {
                accepted = undefined;
            }
            root = accepted;
        }
        return root;
    };

    /* Returns both the value and the path of the value held at the supplied EL path */
    fluid.model.getValueAndSegments = function (root, EL, config, initSegs) {
        return fluid.model.accessWithStrategy(root, EL, fluid.NO_VALUE, config, initSegs, true);
    };

    // Very lightweight remnant of trundler, only used in resolvers
    fluid.model.makeTrundler = function (config) {
        return function (valueSeg, EL) {
            return fluid.model.getValueAndSegments(valueSeg.root, EL, config, valueSeg.segs);
        };
    };

    fluid.model.getWithStrategy = function (root, EL, config, initSegs) {
        return fluid.model.accessWithStrategy(root, EL, fluid.NO_VALUE, config, initSegs);
    };

    fluid.model.setWithStrategy = function (root, EL, newValue, config, initSegs) {
        fluid.model.accessWithStrategy(root, EL, newValue, config, initSegs);
    };

    fluid.model.accessWithStrategy = function (root, EL, newValue, config, initSegs, returnSegs) {
        // This function is written in this unfortunate style largely for efficiency reasons. In many cases
        // it should be capable of running with 0 allocations (EL is preparsed, initSegs is empty)
        if (!fluid.isPrimitive(EL) && !fluid.isArrayable(EL)) {
            var key = EL.type || "default";
            var resolver = config.resolvers[key];
            if (!resolver) {
                fluid.fail("Unable to find resolver of type " + key);
            }
            var trundler = fluid.model.makeTrundler(config); // very lightweight trundler for resolvers
            var valueSeg = {root: root, segs: initSegs};
            valueSeg = resolver(valueSeg, EL, trundler);
            if (EL.path && valueSeg) { // every resolver supports this piece of output resolution
                valueSeg = trundler(valueSeg, EL.path);
            }
            return returnSegs ? valueSeg : (valueSeg ? valueSeg.root : undefined);
        }
        else {
            return fluid.model.accessImpl(root, EL, newValue, config, initSegs, returnSegs, fluid.model.traverseWithStrategy);
        }
    };

    // Implementation notes: The EL path manipulation utilities here are equivalents of the simpler ones
    // that are provided in Fluid.js and elsewhere - they apply escaping rules to parse characters .
    // as \. and \ as \\ - allowing us to process member names containing periods. These versions are mostly
    // in use within model machinery, whereas the cheaper versions based on String.split(".") are mostly used
    // within the IoC machinery.
    // Performance testing in early 2015 suggests that modern browsers now allow these to execute slightly faster
    // than the equivalent machinery written using complex regexps - therefore they will continue to be maintained
    // here. However, there is still a significant performance gap with respect to the performance of String.split(".")
    // especially on Chrome, so we will continue to insist that component member names do not contain a "." character
    // for the time being.
    // See http://jsperf.com/parsing-escaped-el for some experiments

    fluid.registerNamespace("fluid.pathUtil");

    fluid.pathUtil.getPathSegmentImpl = function (accept, path, i) {
        var segment = null;
        if (accept) {
            segment = "";
        }
        var escaped = false;
        var limit = path.length;
        for (; i < limit; ++i) {
            var c = path.charAt(i);
            if (!escaped) {
                if (c === ".") {
                    break;
                }
                else if (c === "\\") {
                    escaped = true;
                }
                else if (segment !== null) {
                    segment += c;
                }
            }
            else {
                escaped = false;
                if (segment !== null) {
                    segment += c;
                }
            }
        }
        if (segment !== null) {
            accept[0] = segment;
        }
        return i;
    };

    var globalAccept = []; // TODO: reentrancy risk here. This holder is here to allow parseEL to make two returns without an allocation.

    /* A version of fluid.model.parseEL that apples escaping rules - this allows path segments
     * to contain period characters . - characters "\" and "}" will also be escaped. WARNING -
     * this current implementation is EXTREMELY slow compared to fluid.model.parseEL and should
     * not be used in performance-sensitive applications */
    // supported, PUBLIC API function
    fluid.pathUtil.parseEL = function (path) {
        var togo = [];
        var index = 0;
        var limit = path.length;
        while (index < limit) {
            var firstdot = fluid.pathUtil.getPathSegmentImpl(globalAccept, path, index);
            togo.push(globalAccept[0]);
            index = firstdot + 1;
        }
        return togo;
    };

    // supported, PUBLIC API function
    fluid.pathUtil.composeSegment = function (prefix, toappend) {
        toappend = toappend.toString();
        for (var i = 0; i < toappend.length; ++i) {
            var c = toappend.charAt(i);
            if (c === "." || c === "\\" || c === "}") {
                prefix += "\\";
            }
            prefix += c;
        }
        return prefix;
    };

    /* Escapes a single path segment by replacing any character ".", "\" or "}" with itself prepended by \ */
    // supported, PUBLIC API function
    fluid.pathUtil.escapeSegment = function (segment) {
        return fluid.pathUtil.composeSegment("", segment);
    };

    /*
     * Compose a prefix and suffix EL path, where the prefix is already escaped.
     * Prefix may be empty, but not null. The suffix will become escaped.
     */
    // supported, PUBLIC API function
    fluid.pathUtil.composePath = function (prefix, suffix) {
        if (prefix.length !== 0) {
            prefix += ".";
        }
        return fluid.pathUtil.composeSegment(prefix, suffix);
    };

    /*
     * Compose a set of path segments supplied as arguments into an escaped EL expression. Escaped version
     * of fluid.model.composeSegments
     */

    // supported, PUBLIC API function
    fluid.pathUtil.composeSegments = function () {
        var path = "";
        for (var i = 0; i < arguments.length; ++i) {
            path = fluid.pathUtil.composePath(path, arguments[i]);
        }
        return path;
    };

    /* Helpful utility for use in resolvers - matches a path which has already been parsed into segments */
    fluid.pathUtil.matchSegments = function (toMatch, segs, start, end) {
        if (end - start !== toMatch.length) {
            return false;
        }
        for (var i = start; i < end; ++i) {
            if (segs[i] !== toMatch[i - start]) {
                return false;
            }
        }
        return true;
    };

    fluid.model.unescapedParser = {
        parse: fluid.model.parseEL,
        compose: fluid.model.composeSegments
    };

    // supported, PUBLIC API record
    fluid.model.defaultGetConfig = {
        parser: fluid.model.unescapedParser,
        strategies: [fluid.model.funcResolverStrategy, fluid.model.defaultFetchStrategy]
    };

    // supported, PUBLIC API record
    fluid.model.defaultSetConfig = {
        parser: fluid.model.unescapedParser,
        strategies: [fluid.model.funcResolverStrategy, fluid.model.defaultFetchStrategy, fluid.model.defaultCreatorStrategy]
    };

    fluid.model.escapedParser = {
        parse: fluid.pathUtil.parseEL,
        compose: fluid.pathUtil.composeSegments
    };

    // supported, PUBLIC API record
    fluid.model.escapedGetConfig = {
        parser: fluid.model.escapedParser,
        strategies: [fluid.model.defaultFetchStrategy]
    };

    // supported, PUBLIC API record
    fluid.model.escapedSetConfig = {
        parser: fluid.model.escapedParser,
        strategies: [fluid.model.defaultFetchStrategy, fluid.model.defaultCreatorStrategy]
    };

    /** CONNECTED COMPONENTS AND TOPOLOGICAL SORTING **/

    // Following "tarjan" at https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm

    /** Compute the strongly connected components of a graph, specified as a list of vertices and an accessor function.
     * Returns an array of arrays of strongly connected vertices, with each component in topologically sorted order.
     * @param {Vertex[]} vertices - An array of vertices of the graph to be processed. Each vertex object will be polluted
     * with three extra fields: `tarjanIndex`, `lowIndex` and `onStack`.
     * @param {Function} accessor - A function that returns a accepts a vertex and returns a list of vertices connected by edges
     * @return {Array.<Vertex[]>} - An array of arrays of vertices.
     */
    fluid.stronglyConnected = function (vertices, accessor) {
        var that = {
            stack: [],
            accessor: accessor,
            components: [],
            index: 0
        };
        vertices.forEach(function (vertex) {
            delete vertex.lowIndex;
            delete vertex.tarjanIndex;
            delete vertex.onStack;
        });
        vertices.forEach(function (vertex) {
            if (vertex.tarjanIndex === undefined) {
                fluid.stronglyConnectedOne(vertex, that);
            }
        });
        return that.components;
    };

    // Perform one round of the Tarjan search algorithm using the state structure generated in fluid.stronglyConnected
    fluid.stronglyConnectedOne = function (vertex, that) {
        vertex.tarjanIndex = that.index;
        vertex.lowIndex = that.index;
        ++that.index;
        that.stack.push(vertex);
        vertex.onStack = true;
        var outEdges = that.accessor(vertex);
        outEdges.forEach(function (outVertex) {
            if (outVertex.tarjanIndex === undefined) {
                // Successor has not yet been visited; recurse on it
                fluid.stronglyConnectedOne(outVertex, that);
                vertex.lowIndex = Math.min(vertex.lowIndex, outVertex.lowIndex);
            } else if (outVertex.onStack) {
                // Successor is on the stack and hence in the current component
                vertex.lowIndex = Math.min(vertex.lowIndex, outVertex.tarjanIndex);
            }
        });
        // If vertex is a root node, pop the stack back as far as it and generate a component
        if (vertex.lowIndex === vertex.tarjanIndex) {
            var component = [], outVertex;
            do {
                outVertex = that.stack.pop();
                outVertex.onStack = false;
                component.push(outVertex);
            } while (outVertex !== vertex);
            that.components.push(component);
        }
    };

    /** MODEL COMPONENT HIERARCHY AND RELAY SYSTEM **/

    fluid.initRelayModel = function (that) {
        // This simply has the effect of returning the fluid.inEvaluationMarker marker if an access is somehow requested
        // early, which will then trigger the circular evaluation failure
        return that.model;
    };

    fluid.findInitModelTransaction = function (that) {
        var transRec = fluid.currentTreeTransaction();
        if (transRec && fluid.isComponent(that)) {
            return transRec.initModelTransaction[that.id];
        }
    };

    // Enlist this model component as part of the "initial transaction" wave - note that "special transaction" init
    // is indexed by component, not by applier, and has special record type (completeOnInit + initModel), in addition to transaction
    fluid.enlistModelComponent = function (that) {
        var initModelTransaction = fluid.currentTreeTransaction().initModelTransaction;
        var enlist = initModelTransaction[that.id];
        if (!enlist) {
            var shadow = fluid.shadowForComponent(that);
            enlist = {
                that: that,
                applier: fluid.getForComponent(that, "applier"),
                completeOnInit: !!shadow.initTransactionId
            };
            initModelTransaction[that.id] = enlist;
        }
        return enlist;
    };

    fluid.clearTransactions = function () {
        var instantiator = fluid.globalInstantiator;
        fluid.clear(instantiator.modelTransactions);
    };

    fluid.failureEvent.addListener(fluid.clearTransactions, "clearTransactions", "before:fail");

    // Utility to coordinate with our crude "oscillation prevention system" which limits each link to 2 updates (presumably
    // in opposite directions). In the case of the initial transaction, we need to reset the count given that genuine
    // changes are arising in the system with each new enlisted model. TODO: if we ever get users operating their own
    // transactions, think of a way to incorporate this into that workflow
    fluid.clearLinkCounts = function (transRec, relaysAlso) {
        // TODO: Separate this record out into different types of records (relays are already in their own area)
        fluid.each(transRec, function (value, key) {
            if (typeof(value) === "number") {
                transRec[key] = 0;
            } else if (relaysAlso && value.options && typeof(value.relayCount) === "number") {
                value.relayCount = 0;
            }
        });
    };

    /** Compute relay dependency out arcs for a group of initialising components.
     * @param {Object} transacs - Hash of component id to local ChangeApplier transaction.
     * @param {Object} initModelTransaction - Hash of component id to enlisted component record.
     * @return {Object} - Hash of component id to list of enlisted component records which are connected by edges
     */
    fluid.computeInitialOutArcs = function (transacs, initModelTransaction) {
        return fluid.transform(initModelTransaction, function (recel, id) {
            var oneOutArcs = {};
            var listeners = recel.that.applier.listeners.sortedListeners;
            fluid.each(listeners, function (listener) {
                if (listener.isRelay && !fluid.isExcludedChangeSource(transacs[id], listener.cond)) {
                    var targetId = listener.targetId;
                    if (targetId !== id) {
                        oneOutArcs[targetId] = true;
                    }
                }
            });
            var oneOutArcList = Object.keys(oneOutArcs);
            var togo = oneOutArcList.map(function (id) {
                return initModelTransaction[id];
            });
            // No edge if the component is not enlisted - it will sort to the end via "completeOnInit"
            fluid.remove_if(togo, function (rec) {
                return rec === undefined;
            });
            return togo;
        });
    };

    fluid.sortCompleteLast = function (reca, recb) {
        return (reca.completeOnInit ? 1 : 0) - (recb.completeOnInit ? 1 : 0);
    };

    fluid.subscribeResourceModelUpdates = function (that, segs, resourceSpec) {
        var treeTransaction = fluid.currentTreeTransaction();
        var resourceUpdateListener = function (value) {
            // We can't go for currentTreeTransaction() in this listener because we in the "dead space" between workflow
            // functions where it has not been restored by the waitIO listener. Isn't the stack a sod.
            var initTransaction = fluid.getImmediate(treeTransaction, ["initModelTransaction", that.id]);
            var trans = initTransaction ? initTransaction.transaction : that.applier.initiate();
            trans.change(segs, null, "DELETE");
            trans.change(segs, value);
            if (!initTransaction) {
                trans.commit();
            }
        };
        resourceSpec.onFetched.addListener(resourceUpdateListener);
        fluid.recordListener(resourceSpec.onFetched, resourceUpdateListener, fluid.shadowForComponent(that));
    };

    /** Operate all coordinated transactions by bringing models to their respective initial values, and then commit them all
     * @param {Object} initModelTransaction The record for the init transaction. This is a hash indexed by component id
     * to a model transaction record, as registered in `fluid.enlistModelComponent`. This has members `that`, `applier`, `complete`.
     * @param {String} transId The id of the model transaction corresponding to the init model transaction
     */
    fluid.operateInitialTransaction = function (initModelTransaction, transId) {
        var transRec = fluid.getModelTransactionRec(fluid.rootComponent, transId);
        var transac;
        var transacs = fluid.transform(initModelTransaction, function (recel) {
            transac = recel.that.applier.initiate(null, "init", transId);
            transRec[recel.that.applier.applierId] = {transaction: transac};
            // Also store it in the init transaction record so it can be easily globbed onto in applier.fireChangeRequest
            recel.transaction = transac;
            return transac;
        });
        // Compute the graph of init transaction relays for FLUID-6234 - one day we will have to do better than this, since there
        // may be finer structure than per-component - it may be that each piece of model area participates in this relation
        // differently. But this will require even more ambitious work such as fragmenting all the initial model values along
        // these boundaries.
        var outArcs = fluid.computeInitialOutArcs(transacs, initModelTransaction);
        var arcAccessor = function (initTransactionRecord) {
            return outArcs[initTransactionRecord.that.id];
        };
        var recs = fluid.values(initModelTransaction);
        var components = fluid.stronglyConnected(recs, arcAccessor);
        var priorityIndex = 0;
        components.forEach(function (component) {
            component.forEach(function (recel) {
                recel.initPriority = recel.completeOnInit ? Infinity : priorityIndex++;
            });
        });

        recs.sort(function (reca, recb) {
            return reca.initPriority - recb.initPriority;
        });
        recs.forEach(function (recel) {
            var that = recel.that,
                applier = that.applier,
                transac = transacs[that.id];
            if (recel.completeOnInit) {
                // Play the stabilised model value of previously complete components into the relay network
                fluid.notifyModelChanges(applier.listeners.sortedListeners, "ADD", transac.oldHolder, fluid.emptyHolder, null, transac, applier, that);
            } else {
                applier.resourceMap.forEach(function (resourceMapEntry) {
                    fluid.subscribeResourceModelUpdates(that, resourceMapEntry.segs, resourceMapEntry.fetchOne.resourceSpec);
                });
                fluid.each(recel.initModels, function (oneInitModel) {
                    if (oneInitModel !== undefined) {
                        transac.fireChangeRequest({type: "ADD", segs: [], value: oneInitModel});
                    }
                    fluid.clearLinkCounts(transRec, true);
                });
                // Ensure that the model can be read as early as possible through non-model interactions resolved via {that}.model
                that.model = transac.newHolder.model;
                applier.earlyModelResolved.fire(that.model);
                // Note that if there is a further operateInitialTransaction for this same init transaction, next time we should treat it as stabilised
                recel.completeOnInit = true;
            }
            var shadow = fluid.shadowForComponent(that);
            if (shadow && !shadow.initTransactionId) { // Fix for FLUID-5869 - the component may have been destroyed during its own init transaction
            // read in fluid.enlistModelComponent in order to compute the completeOnInit flag
                shadow.initTransactionId = transId;
            }
        });
    };

    fluid.parseModelReference = function (that, ref) {
        var parsed = fluid.parseContextReference(ref);
        parsed.segs = fluid.pathUtil.parseEL(parsed.path);
        return parsed;
    };

    /** Given a string which may represent a reference into a model, parses it into a structure holding the coordinates for resolving the reference. It specially
     * detects "references into model material" by looking for the first path segment in the path reference which holds the value "model". Some of its workflow is bypassed
     * in the special case of a reference representing an implicit model relay. In this case, ref will definitely be a String, and if it does not refer to model material, rather than
     * raising an error, the return structure will include a field <code>nonModel: true</code>
     * @param {Component} that - The component holding the reference
     * @param {String} name - A human-readable string representing the type of block holding the reference - e.g. "modelListeners"
     * @param {String|ModelReference} ref - The model reference to be parsed. This may have already been partially parsed at the original site - that is, a ModelReference is a
     * structure containing
     *     segs: {String[]} An array of model path segments to be dereferenced in the target component (will become `modelSegs` in the final return)
     *     context: {String} An IoC reference to the component holding the model
     * @param {Boolean} implicitRelay - <code>true</code> if the reference was being resolved for an implicit model relay - that is,
     * whether it occured within the `model` block itself. In this case, references to non-model material are not a failure and will simply be resolved
     * (by the caller) onto their targets (as constants). Otherwise, this function will issue a failure on discovering a reference to non-model material.
     * @return {ParsedModelReference} - A structure holding:
     *    that {Component|Any} The component whose model is the target of the reference. This may end up being constructed as part of the act of resolving the reference.
     * in the case of a reference to "local record" material such as {arguments} or {source}, `that` may exceptionally be a non-component.
     *    applier {ChangeApplier|Undefined} The changeApplier for the component <code>that</code>. This may end up being constructed as part of the act of resolving the reference
     *    modelSegs {String[]|Undefined} An array of path segments into the model of the component if this is a model reference
     *    path {String} the value of <code>modelSegs</code> encoded as an EL path (remove client uses of this in time)
     *    nonModel {Boolean} Set if <code>implicitRelay</code> was true and the reference was not into a model (modelSegs/path will not be set in this case)
     *    segs {String[]} Holds the full array of path segments found by parsing the original reference - only useful in <code>nonModel</code> case
     */
    fluid.parseValidModelReference = function (that, name, ref, implicitRelay) {
        var localRecord = fluid.shadowForComponent(that).localRecord;
        var reject = function () {
            var failArgs = ["Error in " + name + ": ", ref].concat(fluid.makeArray(arguments));
            fluid.fail.apply(null, failArgs);
        };
        var rejectNonModel = function (value) {
            reject(" must be a reference to a component with a ChangeApplier (descended from fluid.modelComponent), instead got ", value);
        };
        var parsed; // resolve ref into context and modelSegs
        if (typeof(ref) === "string") {
            if (fluid.isIoCReference(ref)) {
                parsed = fluid.parseModelReference(that, ref);
                var modelPoint = parsed.segs.indexOf("model");
                if (modelPoint === -1) {
                    if (implicitRelay) {
                        parsed.nonModel = true;
                    } else {
                        reject(" must be a reference into a component model via a path including the segment \"model\"");
                    }
                } else {
                    parsed.modelSegs = parsed.segs.slice(modelPoint + 1);
                    parsed.contextSegs = parsed.segs.slice(0, modelPoint);
                    delete parsed.path;
                }
            } else {
                parsed = {
                    path: ref,
                    modelSegs: that.applier.parseEL(ref)
                };
            }
        } else {
            if (!fluid.isArrayable(ref.segs)) {
                reject(" must contain an entry \"segs\" holding path segments referring a model path within a component");
            }
            parsed = {
                context: ref.context,
                modelSegs: fluid.expandOptions(ref.segs, that)
            };
        }
        var contextTarget, target; // resolve target component, which defaults to "that"
        if (parsed.context) {
            // cf. logic in fluid.makeStackFetcher
            if (localRecord && parsed.context in localRecord) {
                // It's a "source" reference for a lensed component
                if (parsed.context === "source" && localRecord.sourceModelReference) {
                    target = localRecord.sourceModelReference.that;
                    parsed.modelSegs = localRecord.sourceModelReference.modelSegs.concat(parsed.segs);
                    parsed.nonModel = false;
                } else { // It's an ordinary reference to localRecord material - FLUID-5912 case
                    target = localRecord[parsed.context];
                }
            } else {
                contextTarget = fluid.resolveContext(parsed.context, that);
                if (!contextTarget) {
                    reject(" context must be a reference to an existing component");
                }
                target = parsed.contextSegs ? fluid.getForComponent(contextTarget, parsed.contextSegs) : contextTarget;
            }
        } else {
            target = that;
        }
        if (!parsed.nonModel) {
            if (!fluid.isComponent(target)) {
                rejectNonModel(target);
            }
            if (!target.applier) {
                fluid.getForComponent(target, ["applier"]);
            }
            if (!target.applier) {
                rejectNonModel(target);
            }
        }
        parsed.that = target;
        parsed.applier = target && target.applier;
        if (!parsed.path) { // ChangeToApplicable amongst others rely on this
            parsed.path = target && target.applier.composeSegments.apply(null, parsed.modelSegs);
        }
        return parsed;
    };

    // Gets global record for a particular transaction id, allocating if necessary - looks up applier id to transaction,
    // as well as looking up source id (linkId in below) to count/true
    // Through poor implementation quality, not every access passes through this function - some look up instantiator.modelTransactions directly
    fluid.getModelTransactionRec = function (that, transId) {
        if (!transId) {
            fluid.fail("Cannot get transaction record without transaction id");
        }
        var instantiator = fluid.isComponent(that) && !fluid.isDestroyed(that) ? fluid.globalInstantiator : null;
        if (!instantiator) {
            return null;
        }
        var transRec = instantiator.modelTransactions[transId];
        if (!transRec) {
            transRec = instantiator.modelTransactions[transId] = {
                relays: [], // sorted array of relay elements (also appear at top level index by transaction id)
                sources: {}, // hash of the global transaction sources (includes "init" but excludes "relay" and "local")
                externalChanges: {} // index by applierId to changePath to listener record
            };
        }
        return transRec;
    };

    fluid.recordChangeListener = function (component, applier, sourceListener, listenerId) {
        var shadow = fluid.shadowForComponent(component);
        fluid.recordListener(applier.modelChanged, sourceListener, shadow, listenerId);
    };

    /** Called when a relay listener registered using `fluid.registerDirectChangeRelay` enlists in a transaction. Opens a local
     * representative of this transaction on `targetApplier`, creates and stores a "transaction element" within the global transaction
     * record keyed by the target applier's id. The transaction element is also pushed onto the `relays` member of the global transaction record - they
     * will be sorted by priority here when changes are fired.
     * @param {TransactionRecord} transRec - The global record for the current ChangeApplier transaction as retrieved from `fluid.getModelTransactionRec`
     * @param {ChangeApplier} targetApplier - The ChangeApplier to which outgoing changes will be applied. A local representative of the transaction will be opened on this applier and returned.
     * @param {String} transId - The global id of this transaction
     * @param {Object} options - The `options` argument supplied to `fluid.registerDirectChangeRelay`. This will be stored in the returned transaction element
     * - note that only the member `update` is ever used in `fluid.model.updateRelays` - TODO: We should thin this out
     * @param {Object} npOptions - Namespace and priority options
     *    namespace {String} [optional] The namespace attached to this relay definition
     *    priority {String} [optional] The (unparsed) priority attached to this relay definition
     * @return {Object} A "transaction element" holding information relevant to this relay's enlistment in the current transaction. This includes fields:
     *     transaction {Transaction} The local representative of this transaction created on `targetApplier`
     *     relayCount {Integer} The number of times this relay has been activated in this transaction
     *     namespace {String} [optional] Namespace for this relay definition
     *     priority {Priority} The parsed priority definition for this relay
     */
    fluid.registerRelayTransaction = function (transRec, targetApplier, transId, options, npOptions) {
        var newTrans = targetApplier.initiate("relay", null, transId); // non-top-level transaction will defeat postCommit
        var transEl = transRec[targetApplier.applierId] = {transaction: newTrans, relayCount: 0, namespace: npOptions.namespace, priority: npOptions.priority, options: options};
        transEl.priority = fluid.parsePriority(transEl.priority, transRec.relays.length, false, "model relay");
        transRec.relays.push(transEl);
        return transEl;
    };

    // Configure this parameter to tweak the number of relays the model will attempt per transaction before bailing out with an error
    fluid.relayRecursionBailout = 100;

    // Used with various arg combinations from different sources. For standard "implicit relay" or fully lensed relay,
    // the first 4 args will be set, and "options" will be empty

    // For a model-dependent relay, this will be used in two halves - firstly, all of the model
    // sources will bind to the relay transform document itself. In this case the argument "targetApplier" within "options" will be set.
    // In this case, the component known as "target" is really the source - it is a component reference discovered by parsing the
    // relay document.

    // Secondly, the relay itself will schedule an invalidation (as if receiving change to "*" of its source - which may in most
    // cases actually be empty) and play through its transducer. "Source" component itself is never empty, since it is used for listener
    // degistration on destruction (check this is correct for external model relay). However, "sourceSegs" may be empty in the case
    // there is no "source" component registered for the link. This change is played in a "half-transactional" way - that is, we wait
    // for all other changes in the system to settle before playing the relay document, in order to minimise the chances of multiple
    // firing and corruption. This is done via the "preCommit" hook registered at top level in establishModelRelay. This listener
    // is transactional but it does not require the transaction to conclude in order to fire - it may be reused as many times as
    // required within the "overall" transaction whilst genuine (external) changes continue to arrive.

    // TODO: Vast overcomplication and generation of closure garbage. SURELY we should be able to convert this into an externalised, arg-ist form
    /** Registers a listener operating one leg of a model relay relation, connecting the source and target. Called once or twice from `fluid.connectModelRelay` -
     * see the comment there for the three cases involved. Note that in its case iii)B) the applier to bind to is not the one attached to `target` but is instead
     * held in `options.targetApplier`.
     * @param {Object} target - The target component at the end of the relay.
     * @param {String[]} targetSegs - String segments representing the path in the target where outgoing changes are to be fired
     * @param {Component|null} source - The source component from where changes will be listened to. May be null if the change source is a relay document.
     * @param {String[]} sourceSegs - String segments representing the path in the source component's model at which changes will be listened to
     * @param {String} linkId - The unique id of this relay arc. This will be used as a key within the active transaction record to look up dynamic information about
     *     activation of the link within that transaction (currently just an activation count)
     * @param {Function|null} transducer - A function which will be invoked when a change is to be relayed. This is one of the adapters constructed in "makeTransformPackage"
     *     and is set in all cases other than iii)B) (collecting changes to contextualised relay). Note that this will have a member `cond` as returned from
     *    `fluid.model.parseRelayCondition` encoding the condition whereby changes should be excluded from the transaction. The rule encoded by the condition
     *    will be applied by the function within `transducer`.
     * @param {Object} options -
     *    transactional {Boolean} `true` in case iii) - although this only represents `half-transactions`, `false` in others since these are resolved immediately with no granularity
     *    targetApplier {ChangeApplier} [optional] in case iii)B) holds the applier for the contextualised relay document which outgoing changes should be applied to
     *    sourceApplier {ChangeApplier} [optional] in case ii) holds the applier for the contextualised relay document on which we listen for outgoing changes
     * @param {Object} npOptions - Namespace and priority options
     *    namespace {String} [optional] The namespace attached to this relay definition
     *    priority {String} [optional] The (unparsed) priority attached to this relay definition
     */
    fluid.registerDirectChangeRelay = function (target, targetSegs, source, sourceSegs, linkId, transducer, options, npOptions) {
        var targetApplier = options.targetApplier || target.applier; // first branch implies the target is a relay document
        var sourceApplier = options.sourceApplier || source.applier; // first branch implies the source is a relay document - listener will be transactional
        var applierId = targetApplier.applierId;
        targetSegs = fluid.makeArray(targetSegs);
        sourceSegs = fluid.makeArray(sourceSegs); // take copies since originals will be trashed
        var sourceListener = function (newValue, oldValue, path, changeRequest, trans, applier) {
            var transId = trans.id;
            var transRec = fluid.getModelTransactionRec(target, transId);
            if (applier && trans && !transRec[applier.applierId]) { // don't trash existing record which may contain "options" (FLUID-5397)
                transRec[applier.applierId] = {transaction: trans}; // enlist the outer user's original transaction
            }
            var existing = transRec[applierId];
            transRec[linkId] = transRec[linkId] || 0;
            // Crude "oscillation prevention" system limits each link to maximum of 2 operations per cycle (presumably in opposite directions)
            var relay = true; // TODO: See FLUID-5303 - we currently disable this check entirely to solve FLUID-5293 - perhaps we might remove link counts entirely
            if (relay) {
                ++transRec[linkId];
                if (transRec[linkId] > fluid.relayRecursionBailout) {
                    fluid.fail("Error in model relay specification at component ", target, " - operated more than " + fluid.relayRecursionBailout + " relays without model value settling - current model contents are ", trans.newHolder.model);
                }
                if (!existing) {
                    existing = fluid.registerRelayTransaction(transRec, targetApplier, transId, options, npOptions);
                }
                if (transducer && !options.targetApplier) {
                    // TODO: This is just for safety but is still unusual and now abused. The transducer doesn't need the "newValue" since all the transform information
                    // has been baked into the transform document itself. However, we now rely on this special signalling value to make sure we regenerate transforms in
                    // the "forwardAdapter"
                    transducer(existing.transaction, options.sourceApplier ? undefined : newValue, sourceSegs, targetSegs, changeRequest);
                } else {
                    if (changeRequest && changeRequest.type === "DELETE") {
                        existing.transaction.fireChangeRequest({type: "DELETE", segs: targetSegs});
                    }
                    if (newValue !== undefined) {
                        existing.transaction.fireChangeRequest({type: "ADD", segs: targetSegs, value: newValue});
                    }
                }
            }
        };
        var spec = sourceApplier.modelChanged.addListener({
            isRelay: true,
            cond: transducer && transducer.cond,
            targetId: target.id, // these two fields for debuggability
            targetApplierId: targetApplier.id,
            segs: sourceSegs,
            transactional: options.transactional
        }, sourceListener);
        if (fluid.passLogLevel(fluid.logLevel.TRACE)) {
            fluid.log(fluid.logLevel.TRACE, "Adding relay listener with listenerId " + spec.listenerId + " to source applier with id " +
                sourceApplier.applierId + " from target applier with id " + applierId + " for target component with id " + target.id);
        }
        if (source) { // TODO - we actually may require to register on THREE sources in the case modelRelay is attached to a
            // component which is neither source nor target. Note there will be problems if source, say, is destroyed and recreated,
            // and holder is not - relay will in that case be lost. Need to integrate relay expressions with IoCSS.
            fluid.recordChangeListener(source, sourceApplier, sourceListener, spec.listenerId);
            if (target !== source) {
                fluid.recordChangeListener(target, sourceApplier, sourceListener, spec.listenerId);
            }
        }
    };

    /** Connect a model relay relation between model material. This is called in three scenarios:
     * i) from `fluid.parseModelRelay` when parsing an uncontextualised model relay (one with a static transform document), to
     * directly connect the source and target of the relay
     * ii) from `fluid.parseModelRelay` when parsing a contextualised model relay (one whose transform document depends on other model
     * material), to connect updates emitted from the transform document's applier onto the relay ends (both source and target)
     * iii) from `fluid.parseImplicitRelay` when parsing model references found within contextualised model relay to bind changes emitted
     * from the target of the reference onto the transform document's applier. These may apply directly to another component's model (in its case
     * A) or apply to a relay document (in its case B)
     *
     * This function will make one or two calls to `fluid.registerDirectChangeRelay` in order to set up each leg of any required relay.
     * Note that in case iii)B) the component referred to as our argument `target` is actually the "source" of the changes (that is, the one encountered
     * while traversing the transform document), and our argument `source` is the component holding the transform, and so
     * the call to `fluid.registerDirectChangeRelay` will have `source` and `target` reversed (`fluid.registerDirectChangeRelay` will bind to the `targetApplier`
     * in the options rather than source's applier).
     * @param {Component} source - The component holding the material giving rise to the relay, or the one referred to by the `source` member
     *   of the configuration in case ii), if there is one
     * @param {Array|null} sourceSegs - An array of parsed string segments of the `source` relay reference in case i), or the offset into the transform
     *   document of the reference component in case iii), otherwise `null` (case ii))
     * @param {Component} target - The component holding the model relay `target` in cases i) and ii), or the component at the other end of
     *   the model reference in case iii) (in this case in fact a "source" for the changes.
     * @param {Array} targetSegs - An array of parsed string segments of the `target` reference in cases i) and ii), or of the model reference in
     *   case iii)
     * @param {Object} options - A structure describing the relay, allowing discrimination of the various cases above. This is derived from the return from
     * `fluid.makeTransformPackage` but will have some members filtered in different cases. This contains members:
     *    update {Function} A function to be called at the end of a "half-transaction" when all pending updates have been applied to the document's applier.
     *        This discriminates case iii)
     *    targetApplier {ChangeApplier} The ChangeApplier for the relay document, in case iii)B)
     *    forwardApplier (ChangeApplier} The ChangeApplier for the relay document, in cases ii) and iii)B) (only used in latter case)
     *    forwardAdapter {Adapter} A function accepting (transaction, newValue) to pass through the forward leg of the relay. Contains a member `cond` holding the parsed relay condition.
     *    backwardAdapter {Adapter} A function accepting (transaction, newValue) to pass through the backward leg of the relay. Contains a member `cond` holding the parsed relay condition.
     *    namespace {String} Namespace for any relay definition
     *    priority {String} Priority for any relay definition or synthetic "first" for iii)A)
     */
    fluid.connectModelRelay = function (source, sourceSegs, target, targetSegs, options) {
        var linkId = fluid.allocateGuid();
        fluid.enlistModelComponent(target);
        fluid.enlistModelComponent(source); // role of "source" and "target" are swapped in case iii)B)
        var npOptions = fluid.filterKeys(options, ["namespace", "priority"]);

        if (options.update) { // it is a call for a relay document - ii) or iii)B)
            if (options.targetApplier) { // case iii)B)
                // We are in the middle of parsing a contextualised relay, and this call has arrived via its parseImplicitRelay.
                // register changes from the target model onto changes to the model relay document
                fluid.registerDirectChangeRelay(source, sourceSegs, target, targetSegs, linkId, null, {
                    transactional: false,
                    targetApplier: options.targetApplier,
                    update: options.update
                }, npOptions);
            } else { // case ii), contextualised relay overall output
                // Rather than bind source-source, instead register the "half-transactional" listener which binds changes
                // from the relay document itself onto the target
                fluid.registerDirectChangeRelay(target, targetSegs, source, [], linkId + "-transform", options.forwardAdapter, {transactional: true, sourceApplier: options.forwardApplier}, npOptions);
            }
        } else { // case i) or iii)A): more efficient, old-fashioned branch where relay is uncontextualised
            fluid.registerDirectChangeRelay(target, targetSegs, source, sourceSegs, linkId, options.forwardAdapter, {transactional: false}, npOptions);
            fluid.registerDirectChangeRelay(source, sourceSegs, target, targetSegs, linkId, options.backwardAdapter, {transactional: false}, npOptions);
        }
    };

    fluid.parseSourceExclusionSpec = function (targetSpec, sourceSpec) {
        targetSpec.excludeSource = fluid.arrayToHash(fluid.makeArray(sourceSpec.excludeSource || (sourceSpec.includeSource ? "*" : undefined)));
        targetSpec.includeSource = fluid.arrayToHash(fluid.makeArray(sourceSpec.includeSource));
        return targetSpec;
    };

    /** Determines whether the supplied transaction should have changes not propagated into it as a result of being excluded by a
     * condition specification.
     * @param {Transaction} transaction - A local ChangeApplier transaction, with member `fullSources` holding all currently active sources
     * @param {ConditionSpec} spec - A parsed relay condition specification, as returned from `fluid.model.parseRelayCondition`.
     * @return {Boolean} `true` if changes should be excluded from the supplied transaction according to the supplied specification
     */
    fluid.isExcludedChangeSource = function (transaction, spec) {
        // OLD COMMENT: mergeModelListeners initModelEvent fabricates a fake spec that bypasses processing
        // TODO: initModelEvent is gone, mergeModelListeners is now registerMergedModelListeners - is this still relevant?
        if (!spec || !spec.excludeSource) {
            return false;
        }
        var excluded = spec.excludeSource["*"];
        for (var source in transaction.fullSources) {
            if (spec.excludeSource[source]) {
                excluded = true;
            }
            if (spec.includeSource[source]) {
                excluded = false;
            }
        }
        return excluded;
    };

    fluid.model.guardedAdapter = function (transaction, cond, func, args) {
        if (!fluid.isExcludedChangeSource(transaction, cond) && func !== fluid.model.transform.uninvertibleTransform) {
            func.apply(null, args);
        }
    };

    // TODO: This rather crummy function is the only site with a hard use of "path" as String
    fluid.transformToAdapter = function (transform, targetPath) {
        var basedTransform = {};
        basedTransform[targetPath] = transform; // TODO: Faulty with respect to escaping rules
        return function (trans, newValue, sourceSegs, targetSegs, changeRequest) {
            if (changeRequest && changeRequest.type === "DELETE") {
                trans.fireChangeRequest({type: "DELETE", path: targetPath}); // avoid mouse droppings in target document for FLUID-5585
            }
            // TODO: More efficient model that can only run invalidated portion of transform (need to access changeMap of source transaction)
            fluid.model.transformWithRules(newValue, basedTransform, {finalApplier: trans});
        };
    };

    // TODO: sourcePath and targetPath should really be converted to segs to avoid excess work in parseValidModelReference
    fluid.makeTransformPackage = function (componentThat, transform, sourcePath, targetPath, forwardCond, backwardCond, namespace, priority) {
        var that = {
            forwardHolder: {model: transform},
            backwardHolder: {model: null}
        };
        that.generateAdapters = function (trans) {
            // can't commit "half-transaction" or events will fire - violate encapsulation in this way
            that.forwardAdapterImpl = fluid.transformToAdapter(trans ? trans.newHolder.model : that.forwardHolder.model, targetPath);
            if (sourcePath !== null) {
                var inverted = fluid.model.transform.invertConfiguration(transform);
                if (inverted !== fluid.model.transform.uninvertibleTransform) {
                    that.backwardHolder.model = inverted;
                    that.backwardAdapterImpl = fluid.transformToAdapter(that.backwardHolder.model, sourcePath);
                } else {
                    that.backwardAdapterImpl = inverted;
                }
            }
        };
        that.forwardAdapter = function (transaction, newValue) { // create a stable function reference for this possibly changing adapter
            if (newValue === undefined) {
                that.generateAdapters(); // TODO: Quick fix for incorrect scheduling of invalidation/transducing
                // "it so happens" that fluid.registerDirectChangeRelay invokes us with empty newValue in the case of invalidation -> transduction
            }
            fluid.model.guardedAdapter(transaction, forwardCond, that.forwardAdapterImpl, arguments);
        };
        that.forwardAdapter.cond = forwardCond; // Used when parsing graph in init transaction
        // fired from fluid.model.updateRelays via invalidator event
        that.runTransform = function (trans) {
            trans.commit(); // this will reach the special "half-transactional listener" registered in fluid.connectModelRelay,
            // branch with options.targetApplier - by committing the transaction, we update the relay document in bulk and then cause
            // it to execute (via "transducer")
            trans.reset();
        };
        that.forwardApplier = fluid.makeHolderChangeApplier(that.forwardHolder);
        that.forwardApplier.isRelayApplier = true; // special annotation so these can be discovered in the transaction record
        that.invalidator = fluid.makeEventFirer({name: "Invalidator for model relay with applier " + that.forwardApplier.applierId});
        if (sourcePath !== null) {
            // TODO: backwardApplier is unused
            that.backwardApplier = fluid.makeHolderChangeApplier(that.backwardHolder);
            that.backwardAdapter = function (transaction) {
                fluid.model.guardedAdapter(transaction, backwardCond, that.backwardAdapterImpl, arguments);
            };
            that.backwardAdapter.cond = backwardCond;
        }
        that.update = that.invalidator.fire; // necessary so that both routes to fluid.connectModelRelay from here hit the first branch
        var implicitOptions = {
            targetApplier: that.forwardApplier, // this special field identifies us to fluid.connectModelRelay
            update: that.update,
            namespace: namespace,
            priority: priority,
            refCount: 0
        };
        that.forwardHolder.model = fluid.parseImplicitRelay(componentThat, transform, [], implicitOptions);
        that.refCount = implicitOptions.refCount;
        that.namespace = namespace;
        that.priority = priority;
        that.generateAdapters();
        that.invalidator.addListener(that.generateAdapters);
        that.invalidator.addListener(that.runTransform);
        return that;
    };

    fluid.singleTransformToFull = function (singleTransform) {
        var withPath = $.extend(true, {inputPath: ""}, singleTransform);
        return {
            "": {
                transform: withPath
            }
        };
    };

    // Convert old-style "relay conditions" to source includes/excludes as used in model listeners
    fluid.model.relayConditions = {
        initOnly: {includeSource: "init"},
        liveOnly: {excludeSource: "init"},
        never:    {includeSource: []},
        always:   {}
    };

    /** Parse a relay condition specification, e.g. of the form `{includeSource: "init"}` or `never` into a hash representation
     * suitable for rapid querying.
     * @param {String|Object} condition - A relay condition specification, appearing in the section `forward` or `backward` of a
     * relay definition
     * @return {RelayCondition} The parsed condition, holding members `includeSource` and `excludeSource` each with a hash to `true`
     * of referenced sources
     */
    fluid.model.parseRelayCondition = function (condition) {
        if (condition === "initOnly") {
            fluid.log(fluid.logLevel.WARN, "The relay condition \"initOnly\" is deprecated: Please use the form 'includeSource: \"init\"' instead");
        } else if (condition === "liveOnly") {
            fluid.log(fluid.logLevel.WARN, "The relay condition \"liveOnly\" is deprecated: Please use the form 'excludeSource: \"init\"' instead");
        }
        var exclusionRec;
        if (!condition) {
            exclusionRec = {};
        } else if (typeof(condition) === "string") {
            exclusionRec = fluid.model.relayConditions[condition];
            if (!exclusionRec) {
                fluid.fail("Unrecognised model relay condition string \"" + condition + "\": the supported values are \"never\" or a record with members \"includeSource\" and/or \"excludeSource\"");
            }
        } else {
            exclusionRec = condition;
        }
        return fluid.parseSourceExclusionSpec({}, exclusionRec);
    };

    /** Parse a single model relay record as appearing nested within the `modelRelay` block in a model component's
     * options. By various calls to `fluid.connectModelRelay` this will set up the structure operating the live
     * relay during the component#s lifetime.
     * @param {Component} that - The component holding the record, currently instantiating
     * @param {Object} mrrec - The model relay record. This must contain either a member `singleTransform` or `transform` and may also contain
     * members `namespace`, `path`, `priority`, `forward` and `backward`
     * @param {String} key -
     */
    fluid.parseModelRelay = function (that, mrrec, key) {
        var parsedSource = mrrec.source !== undefined ? fluid.parseValidModelReference(that, "modelRelay record member \"source\"", mrrec.source) :
            {path: null, modelSegs: null};
        var parsedTarget = fluid.parseValidModelReference(that, "modelRelay record member \"target\"", mrrec.target);
        var namespace = mrrec.namespace || key;

        var transform = mrrec.singleTransform ? fluid.singleTransformToFull(mrrec.singleTransform) : mrrec.transform;
        if (!transform) {
            fluid.fail("Cannot parse modelRelay record without element \"singleTransform\" or \"transform\":", mrrec);
        }
        var forwardCond = fluid.model.parseRelayCondition(mrrec.forward), backwardCond = fluid.model.parseRelayCondition(mrrec.backward);

        var transformPackage = fluid.makeTransformPackage(that, transform, parsedSource.path, parsedTarget.path, forwardCond, backwardCond, namespace, mrrec.priority);
        if (transformPackage.refCount === 0) { // There were no implicit relay elements found in the relay document - it can be relayed directly
            // Case i): Bind changes emitted from the relay ends to each other, synchronously
            fluid.connectModelRelay(parsedSource.that || that, parsedSource.modelSegs, parsedTarget.that, parsedTarget.modelSegs,
            // Primarily, here, we want to get rid of "update" which is what signals to connectModelRelay that this is a invalidatable relay
                fluid.filterKeys(transformPackage, ["forwardAdapter", "backwardAdapter", "namespace", "priority"]));
        } else {
            if (parsedSource.modelSegs) {
                fluid.fail("Error in model relay definition: If a relay transform has a model dependency, you can not specify a \"source\" entry - please instead enter this as \"input\" in the transform specification. Definition was ", mrrec, " for component ", that);
            }
            // Case ii): Binds changes emitted from the relay document itself onto the relay ends (using the "half-transactional system")
            fluid.connectModelRelay(that, null, parsedTarget.that, parsedTarget.modelSegs, transformPackage);
        }
    };

    /** Traverses a model document written within a component's options, parsing any IoC references looking for
     * i) references to general material, which will be fetched and interpolated now, and ii) "implicit relay" references to the
     * model areas of other components, which will be used to set up live synchronisation between the area in this component where
     * they appear and their target, as well as setting up initial synchronisation to compute the initial contents.
     * This is called in two situations: A) parsing the `model` configuration option for a model component, and B) parsing the
     * `transform` member (perhaps derived from `singleTransform`) of a `modelRelay` block for a model component. It calls itself
     * recursively as it progresses through the model document material with updated `segs`
     * @param {fluid.modelComponent} that - The component holding the model document
     * @param {Any} modelRec - The model document specification to be parsed
     * @param {String[]} segs - The array of string path segments from the root of the entire model document to the point of current parsing
     * @param {Object} options - Configuration options (mutable) governing this parse. This is primarily used to hand as the 5th argument to
     * `fluid.connectModelRelay` for any model references found, and contains members
     *    refCount {Integer} An count incremented for every call to `fluid.connectModelRelay` setting up a synchronizing relay for every
     * reference to model material encountered
     *    priority {String} The unparsed priority member attached to this record, or `first` for a parse of `model` (case A)
     *    namespace {String} [optional] A namespace attached to this transform, if we are parsing a transform
     *    targetApplier {ChangeApplier} [optional] The ChangeApplier for this transform document, if it is a transform, empty otherwise
     *    update {Function} [optional] A function to be called on conclusion of a "half-transaction" where all currently pending updates have been applied
     * to this transform document. This function will update/regenerate the relay transform functions used to relay changes between the transform
     * ends based on the updated document.
     * @return {Any} - The resulting model value.
     */
    fluid.parseImplicitRelay = function (that, modelRec, segs, options) {
        var value;
        if (fluid.isIoCReference(modelRec)) {
            var parsed = fluid.parseValidModelReference(that, "model reference from model (implicit relay)", modelRec, true);
            if (parsed.nonModel) {
                value = fluid.isComponent(parsed.that) ? fluid.getForComponent(parsed.that, parsed.segs) : fluid.getImmediate(parsed.that, parsed.segs);
                if (value instanceof fluid.fetchResources.FetchOne) {
                    that.applier.resourceMap.push({segs: fluid.makeArray(segs), fetchOne: value});
                    // We don't support compositing of resource references since we couldn't apply this if their
                    // value changes
                    return null;
                }
            } else {
                ++options.refCount; // This count is used from within fluid.makeTransformPackage
                fluid.connectModelRelay(that, segs, parsed.that, parsed.modelSegs, options);
            }
        } else if (fluid.isPrimitive(modelRec) || !fluid.isPlainObject(modelRec)) {
            value = modelRec;
        } else if (modelRec.expander && fluid.isPlainObject(modelRec.expander)) {
            value = fluid.expandOptions(modelRec, that);
        } else { // It is a plain Object or Array container
            value = fluid.freshContainer(modelRec);
            fluid.each(modelRec, function (innerValue, key) {
                segs.push(key);
                var innerTrans = fluid.parseImplicitRelay(that, innerValue, segs, options);
                if (innerTrans !== undefined) {
                    value[key] = innerTrans;
                }
                segs.pop();
            });
        }
        return value;
    };


    // Conclude the transaction by firing to all external listeners in priority order
    fluid.model.notifyExternal = function (transRec) {
        var allChanges = transRec ? fluid.values(transRec.externalChanges) : [];
        fluid.sortByPriority(allChanges);
        for (var i = 0; i < allChanges.length; ++i) {
            var change = allChanges[i];
            var targetApplier = change.args[5]; // NOTE: This argument gets here via fluid.model.storeExternalChange from fluid.notifyModelChanges
            if (!targetApplier.destroyed) { // 3rd point of guarding for FLUID-5592
                change.listener.apply(null, change.args);
            }
        }
        fluid.clearLinkCounts(transRec, true); // "options" structures for relayCount are aliased
    };

    fluid.model.commitRelays = function (instantiator, transactionId) {
        var transRec = instantiator.modelTransactions[transactionId];
        fluid.each(transRec, function (transEl) {
        // EXPLAIN: This must commit ALL current transactions, not just those for relays - why?
            if (transEl.transaction) { // some entries are links
                transEl.transaction.commit("relay");
                transEl.transaction.reset();
            }
        });
    };

    // Listens to all invalidation to relays, and reruns/applies them if they have been invalidated
    fluid.model.updateRelays = function (instantiator, transactionId) {
        var transRec = instantiator.modelTransactions[transactionId];
        var updates = 0;
        fluid.sortByPriority(transRec.relays);
        fluid.each(transRec.relays, function (transEl) {
            // TODO: We have a bit of a problem here in that we only process updatable relays by priority - plain relays get to act non-transactionally
            if (transEl.transaction.changeRecord.changes > 0 && transEl.relayCount < 2 && transEl.options.update) {
                transEl.relayCount++;
                fluid.clearLinkCounts(transRec);
                transEl.options.update(transEl.transaction, transRec);
                ++updates;
            }
        });
        return updates;
    };

    fluid.concludeModelTransaction = function (transaction) {
        var instantiator = fluid.globalInstantiator;
        fluid.model.notifyExternal(instantiator.modelTransactions[transaction.id]);
        delete instantiator.modelTransactions[transaction.id];
    };

    /** The main entry point for enlisting a model component in the initial transaction. Positioned as a "fake member"
     * which evalutes to null. Calls `fluid.enlistModelComponent` to register record in treeTransaction.initModelTransaction
     * @param {fluid.modelComponent} that - The `fluid.modelComponent` which is about to initialise
     * @param {Object} optionsModel - Reference into `{that}.options.model`
     * @param {Object} optionsML - Reference into `{that}.options.modelListeners`
     * @param {Object} optionsMR - Reference into `{that}.options.modelRelay`
     * @param {fluid.changeApplier} applier - Reference into `{that}.applier`
     * @return {Null} A dummy `null` value which will initialise the `{that}.modelRelay` member
     */
    fluid.establishModelRelay = function (that, optionsModel, optionsML, optionsMR, applier) {
        var shadow = fluid.shadowForComponent(that);
        if (!shadow.modelRelayEstablished) {
            shadow.modelRelayEstablished = true;
        } else {
            fluid.fail("FLUID-5887 failure: Model relay initialised twice on component", that);
        }

        var enlist = fluid.enlistModelComponent(that);
        fluid.each(optionsMR, function (mrrec, key) {
            for (var i = 0; i < mrrec.length; ++i) {
                fluid.parseModelRelay(that, mrrec[i], key);
            }
        });

        // Note: this particular instance of "refCount" is disused. We only use the count made within fluid.makeTransformPackge
        var initModels = fluid.transform(optionsModel, function (modelRec) {
            return fluid.parseImplicitRelay(that, modelRec, [], {refCount: 0, priority: "first"});
        });
        enlist.initModels = initModels;

        var instantiator = fluid.getInstantiator(that);

        function updateRelays(transaction) {
            while (fluid.model.updateRelays(instantiator, transaction.id) > 0) {} // eslint-disable-line no-empty
        }

        function commitRelays(transaction, applier, code) {
            if (code !== "relay") { // don't commit relays if this commit is already a relay commit
                fluid.model.commitRelays(instantiator, transaction.id);
            }
        }

        function concludeTransaction(transaction, applier, code) {
            if (code !== "relay") {
                fluid.concludeModelTransaction(transaction);
            }
        }

        applier.preCommit.addListener(updateRelays);
        applier.preCommit.addListener(commitRelays);
        applier.postCommit.addListener(concludeTransaction);
        applier.postCommit.addListener(fluid.concludeAnyTransaction);

        return null;
    };

    fluid.destroyLensedComponentSource = function (that, isBoolean) {
        var shadow = fluid.shadowForComponent(that);
        var sourceModelReference = shadow.localRecord.sourceModelReference;
        if (sourceModelReference && !fluid.isDestroyed(sourceModelReference.that)) {
            sourceModelReference.that.applier.change(sourceModelReference.modelSegs, false, isBoolean ? "ADD" : "DELETE");
        }
    };

    fluid.constructLensedComponents = function (shadow, sourcesParsed, dynamicComponentKey) {
        var lightMerge = shadow.lightMergeDynamicComponents[dynamicComponentKey];
        var sources = fluid.getImmediate(shadow.that.model, sourcesParsed.modelSegs);
        var shadowRecord = shadow.modelSourcedDynamicComponents[dynamicComponentKey];
        var localRecordContributor = shadowRecord.localRecordContributor =
            function (localRecord, source, sourceKey) {
                localRecord.sourceModelReference = {
                    that: sourcesParsed.that,
                    modelSegs: sourcesParsed.modelSegs.concat(shadowRecord.isBoolean ? [] : [sourceKey])
                };
            };
        fluid.lightMergeRecords.pushRecord(lightMerge, {
            options: {
                listeners: {
                    afterDestroy: {
                        funcName: "fluid.destroyLensedComponentSource",
                        args: ["{that}", shadowRecord.isBoolean]
                    }
                }
            }
        });
        fluid.registerSourcedDynamicComponentsTriage(shadow.potentia, shadow.that, sources, lightMerge, dynamicComponentKey,
            shadowRecord.isBoolean, localRecordContributor);
    };

    fluid.operateInitialTransactionWorkflow = function (shadows, treeTransaction) {
        var transId = treeTransaction.initModelTransactionId;
        if (!transId) {
            transId = fluid.allocateGuid();
            treeTransaction.initModelTransactionId = transId;
        }
        fluid.tryCatch(function () { // For FLUID-6195 ensure that exceptions during init relay don't leave the framework unusable
            fluid.operateInitialTransaction(treeTransaction.initModelTransaction, transId);
            // Do this afterwards so that model listeners can be fired by concludeComponentInit
            shadows.forEach(function (shadow) {
                var that = shadow.that;
                fluid.registerMergedModelListeners(that, that.options.modelListeners);
                fluid.each(shadow.modelSourcedDynamicComponents, function (componentRecord, key) {
                    fluid.constructLensedComponents(shadow, componentRecord.sourcesParsed, key);
                });
            });
        }, function (e) {
            treeTransaction.initModelTransaction = {};
            treeTransaction.initModelTransactionId = null;
            fluid.clearTransactions();
            throw e;
        }, fluid.identity);
    };

    fluid.enlistModelWorkflow = function (shadows, treeTransaction) {
        shadows.forEach(function (shadow) {
            fluid.getForComponent(shadow.that, "modelRelay"); // invoke fluid.establishModelRelay and enlist each component
        });
        fluid.operateInitialTransactionWorkflow(shadows, treeTransaction);
    };

    fluid.notifyInitModelWorkflow = function (shadow, treeTransaction) {
       // Note that this really has many of the characteristics of a global workflow function, but all the book-keeping
       // is done on our side, and notification needs to occur with respect to the skeleton's incident namespaces, so
       // we use the first call in the transaction as a proxy for all
        if (!shadow.modelComplete) {
            var initModelTransaction = treeTransaction.initModelTransaction;
            var transRec = fluid.getModelTransactionRec(fluid.rootComponent, shadow.initTransactionId);
            var trans = Object.values(initModelTransaction)[0].transaction;
            treeTransaction.initModelTransaction = {};
            treeTransaction.initModelTransactionId = null;
            trans.commit(); // committing one representative transaction will commit them all
            // NB: Don't call concludeTransaction since "init" is not a standard record - this occurs in commitRelays for the corresponding genuine record as usual
            fluid.each(initModelTransaction, function (oneRec) {
                var that = oneRec.that,
                    applier = that.applier;
                trans = transRec[applier.applierId].transaction;
                var listeners = applier.transListeners.sortedListeners;
                var initShadow = fluid.shadowForComponent(that);
                initShadow.modelComplete = true;
                var shadowTrans = initShadow.initTransactionId;
                if (shadowTrans === shadow.initTransactionId) {
                    fluid.notifyModelChanges(listeners, "ADD", trans.oldHolder, fluid.emptyHolder, null, trans, applier, that);
                } else {
                    // TODO: See if we can generate a case where this branch is necessary
                    // fluid.notifyModelChanges(listeners, "ADD", trans.newHolder, trans.oldHolder, null, trans, applier, that);
                }
            });
            fluid.concludeModelTransaction(trans);
        }
    };

    // supported, PUBLIC API grade
    fluid.defaults("fluid.modelComponent", {
        gradeNames: ["fluid.component"],
        workflows: {
            global: {
                enlistModel: {
                    funcName: "fluid.enlistModelWorkflow"
                },
                resolveResourceModel: {
                    funcName: "fluid.identity",
                    priority: "after:enlistModel",
                    waitIO: true
                }
            },
            local: {
                notifyInitModelWorkflow: {
                    funcName: "fluid.notifyInitModelWorkflow",
                    priority: "before:concludeComponentInit"
                }
            }
        },
        members: {
            model: "@expand:fluid.initRelayModel({that}, {that}.modelRelay)",
            applier: "@expand:fluid.makeHolderChangeApplier({that}, {that}.options.changeApplierOptions)",
            modelRelay: "@expand:fluid.establishModelRelay({that}, {that}.options.model, {that}.options.modelListeners, {that}.options.modelRelay, {that}.applier)"
        },
        mergePolicy: {
            model: {
                noexpand: true,
                func: fluid.arrayConcatPolicy // TODO: bug here in case a model consists of an array
            },
            modelListeners: fluid.makeMergeListenersPolicy(fluid.arrayConcatPolicy),
            modelRelay: fluid.makeMergeListenersPolicy(fluid.arrayConcatPolicy, true)
        }
    });

    fluid.modelChangedToChange = function (args) {
        return {
            value: args[0],
            oldValue: args[1],
            path: args[2],
            transaction: args[4]
        };
    };

    // Note - has only one call, from resolveModelListener
    fluid.event.invokeListener = function (listener, args, localRecord, mergeRecord) {
        if (typeof(listener) === "string") {
            listener = fluid.event.resolveListener(listener); // just resolves globals
        }
        return listener.apply(null, args, localRecord, mergeRecord); // can be "false apply" that requires extra context for expansion
    };

    fluid.resolveModelListener = function (that, record) {
        var togo = function () {
            if (fluid.isDestroyed(that)) { // first guarding point to resolve FLUID-5592
                return;
            }
            var change = fluid.modelChangedToChange(arguments);
            var args = arguments;
            var localRecord = {change: change, "arguments": args};
            var mergeRecord = {source: Object.keys(change.transaction.sources)}; // cascade for FLUID-5490
            if (record.args) {
                args = fluid.expandOptions(record.args, that, {}, localRecord);
            }
            fluid.event.invokeListener(record.listener, fluid.makeArray(args), localRecord, mergeRecord);
        };
        fluid.event.impersonateListener(record.listener, togo);
        return togo;
    };

    fluid.registerModelListeners = function (that, record, paths, namespace) {
        var func = fluid.resolveModelListener(that, record);
        fluid.each(record.byTarget, function (parsedArray) {
            var parsed = parsedArray[0]; // that, applier are common across all these elements
            var spec = {
                listener: func, // for initModelEvent
                listenerId: fluid.allocateGuid(), // external declarative listeners may often share listener handle, identify here
                segsArray: fluid.getMembers(parsedArray, "modelSegs"),
                pathArray: fluid.getMembers(parsedArray, "path"),
                includeSource: record.includeSource,
                excludeSource: record.excludeSource,
                priority: fluid.expandOptions(record.priority, that),
                transactional: true
            };
            // update "spec" so that we parse priority information just once
            spec = parsed.applier.modelChanged.addListener(spec, func, namespace, record.softNamespace);

            fluid.recordChangeListener(that, parsed.applier, func, spec.listenerId);
        });
    };

    fluid.registerMergedModelListeners = function (that, listeners) {
        fluid.each(listeners, function (value, key) {
            if (typeof(value) === "string") {
                value = {
                    funcName: value
                };
            }
            // Bypass fluid.event.dispatchListener by means of "standard = false" and enter our custom workflow including expanding "change":
            var records = fluid.event.resolveListenerRecord(value, that, "modelListeners", null, false).records;
            fluid.each(records, function (record) {
                // Aggregate model listeners into groups referring to the same component target.
                // We do this so that a single entry will appear in its modelListeners so that they may
                // be notified just once per transaction, and also displaced by namespace
                record.byTarget = {};
                var paths = fluid.makeArray(record.path === undefined ? key : record.path);
                fluid.each(paths, function (path) {
                    var parsed = fluid.parseValidModelReference(that, "modelListeners entry", path);
                    fluid.pushArray(record.byTarget, parsed.that.id, parsed);
                });
                var namespace = (record.namespace && !record.softNamespace ? record.namespace : null) || (record.path !== undefined ? key : null);
                fluid.registerModelListeners(that, record, paths, namespace);
            });
        });
    };


    /** CHANGE APPLIER **/

    /* Dispatches a list of changes to the supplied applier */
    fluid.fireChanges = function (applier, changes) {
        for (var i = 0; i < changes.length; ++i) {
            applier.fireChangeRequest(changes[i]);
        }
    };

    fluid.model.isChangedPath = function (changeMap, segs) {
        for (var i = 0; i <= segs.length; ++i) {
            if (typeof(changeMap) === "string") {
                return true;
            }
            if (i < segs.length && changeMap) {
                changeMap = changeMap[segs[i]];
            }
        }
        return false;
    };

    fluid.model.setChangedPath = function (options, segs, value) {
        var notePath = function (record) {
            segs.unshift(record);
            fluid.model.setSimple(options, segs, value);
            segs.shift();
        };
        if (!fluid.model.isChangedPath(options.changeMap, segs)) {
            ++options.changes;
            notePath("changeMap");
        }
        if (!fluid.model.isChangedPath(options.deltaMap, segs)) {
            ++options.deltas;
            notePath("deltaMap");
        }
    };

    fluid.model.fetchChangeChildren = function (target, i, segs, source, options) {
        fluid.each(source, function (value, key) {
            segs[i] = key;
            fluid.model.applyChangeStrategy(target, key, i, segs, value, options);
            segs.length = i;
        });
    };

    // Called with two primitives which are compared for equality. This takes account of "floating point slop" to avoid
    // continuing to propagate inverted values as changes
    // TODO: replace with a pluggable implementation
    fluid.model.isSameValue = function (a, b) {
        if (typeof(a) !== "number" || typeof(b) !== "number") {
            return a === b;
        } else {
            // Don't use isNaN because of https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/isNaN#Confusing_special-case_behavior
            if (a === b || a !== a && b !== b) { // Either the same concrete number or both NaN
                return true;
            } else {
                var relError = Math.abs((a - b) / b);
                return relError < 1e-12; // 64-bit floats have approx 16 digits accuracy, this should deal with most reasonable transforms
            }
        }
    };

    fluid.model.applyChangeStrategy = function (target, name, i, segs, source, options) {
        var targetSlot = target[name];
        var sourceCode = fluid.typeCode(source);
        var targetCode = fluid.typeCode(targetSlot);
        var changedValue = fluid.NO_VALUE;
        if (sourceCode === "primitive") {
            if (!fluid.model.isSameValue(targetSlot, source)) {
                changedValue = source;
                ++options.unchanged;
            }
        } else if (targetCode !== sourceCode || sourceCode === "array" && source.length !== targetSlot.length) {
            // RH is not primitive - array or object and mismatching or any array rewrite
            changedValue = fluid.freshContainer(source);
        }
        if (changedValue !== fluid.NO_VALUE) {
            target[name] = changedValue;
            if (options.changeMap) {
                fluid.model.setChangedPath(options, segs, options.inverse ? "DELETE" : "ADD");
            }
        }
        if (sourceCode !== "primitive") {
            fluid.model.fetchChangeChildren(target[name], i + 1, segs, source, options);
        }
    };

    fluid.model.stepTargetAccess = function (target, type, segs, startpos, endpos, options) {
        for (var i = startpos; i < endpos; ++i) {
            if (!target) {
                continue;
            }
            var oldTrunk = target[segs[i]];
            target = fluid.model.traverseWithStrategy(target, segs, i, options[type === "ADD" ? "resolverSetConfig" : "resolverGetConfig"],
                segs.length - i - 1);
            if (oldTrunk !== target && options.changeMap) {
                fluid.model.setChangedPath(options, segs.slice(0, i + 1), "ADD");
            }
        }
        return {root: target, last: segs[endpos]};
    };

    fluid.model.defaultAccessorConfig = function (options) {
        options = options || {};
        options.resolverSetConfig = options.resolverSetConfig || fluid.model.escapedSetConfig;
        options.resolverGetConfig = options.resolverGetConfig || fluid.model.escapedGetConfig;
        return options;
    };

    // Changes: "MERGE" action abolished
    // ADD/DELETE at root can be destructive
    // changes tracked in optional final argument holding "changeMap: {}, changes: 0, unchanged: 0"
    fluid.model.applyHolderChangeRequest = function (holder, request, options) {
        options = fluid.model.defaultAccessorConfig(options);
        options.deltaMap = options.changeMap ? {} : null;
        options.deltas = 0;
        var length = request.segs.length;
        var pen, atRoot = length === 0;
        if (atRoot) {
            pen = {root: holder, last: "model"};
        } else {
            if (!holder.model) {
                holder.model = {};
                fluid.model.setChangedPath(options, [], options.inverse ? "DELETE" : "ADD");
            }
            pen = fluid.model.stepTargetAccess(holder.model, request.type, request.segs, 0, length - 1, options);
        }
        if (request.type === "ADD") {
            var value = request.value;
            var segs = fluid.makeArray(request.segs);
            fluid.model.applyChangeStrategy(pen.root, pen.last, length - 1, segs, value, options, atRoot);
        } else if (request.type === "DELETE") {
            if (pen.root && pen.root[pen.last] !== undefined) {
                delete pen.root[pen.last];
                if (options.changeMap) {
                    fluid.model.setChangedPath(options, request.segs, "DELETE");
                }
            }
        } else {
            fluid.fail("Unrecognised change type of " + request.type);
        }
        return options.deltas ? options.deltaMap : null;
    };

    /** Compare two models for equality using a deep algorithm. It is assumed that both models are JSON-equivalent and do
     * not contain circular links.
     * @param modela The first model to be compared
     * @param modelb The second model to be compared
     * @param {Object} options - If supplied, will receive a map and summary of the change content between the objects. Structure is:
     *     changeMap: {Object/String} An isomorphic map of the object structures to values "ADD" or "DELETE" indicating
     * that values have been added/removed at that location. Note that in the case the object structure differs at the root, <code>changeMap</code> will hold
     * the plain String value "ADD" or "DELETE"
     *     changes: {Integer} Counts the number of changes between the objects - The two objects are identical iff <code>changes === 0</code>.
     *     unchanged: {Integer} Counts the number of leaf (primitive) values at which the two objects are identical. Note that the current implementation will
     * double-count, this summary should be considered indicative rather than precise.
     * @return <code>true</code> if the models are identical
     */
    // TODO: This algorithm is quite inefficient in that both models will be copied once each
    // supported, PUBLIC API function
    fluid.model.diff = function (modela, modelb, options) {
        options = options || {changes: 0, unchanged: 0, changeMap: {}}; // current algorithm can't avoid the expense of changeMap
        var typea = fluid.typeCode(modela);
        var typeb = fluid.typeCode(modelb);
        var togo;
        if (typea === "primitive" && typeb === "primitive") {
            togo = fluid.model.isSameValue(modela, modelb);
        } else if (typea === "primitive" ^ typeb === "primitive") {
            togo = false;
        } else {
            // Apply both forward and reverse changes - if no changes either way, models are identical
            // "ADD" reported in the reverse direction must be accounted as a "DELETE"
            var holdera = {
                model: fluid.copy(modela)
            };
            fluid.model.applyHolderChangeRequest(holdera, {value: modelb, segs: [], type: "ADD"}, options);
            var holderb = {
                model: fluid.copy(modelb)
            };
            options.inverse = true;
            fluid.model.applyHolderChangeRequest(holderb, {value: modela, segs: [], type: "ADD"}, options);
            togo = options.changes === 0;
        }
        if (togo === false && options.changes === 0) { // catch all primitive cases
            options.changes = 1;
            options.changeMap = modelb === undefined ? "DELETE" : "ADD";
        } else if (togo === true && options.unchanged === 0) {
            options.unchanged = 1;
        }
        return togo;
    };

    fluid.outputMatches = function (matches, outSegs, root) {
        fluid.each(root, function (value, key) {
            matches.push(outSegs.concat(key));
        });
    };

    // Here we only support for now very simple expressions which have at most one
    // wildcard which must appear in the final segment
    fluid.matchChanges = function (changeMap, specSegs, newHolder, oldHolder) {
        var newRoot = newHolder.model;
        var oldRoot = oldHolder.model;
        var map = changeMap;
        var outSegs = ["model"];
        var wildcard = false;
        var togo = [];
        for (var i = 0; i < specSegs.length; ++i) {
            var seg = specSegs[i];
            if (seg === "*") {
                if (i === specSegs.length - 1) {
                    wildcard = true;
                } else {
                    fluid.fail("Wildcard specification in modelChanged listener is only supported for the final path segment: " + specSegs.join("."));
                }
            } else {
                outSegs.push(seg);
                map = fluid.isPrimitive(map) ? map : map[seg];
                newRoot = newRoot ? newRoot[seg] : undefined;
                oldRoot = oldRoot ? oldRoot[seg] : undefined;
            }
        }
        if (map) {
            if (wildcard) {
                if (map === "DELETE") {
                    fluid.outputMatches(togo, outSegs, oldRoot);
                } else if (map === "ADD") {
                    fluid.outputMatches(togo, outSegs, newRoot);
                } else {
                    fluid.outputMatches(togo, outSegs, map);
                }
            } else {
                togo.push(outSegs);
            }
        }
        return togo;
    };

    fluid.storeExternalChange = function (transRec, applier, invalidPath, spec, args) {
        var pathString = applier.composeSegments.apply(null, invalidPath);
        var keySegs = [applier.holder.id, spec.listenerId, (spec.wildcard ? pathString : "")];
        var keyString = keySegs.join("|");
        // TODO: We think we probably have a bug in that notifications destined for end of transaction are actually continuously emitted during the transaction
        // No, we don't, becuase "changeMap" is only computed during commit, during the transaction we only compute "deltaMap"
        // These are unbottled in fluid.establishModelRelay's concludeTransaction
        transRec.externalChanges[keyString] = {listener: spec.listener, namespace: spec.namespace, priority: spec.priority, args: args};
    };

    fluid.notifyModelChanges = function (listeners, changeMap, newHolder, oldHolder, changeRequest, transaction, applier, that) {
        if (!listeners) {
            return;
        }
        var transRec = fluid.getModelTransactionRec(that, transaction.id);
        for (var i = 0; i < listeners.length; ++i) {
            var spec = listeners[i];
            var multiplePaths = spec.segsArray.length > 1; // does this spec listen on multiple paths? If so, don't rebase arguments and just report once per transaction
            for (var j = 0; j < spec.segsArray.length; ++j) {
                var invalidPaths = fluid.matchChanges(changeMap, spec.segsArray[j], newHolder, oldHolder);
                // We only have multiple invalidPaths here if there is a wildcard
                for (var k = 0; k < invalidPaths.length; ++k) {
                    if (applier.destroyed) { // 2nd guarding point for FLUID-5592
                        return;
                    }
                    var invalidPath = invalidPaths[k];
                    spec.listener = fluid.event.resolveListener(spec.listener);
                    var args = [multiplePaths ? newHolder.model : fluid.model.getSimple(newHolder, invalidPath),
                                multiplePaths ? oldHolder.model : fluid.model.getSimple(oldHolder, invalidPath),
                                multiplePaths ? [] : invalidPath.slice(1), changeRequest, transaction, applier];
                    // FLUID-5489: Do not notify of null changes which were reported as a result of invalidating a higher path
                    // TODO: We can improve greatly on efficiency by i) reporting a special code from fluid.matchChanges which signals the difference between invalidating a higher and lower path,
                    // ii) improving fluid.model.diff to create fewer intermediate structures and no copies
                    // TODO: The relay invalidation system is broken and must always be notified (branch 1) - since our old/new value detection is based on the wrong (global) timepoints in the transaction here,
                    // rather than the "last received model" by the holder of the transform document
                    if (!spec.isRelay) {
                        var isNull = fluid.model.diff(args[0], args[1]);
                        if (isNull) {
                            continue;
                        }
                        var sourceExcluded = fluid.isExcludedChangeSource(transaction, spec);
                        if (sourceExcluded) {
                            continue;
                        }
                    }
                    // Note that the only reason there may not be a transRec is that we still (barely) support the standalone use of makeHolderChangeApplier
                    if (transRec && !spec.isRelay && spec.transactional) { // bottle up genuine external changes so we can sort and dedupe them later
                        fluid.storeExternalChange(transRec, applier, invalidPath, spec, args);
                    } else {
                        spec.listener.apply(null, args);
                    }
                }
            }
        }
    };

    fluid.bindELMethods = function (applier) {
        applier.parseEL = function (EL) {
            return fluid.model.pathToSegments(EL, applier.options.resolverSetConfig);
        };
        applier.composeSegments = function () {
            return applier.options.resolverSetConfig.parser.compose.apply(null, arguments);
        };
    };

    // A standard "empty model" for the purposes of comparing initial state during the primordial transaction
    fluid.emptyHolder = fluid.freezeRecursive({ model: undefined });

    fluid.preFireChangeRequest = function (applier, changeRequest) {
        if (!changeRequest.type) {
            changeRequest.type = "ADD";
        }
        changeRequest.segs = changeRequest.segs || applier.parseEL(changeRequest.path);
    };

    // Automatically adapts change onto fireChangeRequest
    fluid.bindRequestChange = function (that) {
        that.change = function (path, value, type, source) {
            var changeRequest = {
                path: path,
                value: value,
                type: type,
                source: source
            };
            that.fireChangeRequest(changeRequest);
        };
    };

    // Quick n dirty test to cheaply detect Object versus other JSON types
    fluid.isObjectSimple = function (totest) {
        return Object.prototype.toString.call(totest) === "[object Object]";
    };

    fluid.mergeChangeSources = function (target, globalSources) {
        if (fluid.isObjectSimple(globalSources)) { // TODO: No test for this branch!
            fluid.extend(target, globalSources);
        } else {
            fluid.each(fluid.makeArray(globalSources), function (globalSource) {
                target[globalSource] = true;
            });
        }
    };

    fluid.ChangeApplier = function () {};

    fluid.makeHolderChangeApplier = function (holder, options) {
        options = fluid.model.defaultAccessorConfig(options);
        var applierId = fluid.allocateGuid();
        var that = new fluid.ChangeApplier();
        var name = fluid.isComponent(holder) ? "ChangeApplier for component " + fluid.dumpThat(holder) : "ChangeApplier with id " + applierId;
        $.extend(that, {
            applierId: applierId,
            holder: holder,
            listeners: fluid.makeEventFirer({name: "Internal change listeners for " + name}),
            transListeners: fluid.makeEventFirer({name: "External change listeners for " + name}),
            options: options,
            modelChanged: {},
            resourceMap: [], // list of records containing {segs: segs, fetchOne: fluid.fetchResources.FetchOne}
            earlyModelResolved: fluid.makeEventFirer({name: "earlyModelResolved event for " + name}),
            preCommit: fluid.makeEventFirer({name: "preCommit event for " + name}),
            postCommit: fluid.makeEventFirer({name: "postCommit event for " + name})
        });
        that.destroy = function () {
            that.preCommit.destroy();
            that.postCommit.destroy();
            that.destroyed = true;
        };
        that.modelChanged.addListener = function (spec, listener, namespace, softNamespace) {
            if (typeof(spec) === "string") {
                spec = {
                    path: spec
                };
            } else {
                spec = fluid.copy(spec);
            }
            spec.listenerId = spec.listenerId || fluid.allocateGuid(); // FLUID-5151: don't use identifyListener since event.addListener will use this as a namespace
            spec.namespace = namespace;
            spec.softNamespace = softNamespace;
            if (typeof(listener) === "string") { // The reason for "globalName" is so that listener names can be resolved on first use and not on registration
                listener = {globalName: listener};
            }
            spec.listener = listener;
            if (spec.transactional !== false) {
                spec.transactional = true;
            }
            if (!spec.segsArray) { // It's a manual registration
                if (spec.path !== undefined) {
                    spec.segs = spec.segs || that.parseEL(spec.path);
                }
                spec.segsArray = [spec.segs];
            }
            if (!spec.isRelay) {
                // This acts for listeners registered externally. For relays, the exclusion spec is stored in "cond"
                fluid.parseSourceExclusionSpec(spec, spec);
                spec.wildcard = fluid.accumulate(fluid.transform(spec.segsArray, function (segs) {
                    return fluid.contains(segs, "*");
                }), fluid.add, 0);
                if (spec.wildcard && spec.segsArray.length > 1) {
                    fluid.fail("Error in model listener specification ", spec, " - you may not supply a wildcard pattern as one of a set of multiple paths to be matched");
                }
            }
            var firer = that[spec.transactional ? "transListeners" : "listeners"];
            firer.addListener(spec);
            return spec; // return is used in registerModelListeners
        };
        that.modelChanged.removeListener = function (listener) {
            that.listeners.removeListener(listener);
            that.transListeners.removeListener(listener);
        };
        that.fireChangeRequest = function (changeRequest) {
            var initTransaction = fluid.findInitModelTransaction(holder);
            if (initTransaction) {
                initTransaction.transaction.fireChangeRequest(changeRequest);
            } else {
                var ation = that.initiate("local", changeRequest.source);
                ation.fireChangeRequest(changeRequest);
                ation.commit();
            }
        };

        /**
         * Initiate a fresh transaction on this applier, perhaps coordinated with other transactions sharing the same id across the component tree
         * Arguments all optional
         * @param {String} localSource  - "local", "relay" or null Local source identifiers only good for transaction's representative on this applier
         * @param {String|Array|Object} globalSources - Global source identifiers common across this transaction, expressed as a single string, an array of strings, or an object with a "toString" method.
         * @param {String} transactionId - Global transaction id to enlist with.
         * @return {Object} - The component initiating the change.
         */
        that.initiate = function (localSource, globalSources, transactionId) {
            localSource = globalSources === "init" ? null : (localSource || "local"); // supported values for localSource are "local" and "relay" - globalSource of "init" defeats defaulting of localSource to "local"
            // defeatPost is supplied for all non-top-level transactions as well as init transactions, which commit separately in notifyInitModelWorkflow
            var defeatPost = localSource === "relay" || globalSources === "init";
            var trans = {
                instanceId: fluid.allocateGuid(), // for debugging only - the representative of this transction on this applier
                id: transactionId || fluid.allocateGuid(), // The global transaction id across all appliers - allocate here if this is the starting point
                changeRecord: {
                    resolverSetConfig: options.resolverSetConfig, // here to act as "options" in applyHolderChangeRequest
                    resolverGetConfig: options.resolverGetConfig
                },
                /** Method for internal use only - we "reset" a transaction after we have committed changes to relay documents and are ready for
                 * a fresh round of propagation.
                 */
                reset: function () {
                    trans.oldHolder = holder;
                    trans.newHolder = { model: fluid.copy(holder.model) };
                    trans.changeRecord.changes = 0;
                    trans.changeRecord.unchanged = 0; // just for type consistency - we don't use these values in the ChangeApplier
                    trans.changeRecord.changeMap = {};
                },
                /** Commit this transaction. The argument `code` is for internal use only, and takes the value "relay" when
                 * we are committing changes to relay documents partway through a full transaction.
                 * @param {String} [code] - Optional, internal use argument indicating the purpose of the commit. Can take the value "relay".
                 */
                commit: function (code) {
                    that.preCommit.fire(trans, that, code);
                    if (trans.changeRecord.changes > 0) {
                        var oldHolder = {model: holder.model};
                        holder.model = trans.newHolder.model;
                        fluid.notifyModelChanges(that.transListeners.sortedListeners, trans.changeRecord.changeMap, holder, oldHolder, null, trans, that, holder);
                    }
                    if (!defeatPost) {
                        that.postCommit.fire(trans, that, code);
                    }
                },
                fireChangeRequest: function (changeRequest) {
                    fluid.preFireChangeRequest(that, changeRequest);
                    changeRequest.transactionId = trans.id;
                    var deltaMap = fluid.model.applyHolderChangeRequest(trans.newHolder, changeRequest, trans.changeRecord);
                    fluid.notifyModelChanges(that.listeners.sortedListeners, deltaMap, trans.newHolder, holder, changeRequest, trans, that, holder);
                },
                hasChangeSource: function (source) {
                    return trans.fullSources[source];
                }
            };
            var transRec = fluid.getModelTransactionRec(holder, trans.id);
            if (transRec) {
                fluid.mergeChangeSources(transRec.sources, globalSources);
                trans.sources = transRec.sources;
                trans.fullSources = Object.create(transRec.sources);
                if (localSource) {
                    trans.fullSources[localSource] = true;
                }
            }
            trans.reset();
            fluid.bindRequestChange(trans);
            return trans;
        };

        fluid.bindRequestChange(that);
        fluid.bindELMethods(that);
        return that;
    };

    /**
     * Calculates the changes between the model values 'value' and 'oldValue' and returns an array of change records.
     * The optional argument 'changePathPrefix' is prepended to the change path of each record (this is useful for
     * generating change records to be applied at a non-root path in a model). The returned array of
     * change records may be used with fluid.fireChanges().
     *
     * @param {Any} value - Model value to compare.
     * @param {Any} oldValue - Model value to compare.
     * @param {String|Array} [changePathPrefix] - [optional] Path prefix to prepend to change record paths, expressed as a string or an array of string segments.
     * @return {Array} - An array of change record objects.
     */
    fluid.modelPairToChanges = function (value, oldValue, changePathPrefix) {
        changePathPrefix = changePathPrefix || "";

        // Calculate the diff between value and oldValue
        var diffOptions = {changes: 0, unchanged: 0, changeMap: {}};
        fluid.model.diff(oldValue, value, diffOptions);

        var changes = [];

        // Recursively process the diff to generate an array of change
        // records, stored in 'changes'
        fluid.modelPairToChangesImpl(value,
            fluid.pathUtil.parseEL(changePathPrefix),
            diffOptions.changeMap, [], changes);

        return changes;
    };

    /**
     * This function implements recursive processing for fluid.modelPairToChanges(). It builds an array of change
     * records, accumulated in the 'changes' argument, by walking the 'changeMap' structure and 'value' model value.
     * As we walk down the model, our path from the root of the model is recorded in
     * the 'changeSegs' argument.
     *
     * @param {Any} value - Model value
     * @param {String[]} changePathPrefixSegs - Path prefix to prepend to change record paths, expressed as an array of string segments.
     * @param {String|Object} changeMap - The changeMap structure from fluid.model.diff().
     * @param {String[]} changeSegs - Our path relative to the model value root, expressed as an array of string segments.
     * @param {Object[]} changes - The accumulated change record objects.
     */
    fluid.modelPairToChangesImpl = function (value, changePathPrefixSegs, changeMap, changeSegs, changes) {
        if (changeMap === "ADD") {
            // The whole model value is new
            changes.push({
                path: changePathPrefixSegs,
                value: value,
                type: "ADD"
            });
        } else if (changeMap === "DELETE") {
            // The whole model value has been deleted
            changes.push({
                path: changePathPrefixSegs,
                value: null,
                type: "DELETE"
            });
        } else if (fluid.isPlainObject(changeMap, true)) {
            // Something within the model value has changed
            fluid.each(changeMap, function (change, seg) {
                var currentChangeSegs = changeSegs.concat([seg]);
                if (change === "ADD") {
                    changes.push({
                        path: changePathPrefixSegs.concat(currentChangeSegs),
                        value: fluid.get(value, currentChangeSegs),
                        type: "ADD"
                    });
                } else if (change === "DELETE") {
                    changes.push({
                        path: changePathPrefixSegs.concat(currentChangeSegs),
                        value: null,
                        type: "DELETE"
                    });
                } else if (fluid.isPlainObject(change, true)) {
                    // Recurse down the tree of changes
                    fluid.modelPairToChangesImpl(value, changePathPrefixSegs,
                        change, currentChangeSegs, changes);
                }
            });
        }
    };

})(jQuery, fluid_3_0_0);
;/*
 * Bergson Clocks
 * http://github.com/colinbdclark/bergson
 *
 * Copyright 2015, Colin Clark
 * Dual licensed under the MIT and GPL Version 2 licenses.
 */
/*global require, performance*/
var fluid = fluid || require("infusion"),
    berg = fluid.registerNamespace("berg");

(function () {
    "use strict";

    /**
     * Clock is the base grade for all Clocks.
     */
    fluid.defaults("berg.clock", {
        gradeNames: ["fluid.modelComponent"],

        freq: 1, // Ticks per second.

        members: {
            /**
             * The clock's current time, in seconds.
             */
            time: 0,

            /**
             * The number of times per second that this clock will tick.
             * This value is not guaranteed to be precise for all clocks.
             */
            freq: "{that}.options.freq",

            /**
             * The duration, in seconds, between ticks.
             * This value is not guaranteed to be precise for all clocks.
             */
            tickDuration: {
                expander: {
                    funcName: "berg.clock.calcTickDuration",
                    args: "{that}.freq"
                }
            }
        },

        model: {
            isPlaying: false
        },

        invokers: {
            start: "{that}.events.onStart.fire()",
            tick: "fluid.notImplemented()",
            stop: "{that}.events.onStop.fire()"
        },

        events: {
            onStart: null,
            onTick: null,
            onStop: null
        },

        listeners: {
            "onStart.updateState": {
                changePath: "isPlaying",
                value: true
            },

            "onStop.updateState": {
                changePath: "isPlaying",
                value: false
            },

            "onDestroy.stop": "{that}.stop()"
        }
    });

    berg.clock.calcTickDuration = function (freq) {
        return 1.0 / freq;
    };


    /**
     * Offline Clock
     *
     * An Offline Clock tracks time relatively
     * (i.e. without reference to a "real" source of time
     * such as the system clock).
     *
     * This clock can be driven manually
     * (perhaps by an offline frame or audio sample renderer)
     * by invoking its tick() method.
     */
    fluid.defaults("berg.clock.offline", {
        gradeNames: ["berg.clock"],

        invokers: {
            tick: {
                funcName: "berg.clock.offline.tick",
                args: ["{that}"]
            }
        }
    });

    berg.clock.offline.tick = function (that) {
        that.time = that.time + that.tickDuration;
        that.events.onTick.fire(that.time, that.freq);
    };


    /**
     * A Realtime Clock tracks time based on actual system time
     * (i.e. performance.now)
     */
    fluid.defaults("berg.clock.realtime", {
        gradeNames: ["berg.clock"],

        members: {
            time: "@expand:berg.clock.realtime.now()"
        },

        invokers: {
            tick: {
                funcName: "berg.clock.realtime.tick",
                args: ["{that}"]
            }
        }
    });

    // TODO: Remove this in favour of a direct call
    // to performance.now() once Safari supports it
    // in Web Workers.
    berg.clock.realtime.now = function () {
        return performance.now() / 1000;
    };

    // Terrible hack to workaround Safari's lack of
    // support for performance.now().
    if (typeof performance === "undefined") {
        berg.clock.realtime.now = function () {
            return Date.now() / 1000;
        };
    }

    berg.clock.realtime.tick = function (that) {
        that.time = berg.clock.realtime.now();
        that.events.onTick.fire(that.time, that.freq);
    };

})();
;/* Bergson Priority Queue
 *
 * Based on Marijn Haverbeke's Binary Heap,
 * published in the 1st edition of Eloquent JavaScript
 * http://eloquentjavascript.net/1st_edition/appendix2.html
 *
 * License: Creative Commons Attribution 3.0 Unported
 * Copyright 2013 Marijn Haverbeke
 * Copyright 2015 Colin Clark
 */
/*global require*/
var fluid = fluid || require("infusion"),
    berg = fluid.registerNamespace("berg");

(function () {
    "use strict";

    fluid.registerNamespace("berg");

    /**
     * Priority Queue
     *
     * Stores elements sorted by their order of priority.
     * This implementation uses a binary heap algorithm in order to
     * efficiently keep items sorted.
     *
     * @return the new queue instance
     */
    berg.priorityQueue = function () {
        var that = {
            items: []
        };

        /**
         * Adds a new item to the queue.
         *
         * @param the item to add
         */
        that.push = function (item) {
            if (!item) {
                return;
            }

            if (item.priority === undefined) {
                throw new Error("An item without a priority cannot be added to the queue.");
            }

            // Add the new element to the end of the array.
            that.items.push(item);
            // Allow it to bubble up.
            that.bubbleUp(that.items.length - 1);
        };

        /**
         * Returns the highest-priority element from the queue.
         * This method will not remove the item from the queue.
         *
         * @return the highest-priority element
         */
        that.peek = function () {
            return that.items[0];
        };

        /**
         * Removes the highest-priority element from the queue and returns it.
         *
         * @return the highest-priority element in the queue
         */
        that.pop = function () {
            // Store the first element so we can return it later.
            var result = that.items[0],
                end = that.items.pop();

            // If there are any elements left, put the end element at the
            // start, and let it sink down.
            if (that.items.length > 0) {
                that.items[0] = end;
                that.sinkDown(0);
            }

            return result;
        };

        /**
         * Removes the specified item from the queue.
         *
         * @param item the item to remove
         */
        that.remove = function (item) {
            var len = that.items.length;
            // To remove a value, we must search through the array to find it.
            for (var i = 0; i < len; i++) {
                if (that.items[i] !== item) {
                    continue;
                }
                // When it is found, the process seen in 'pop' is repeated
                // to fill up the hole.
                var end = that.items.pop();
                // If the element we popped was the one we needed to remove,
                // we're done.
                if (i === len - 1) {
                    break;
                }
                // Otherwise, we replace the removed element with the popped
                // one, and allow it to float up or sink down as appropriate.
                that.items[i] = end;
                that.bubbleUp(i);
                that.sinkDown(i);

                break;
            }
        };

        /**
         * Returns the number of items in the queue.
         *
         * @return the number of items
         */
        that.size = function () {
            return that.items.length;
        };

        /**
         * Clears all items from the queue.
         */
        that.clear = function () {
            that.items.length = 0;
        };

        // Unsupported, non-API method.
        that.bubbleUp = function (n) {
            // Fetch the element that has to be moved.
            var item = that.items[n];

            // When at 0, an element can not go up any further.
            while (n > 0) {
                // Compute the parent element's index, and fetch it.
                var parentN = (n - 1) >> 1,
                    parent = that.items[parentN];
                // If the parent has a lesser score, things are in order and we
                // are done.
                if (parent.priority <= item.priority) {
                    break;
                }

                // Otherwise, swap the parent with the current element and
                // continue.
                that.items[parentN] = item;
                that.items[n] = parent;
                n = parentN;
            }
        };

        // Unsupported, non-API method.
        that.sinkDown = function (n) {
            // Look up the target element and its score.
            var length = that.items.length,
                item = that.items[n],
                child1;

            while (true) {
                // Compute the indices of the child elements.
                var child2N = (n + 1) * 2,
                    child1N = child2N - 1,
                    swap = null; // The new position of the item, if any.

                // If the first child exists (is inside the array)...
                if (child1N < length) {
                    // Look it up and compute its score.
                    child1 = that.items[child1N];

                    // If the score is less than our element's, we need to swap.
                    if (child1.priority < item.priority) {
                        swap = child1N;
                    }
                }

                // Do the same checks for the other child.
                if (child2N < length) {
                    var child2 = that.items[child2N],
                        right = swap === null ? item : child1;

                    if (child2.priority < right.priority) {
                        swap = child2N;
                    }
                }

                // No need to swap further, we are done.
                if (swap === null) {
                    break;
                }

                // Otherwise, swap and continue.
                that.items[n] = that.items[swap];
                that.items[swap] = item;
                n = swap;
            }
        };

        return that;
    };
})();
;/*
 * Bergson postMessage Components
 * http://github.com/colinbdclark/bergson
 *
 * Copyright 2015, Colin Clark
 * Dual licensed under the MIT and GPL Version 2 licenses.
 */
/*global require, self*/
var fluid = fluid || require("infusion"),
    berg = fluid.registerNamespace("berg");

(function () {
    "use strict";

    // A function that returns "self",
    // in order to prevent Infusion from chewing it.
    // TODO: Will a mergePolicy address this?
    berg.getGlobalSelf = function () {
        return self;
    };

    fluid.defaults("berg.postMessageSender", {
        gradeNames: ["fluid.component"],

        members: {
            messageTarget: "@expand:berg.getGlobalSelf()"
        },

        invokers: {
            postMessage: "berg.postMessageSender.postMessage({arguments}.0, {arguments}.1, {that}.messageTarget)"
        }
    });

    berg.postMessageSender.postMessage = function (type, args, messageTarget) {
        if (typeof type !== "string") {
            throw new Error("Can't post a message without a message type.");
        }

        var message = {
            type: type,
            args: args
        };

        messageTarget.postMessage(message);
    };


    fluid.defaults("berg.postMessageListener", {
        gradeNames: ["fluid.component"],

        members: {
            messageSource: "@expand:berg.getGlobalSelf()"
        },

        events: {
            onError: null
        },

        listeners: {
            onCreate: [
                "berg.postMessageListener.bind({that})"
            ],

            onError: [
                {
                    namespace: "failOnError",
                    funcName: "fluid.fail"
                }
            ]
        }
    });

    berg.postMessageListener.bind = function (that) {
        that.messageSource.addEventListener("message", function (e) {
            var msg = e.data;

            if (!msg.type) {
                that.events.onError.fire("Received a remote message without a type. " +
                    fluid.prettyPrintJSON(msg));
            }

            if (msg.type === "create") {
                // Work around a bug in Safari where stopPropagation()
                // doesn't seem to work in a Worker postMessage listener.
                return;
            }

            var invoker = that[msg.type];
            if (!that.options.invokers[msg.type] || !invoker) {
                that.events.onError.fire("Received a message of type " + msg.type +
                    ", which did not resolve to a component invoker. Invokers: " +
                    fluid.prettyPrintJSON(that.options.invokers));
            }

            var args = fluid.makeArray(msg.args);
            invoker.apply(null, args);
        }, false);
    };
})();
;/*
 * Bergson Scheduler
 * http://github.com/colinbdclark/bergson
 *
 * Copyright 2015, Colin Clark
 * Dual licensed under the MIT and GPL Version 2 licenses.
 */
/*global require*/
var fluid = fluid || require("infusion"),
    berg = fluid.registerNamespace("berg");

(function () {
    "use strict";

    /**
     * Scheduler
     *
     * Responsible for scheduling "score event specifications"
     * at defined moments in time.
     *
     * Schedulers are typically driven by a Clock instance.
     *
     * Bergson provides two primary scheduling primitives:
     *  1. "once", which will schedule a one-time event
     *  2. "repeat", which schedules a repeating event
     *
     * Score Event Specifications:
     *
     * One-time events:
     *    {
     *        type: "once",
     *
     *        // a future time in seconds when the callback should be invoked
     *        time: 2,
     *
     *        // a function to invoke at the specified time
     *        callback: function (time, this) {}
     *    }
     *
     * Repeating events:
     *    {
     *        type: "repeat",
     *
     *        // The frequency, in Hz, at which to repeat
     *        freq: 5,
     *
     *        // A future time in seconds at which to start repeating. Defaults to 0.
     *        time: 2,
     *
     *        // A future time in seconds at which to stop. Defaults to Infinity
     *        //(i.e. never stop)
     *        end: 20,
     *
     *        // A function to invoke repeatedly.
     *        callback: callback
     *    }
     *
     * Note: the Bergson scheduler operates a simple "rounding"
     * quantization scheme for changes that are finer-grained
     * than the resolution of its clock. So, for example, if the
     * clock is running at a freq of 1 tick/second, an event scheduled
     * at time 1.5 seconds or less will be invoked at the 1 second tick, while
     * events scheduled at a time greater than half a tick
     * will be invoked at the 2 second tick.
     *
     * The order of events scheduled for the same clock time is indeterminate.
     *
     */
    fluid.defaults("berg.scheduler", {
        gradeNames: ["fluid.modelComponent"],

        members: {
            queue: "@expand:berg.priorityQueue()",

            // By default, we schedule ahead by half a tick's duration.
            lookahead: "@expand:berg.scheduler.calcLookahead({clock})"
        },

        model: {
            timeScale: 1.0
        },

        components: {
            clock: { // Should be supplied by the user.
                type: "berg.clock.offline"
            }
        },

        invokers: {
            /**
             * Starts this scheduler's clock.
             */
            start: "{that}.events.onStart.fire()",

            /**
             * Stops this scheduler's clock.
             */
            stop: "{that}.events.onStop.fire()",

            /**
             * Causes the scheduler to evaluate its
             * queue of scheduled callback and fire those that
             * are appropriate for the current clock time.
             *
             * This function is invoked automatically when the
             * scheduler's clock fires its onTick event.
             *
             * @param {Number} now - the current clock time, in seconds
             */
            tick: "berg.scheduler.tick({arguments}.0, {that})",

            /**
             * Schedules one or more score event specifications.
             *
             * @param {Object||Array} scoreSpecs - the score event specifications to schedule
             */
            schedule: "berg.scheduler.schedule({arguments}.0, {that})",

            /**
             * Schedules a callback to be fired once at the specified time.
             *
             * @param {Number} time - the time from now, in seconds, to schedule the callback
             * @param {Function} callback - the callback to schedule
             */
            once: "berg.scheduler.once({arguments}.0, {arguments}.1, {that})",

            /**
             * Schedules a callback to be fired repeatedly at the specified frequency.
             *
             * @param {Number} freq - the frequency (per second) to repeat at
             * @param {Function} callback - the callback to schedule
             * @param {Number} time - the time (in seconds) to start repeating at
             * @param {Number} end - the time (in seconds) to stop repeating at; this value is inclusive
             */
            repeat: {
                funcName: "berg.scheduler.repeat",
                args: [
                    "{arguments}.0",
                    "{arguments}.1",
                    "{arguments}.2",
                    "{arguments}.3",
                    "{that}"
                ]
            },

            /**
             * Clears a scheduled event,
             * causing it not to be evaluated by this scheduler
             * if it hasn't already fired or is repeating.
             *
             * @param {Object} eventSpec - the event specification to clear
             */
            clear: "{that}.queue.remove({arguments}.0)",

            /**
             * Clears all scheduled events.
             */
            clearAll: "{that}.queue.clear()",

            /**
             * Scales the scheduled time of all currently and future events.
             *
             * @param {Number} value - the timeScale value (default is 1.0)
             */
            setTimeScale: {
                changePath: "timeScale",
                value: "{arguments}.0"
            },

            // Unsupported, non-API function.
            scheduleEvent: {
                funcName: "berg.scheduler.scheduleEvent",
                args: ["{arguments}.0", "{that}"]
            },

            // Unsupported, non-API function.
            invokeCallback: {
                funcName: "berg.scheduler.invokeCallback",
                args: ["{arguments}.0", "{arguments}.1"]
            }
        },

        modelListeners: {
            timeScale: {
                funcName: "berg.scheduler.scaleEventTimes",
                args: ["{that}.queue", "{change}.value"],
                excludeSource: "init"
            }
        },

        events: {
            onStart: null,
            onStop: null
        },

        listeners: {
            "onStart.startClock": "{clock}.start()",

            "{clock}.events.onTick": {
                func: "{scheduler}.tick"
            },

            "onStop.stopClock": "{clock}.stop()"
        }
    });

    berg.scheduler.calcLookahead = function (clock) {
        return clock.tickDuration / 2;
    };

    // Unsupported, non-API function.
    berg.scheduler.calcPriority = function (baseTime, timeOffset, timeScale) {
        return baseTime + (timeOffset * timeScale);
    };

    // Unsupported, non-API function.
    berg.scheduler.scaleEventTimes = function (queue, timeScale) {
        for (var i = 0; i < queue.items.length; i++) {
            var item = queue.items[i];
            item.priority = berg.scheduler.calcPriority(item.scheduledAt, item.time, timeScale);
        }
    };

    // Unsupported, non-API function.
    berg.scheduler.expandRepeatingEventSpec = function (now, eventSpec) {
        if (typeof eventSpec.time !== "number") {
            eventSpec.time = 0;
        }

        if (typeof eventSpec.interval !== "number") {
            eventSpec.interval = 1.0 / eventSpec.freq;
        }

        eventSpec.end = typeof eventSpec.end !== "number" ?
            Infinity : eventSpec.end + now;
    };

    // Unsupported, non-API function.
    berg.scheduler.validateEventSpec = function (eventSpec) {
        // TODO: Provide a means to perform implementation-specific validation.
        if (eventSpec.type === "repeat") {
            if (typeof eventSpec.freq !== "number" && typeof eventSpec.interval !== "number") {
                throw new Error("No freq or interval was specified for a repeating event: " + fluid.prettyPrintJSON(eventSpec));
            }
        }

        if (typeof eventSpec.time !== "number") {
            throw new Error("No time was specified for scheduled event: " +
                fluid.prettyPrintJSON(eventSpec));
        }
    };

    berg.scheduler.invokeCallback = function (now, scoreEvent) {
        scoreEvent.callback(now, scoreEvent);
    };

    // Unsupported, non-API function.
    berg.scheduler.evaluateScoreEvent = function (now, scoreEvent, that) {
        that.invokeCallback(now, scoreEvent);

        // If it's a repeating event, queue it back up.
        if (scoreEvent.type === "repeat" && scoreEvent.end > now) {
            scoreEvent.priority = berg.scheduler.calcPriority(now, scoreEvent.interval, that.model.timeScale);
            that.queue.push(scoreEvent);
        }
    };

    berg.scheduler.expandEventSpec = function (eventSpec) {
        // TODO: Should we warn on omitted type?
        if (!eventSpec.type) {
            eventSpec.type = "once";
        }

        // Ensure all event specs have IDs (for debugging and complex scheduling cases).
        if (!eventSpec.id) {
            eventSpec.id = fluid.allocateGuid();
        }
    };

    // Unsupported, non-API function.
    berg.scheduler.scheduleEvent = function (eventSpec, that) {
        var now = that.clock.time,
            timeScale = that.model.timeScale;

        berg.scheduler.expandEventSpec(eventSpec);
        if (eventSpec.type === "repeat") {
            berg.scheduler.expandRepeatingEventSpec(now, eventSpec);
        }

        if (typeof eventSpec.scheduledAt !== "number") {
            eventSpec.scheduledAt = now;
        }

        // TODO: Everything below is wrong in the case that the clock hasn't event started ticking yet.
        // In that case, we need to defer the "concretizing"
        // of time that references to "now" will cause
        // until the clock actually starts ticking.
        // So (I think) everything that gets scheduled prior
        // to the clock starting should go into a list to be
        // processed at the moment when time actually starts.
        berg.scheduler.validateEventSpec(eventSpec);
        eventSpec.priority = berg.scheduler.calcPriority(now, eventSpec.time, timeScale);

        if (eventSpec.priority <= now) {
            berg.scheduler.evaluateScoreEvent(now, eventSpec, that);
        } else {
            that.queue.push(eventSpec);
        }

        return eventSpec;
    };

    // Unsupported, non-API function.
    berg.scheduler.scheduleEvents = function (eventSpecs, that) {
        eventSpecs.forEach(function (eventSpec) {
            that.scheduleEvent(eventSpec);
        });

        return eventSpecs;
    };

    berg.scheduler.schedule = function (eventSpec, that) {
        return fluid.isArrayable(eventSpec) ?
            berg.scheduler.scheduleEvents(eventSpec, that) :
            that.scheduleEvent(eventSpec);
    };

    berg.scheduler.once = function (time, callback, that) {
        var eventSpec = {
            type: "once",
            time: time,
            callback: callback
        };

        return that.scheduleEvent(eventSpec);
    };

    berg.scheduler.repeat = function (freq, callback, time, end, that) {
        var eventSpec = {
            type: "repeat",
            freq: freq,
            time: time,
            end: end,
            callback: callback
        };

        return that.scheduleEvent(eventSpec);
    };

    berg.scheduler.tick = function (now, that) {
        var next = that.queue.peek();

        // Check to see if this event should fire now
        // (or should have fired earlier!)
        while (next && next.priority <= now + that.lookahead) {
            // Take it out of the queue and invoke its callback.
            that.queue.pop();
            berg.scheduler.evaluateScoreEvent(now, next, that);
            next = that.queue.peek();
        }
    };
})();
;/*
 * Bergson Worker-based Scheduler
 * http://github.com/colinbdclark/bergson
 *
 * Copyright 2015, Colin Clark
 * Dual licensed under the MIT and GPL Version 2 licenses.
 */
/*global require*/
var fluid = fluid || require("infusion"),
    berg = fluid.registerNamespace("berg");

(function () {
    "use strict";

    /**
     * A Scheduler that runs in a Web Worker or other environment
     * where it delegates callback invocation to an out-of-thread proxy
     * using postMessage().
     */
    fluid.defaults("berg.scheduler.postMessage", {
        gradeNames: [
            "berg.postMessageListener",
            "berg.postMessageSender",
            "berg.scheduler"
        ],

        invokers: {
            invokeCallback: {
                funcName: "berg.scheduler.postMessage.post",
                args: ["invokeCallback", ["{arguments}.0", "{arguments}.1"], "{that}"]
            }
        }
    });

    // TODO: Apparent Infusion options merging bug.
    // Try with compact invoker syntax or "func",
    // and it will fail due to creating a merged invoker record
    // containing both "funcName" and "func".
    berg.scheduler.postMessage.post = function (type, args, that) {
        that.postMessage(type, args);
    };

    /**
     * A Proxy Scheduler that communicates with  a
     * Web Worker-based PostMessageScheduler via postMessage.
     *
     * The Proxy Scheduler is responsible for maintaining a map
     * of functions by id so that they can be invoked in the current thread.
     */
    fluid.defaults("berg.scheduler.workerProxy", {
        gradeNames: [
            "berg.scheduler",
            "berg.postMessageListener",
            "berg.postMessageSender"
        ],

        scriptPath: "../../dist/bergson-all-worker.js",

        remoteSchedulerOptions: {
            components: {
                clock: {
                    type: "berg.clock.setInterval",
                    options: {
                        freq: 1 / 100 // Tick every 10 ms by default.
                    }
                }
            }
        },

        members: {
            eventSpecMap: {},
            worker: "@expand:berg.scheduler.workerProxy.createWorker({that}.options.scriptPath)",
            messageTarget: "{that}.worker",
            messageSource: "{that}.worker"
        },

        components: {
            clock: {
                type: "berg.clock.offline" // The real clock is in the other universe.
            }
        },

        invokers: {
            start: "{that}.postMessage(start)",
            stop: "{that}.postMessage(stop)",
            tick: "fluid.identity()",
            invokeCallback: "berg.scheduler.workerProxy.invokeCallback({arguments}.0, {arguments}.1, {that})",
            scheduleEvent: "berg.scheduler.workerProxy.scheduleEvent({arguments}.0, {that})",
            clear: "{that}.postMessage(clear, {arguments}.0)",
            clearAll: "{that}.postMessage(clearAll)",
            setTimeScale: "{that}.postMessage(setTimeScale, {arguments}.0)"
        },

        listeners: {
            "onCreate.postSchedulerOptions": {
                func: "{that}.postMessage",
                args: [
                    "create",
                    [
                        "berg.scheduler.postMessage",
                        "{that}.options.remoteSchedulerOptions"
                    ]
                ]
            },

            "onDestroy.terminateWorker": {
                this: "{that}.worker",
                method: "terminate"
            }
        }
    });

    berg.scheduler.workerProxy.createWorker = function (scriptPath) {
        return new Worker(scriptPath);
    };

    berg.scheduler.workerProxy.invokeCallback = function (now, scoreEventSpecFromWorker, that) {
        var localEventSpec = that.eventSpecMap[scoreEventSpecFromWorker.id],
            callback = localEventSpec.callback;

        if (typeof callback === "function") {
            callback(now, scoreEventSpecFromWorker);
        } else {
            that.events.onError.fire("A callback function was not found for score event: " +
                fluid.prettyPrintJSON(localEventSpec));
        }
    };

    berg.scheduler.workerProxy.makeTransferrableCopy = function (eventSpec) {
        var toTransfer = fluid.copy(eventSpec);
        delete toTransfer.callback; // Functions can't survive the journey to the other universe.

        return toTransfer;
    };

    berg.scheduler.workerProxy.scheduleEvent = function (eventSpec, that) {
        berg.scheduler.expandEventSpec(eventSpec);
        that.eventSpecMap[eventSpec.id] = eventSpec;

        var toTransfer = berg.scheduler.workerProxy.makeTransferrableCopy(eventSpec);
        that.postMessage("scheduleEvent", toTransfer);
    };
})();
;/*
 * Bergson requestAnimationFrame Clock
 * http://github.com/colinbdclark/bergson
 *
 * Copyright 2015, Colin Clark
 * Dual licensed under the MIT and GPL Version 2 licenses.
 */
/*global require, requestAnimationFrame, cancelAnimationFrame*/
var fluid = fluid || require("infusion"),
    berg = fluid.registerNamespace("berg");

(function () {
    "use strict";

    /**
     * The RAF Clock is a realtime clock driven by
     * window.requestAnimationFrame()
     */
    fluid.defaults("berg.clock.raf", {
        gradeNames: ["berg.clock.realtime"],

        freq: 60, // This should be overridden by the user
                  // to match the refresh rate of their display.

        members: {
            requestID: null
        },

        invokers: {
            tick: {
                funcName: "berg.clock.raf.tick",
                args: ["{that}", "{arguments}.0"]
            }
        },

        listeners: {
            "onStart.requestNextTick": {
                priority: "after:updateState",
                funcName: "berg.clock.raf.requestNextTick",
                args: ["{that}"]
            },

            "onStop.cancelNextTick": {
                priority: "after:updateState",
                funcName: "berg.clock.raf.cancelNextTick",
                args: ["{that}"]
            }
        }
    });

    berg.clock.raf.requestNextTick = function (that) {
        that.requestID = requestAnimationFrame(that.tick);
    };

    berg.clock.raf.tick = function (that, now) {
        berg.clock.raf.requestNextTick(that);

        var nowSecs = now / 1000;
        that.time = nowSecs;
        that.events.onTick.fire(nowSecs, that.freq);
    };

    berg.clock.raf.cancelNextTick = function (that) {
        cancelAnimationFrame(that.requestID);
    };
})();
;/*
 * Bergson setInterval Clock
 * http://github.com/colinbdclark/bergson
 *
 * Copyright 2015, Colin Clark
 * Dual licensed under the MIT and GPL Version 2 licenses.
 */
/*global require*/
var fluid = fluid || require("infusion"),
    berg = fluid.registerNamespace("berg");

(function () {
    "use strict";

    fluid.defaults("berg.clock.setInterval", {
        gradeNames: ["berg.clock.realtime"],

        freq: 10,

        members: {
            intervalID: null
        },

        listeners: {
            "onStart.setInterval": {
                priority: "after:updateState",
                funcName: "berg.clock.setInterval.start",
                args: ["{that}"]
            },

            "onStop.clearInterval": {
                priority: "after:updateState",
                funcName: "berg.clock.setInterval.stop",
                args: ["{that}"]
            }
        }
    });

    berg.clock.setInterval.start = function (that) {
        that.intervalID = setInterval(that.tick, 1000 / that.freq);
    };

    berg.clock.setInterval.stop = function (that) {
        clearInterval(that.intervalID);
    };
})();
;/*
 * Bergson Clock Logger
 * http://github.com/colinbdclark/bergson
 *
 * Copyright 2015, Colin Clark
 * Dual licensed under the MIT and GPL Version 2 licenses.
 */
 /*global require, Float32Array*/
var fluid = fluid || require("infusion"),
    berg = fluid.registerNamespace("berg");

(function () {
    "use strict";

    /**
     * Interval Logger logs the interval between ticks over time
     * into a typed array that can be used to analyse the realtime
     * performance of a clock instance (e.g. to determine definitively
     * if the clock is dropping frames).
     */
    fluid.defaults("berg.clock.logger", {
        gradeNames: ["fluid.component"],

        numTicksToLog: 60 * 60 * 20, // Twenty minutes at 60 fps by default.

        members: {
            tickCounter: 0,
            lastTickTime: null,
            interval: 0,
            intervalLog: "@expand:berg.clock.logger.initLog({that}.options.numTicksToLog)"
        },

        invokers: {
            log: "berg.clock.logger.log({that}, {clock})"
        },

        listeners: {
            "{clock}.events.onTick": [
                "{that}.log()"
            ]
        }
    });

    berg.clock.logger.initLog = function (numTicksToLog) {
        return new Float32Array(numTicksToLog);
    };

    berg.clock.logger.log = function (that, clock) {
        // Don't log the first frame.
        if (that.lastTickTime === null) {
            that.lastTickTime = clock.time;
            return;
        }

        if (that.tickCounter < that.options.numTicksToLog) {
            that.tickCounter++;
            that.interval = clock.time - that.lastTickTime;
            that.lastTickTime = clock.time;

            that.intervalLog[that.tickCounter] = that.interval;
        }
    };
})();
;/*global fluid, self*/
(function () {
    "use strict";

    // TODO: This should all be refactored to ultimately
    // support a Nexus-like interaction between universes.
    // At the moment, we only support a single postMessageListener
    // component for the entire Worker scope.

    self.addEventListener("message", function (e) {
        if (e.data.type === "create") {
            if (self.activeComponent) {
                self.activeComponent.destroy();
            }

            self.activeComponent = fluid.invokeGlobalFunction(e.data.args[0], [e.data.args[1]]);
            e.stopPropagation();
        }
    }, true);
})();
